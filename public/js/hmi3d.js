/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.THREE = {})));
}(this, (function (exports) { 'use strict';

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		( function () {

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		} )();

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	var REVISION = '89';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RGB_S3TC_DXT1_Format = 2001;
	var RGBA_S3TC_DXT1_Format = 2002;
	var RGBA_S3TC_DXT3_Format = 2003;
	var RGBA_S3TC_DXT5_Format = 2004;
	var RGB_PVRTC_4BPPV1_Format = 2100;
	var RGB_PVRTC_2BPPV1_Format = 2101;
	var RGBA_PVRTC_4BPPV1_Format = 2102;
	var RGBA_PVRTC_2BPPV1_Format = 2103;
	var RGB_ETC1_Format = 2151;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: ( function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var lut = [];

			for ( var i = 0; i < 256; i ++ ) {

				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();

			}

			return function () {

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				return lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

			};

		} )(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector2();
			var max = new Vector2();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( this.y, this.x );

			if ( angle < 0 ) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new Vector3();

			return function extractRotation( m ) {

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function ( q ) {

			var te = this.elements;

			var x = q._x, y = q._y, z = q._z, w = q._w;
			var x2 = x + x, y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			te[ 0 ] = 1 - ( yy + zz );
			te[ 4 ] = xy - wz;
			te[ 8 ] = xz + wy;

			te[ 1 ] = xy + wz;
			te[ 5 ] = 1 - ( xx + zz );
			te[ 9 ] = yz - wx;

			te[ 2 ] = xz - wy;
			te[ 6 ] = yz + wx;
			te[ 10 ] = 1 - ( xx + yy );

			// last column
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// bottom row
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		lookAt: function () {

			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();

			return function lookAt( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target );

				if ( z.lengthSq() === 0 ) {

					// eye and target are in the same position

					z.z = 1;

				}

				z.normalize();
				x.crossVectors( up, z );

				if ( x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						z.x += 0.0001;

					} else {

						z.z += 0.0001;

					}

					z.normalize();
					x.crossVectors( up, z );

				}

				x.normalize();
				y.crossVectors( z, x );

				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix4( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			this.makeRotationFromQuaternion( quaternion );
			this.scale( scale );
			this.setPosition( position );

			return this;

		},

		decompose: function () {

			var vector = new Vector3();
			var matrix = new Matrix4();

			return function decompose( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				matrix.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// assumes direction vectors vFrom and vTo are normalized

			var v1 = new Vector3();
			var r;

			var EPS = 0.000001;

			return function setFromUnitVectors( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				return this.normalize();

			};

		}(),

		inverse: function () {

			return this.conjugate().normalize();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

			if ( Math.abs( sinHalfTheta ) < 0.001 ) {

				this._w = 0.5 * ( w + this._w );
				this._x = 0.5 * ( x + this._x );
				this._y = 0.5 * ( y + this._y );
				this._z = 0.5 * ( z + this._z );

				return this;

			}

			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix = new Matrix4();

			return function project( camera ) {

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		unproject: function () {

			var matrix = new Matrix4();

			return function unproject( camera ) {

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			var sinPhiRadius = Math.sin( s.phi ) * s.radius;

			this.x = sinPhiRadius * Math.sin( s.theta );
			this.y = Math.cos( s.phi ) * s.radius;
			this.z = sinPhiRadius * Math.cos( s.theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			this.x = c.radius * Math.sin( c.theta );
			this.y = c.y;
			this.z = c.radius * Math.cos( c.theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix3( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			function getDataURL( image ) {

				var canvas;

				if ( image instanceof HTMLCanvasElement ) {

					canvas = image;

				} else {

					canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

					var context = canvas.getContext( '2d' );

					if ( image instanceof ImageData ) {

						context.putImageData( image, 0, 0 );

					} else {

						context.drawImage( image, 0, 0, image.width, image.height );

					}

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

			var output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY
			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = _Math.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: getDataURL( image )
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new Vector4();
					max = new Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.uuid = _Math.generateUUID();

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;

	}

	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	/**
	 * @author tschw
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyCubeTexture = new CubeTexture();

	// --- Base for inner nodes (including the root) ---

	function UniformContainer() {

		this.seq = [];
		this.map = {};

	}

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	// Texture unit allocation

	function allocTexUnits( renderer, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = renderer.allocTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f( gl, v ) {

		gl.uniform1f( this.addr, v );

	}

	function setValue1i( gl, v ) {

		gl.uniform1i( this.addr, v );

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv( gl, v ) {

		if ( v.x === undefined ) {

			gl.uniform2fv( this.addr, v );

		} else {

			gl.uniform2f( this.addr, v.x, v.y );

		}

	}

	function setValue3fv( gl, v ) {

		if ( v.x !== undefined ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

		} else if ( v.r !== undefined ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

		} else {

			gl.uniform3fv( this.addr, v );

		}

	}

	function setValue4fv( gl, v ) {

		if ( v.x === undefined ) {

			gl.uniform4fv( this.addr, v );

		} else {

			 gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm( gl, v ) {

		gl.uniformMatrix2fv( this.addr, false, v.elements || v );

	}

	function setValue3fm( gl, v ) {

		if ( v.elements === undefined ) {

			gl.uniformMatrix3fv( this.addr, false, v );

		} else {

			mat3array.set( v.elements );
			gl.uniformMatrix3fv( this.addr, false, mat3array );

		}

	}

	function setValue4fm( gl, v ) {

		if ( v.elements === undefined ) {

			gl.uniformMatrix4fv( this.addr, false, v );

		} else {

			mat4array.set( v.elements );
			gl.uniformMatrix4fv( this.addr, false, mat4array );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, renderer ) {

		var unit = renderer.allocTextureUnit();
		gl.uniform1i( this.addr, unit );
		renderer.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT6( gl, v, renderer ) {

		var unit = renderer.allocTextureUnit();
		gl.uniform1i( this.addr, unit );
		renderer.setTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValue3iv( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValue4iv( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4

			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4

			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8b60: return setValueT6; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// Array of scalars

	function setValue1fv( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}
	function setValue1iv( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a( gl, v ) {

		gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

	}

	function setValueV3a( gl, v ) {

		gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

	}

	function setValueV4a( gl, v ) {

		gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a( gl, v ) {

		gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

	}

	function setValueM3a( gl, v ) {

		gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

	}

	function setValueM4a( gl, v ) {

		gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

	}

	// Array of textures (2D / Cube)

	function setValueT1a( gl, v, renderer ) {

		var n = v.length,
			units = allocTexUnits( renderer, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6a( gl, v, renderer ) {

		var n = v.length,
			units = allocTexUnits( renderer, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4

			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4

			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function StructuredUniform( id ) {

		this.id = id;

		UniformContainer.call( this ); // mix-in

	}

	StructuredUniform.prototype.setValue = function ( gl, value ) {

		// Note: Don't need an extra 'renderer' parameter, since samplers
		// are not allowed in structured uniforms.

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ] );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		for ( ; ; ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program, renderer ) {

		UniformContainer.call( this );

		this.renderer = renderer;

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				path = info.name,
				addr = gl.getUniformLocation( program, path );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, this.renderer );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, renderer );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function setHSL( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function () {

			var r = this.r, g = this.g, b = this.b;

			this.r = r * r;
			this.g = g * g;
			this.b = b * b;

			return this;

		},

		convertLinearToGamma: function () {

			this.r = Math.sqrt( this.r );
			this.g = Math.sqrt( this.g );
			this.b = Math.sqrt( this.b );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( optionalTarget ) {

			// h,s,l ranges are in 0.0 - 1.0

			var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			var hsl = this.getHSL();

			hsl.h += h; hsl.s += s; hsl.l += l;

			this.setHSL( hsl.h, hsl.s, hsl.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * Uniform Utilities
	 */

	var UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src && ( parameter_src.isColor ||
						parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
						parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
						parameter_src.isTexture ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "\nvec3 transformed = vec3( position );\n";

	var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

	var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

	var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

	var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

	var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

	var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

	var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

	var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";

	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

	var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

	var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";

	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars: lights_pars,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_template: lights_template,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment: normal_fragment,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		points: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: UniformsUtils.merge( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	Object.assign( Box2.prototype, {

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector2();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		getCenter: function ( optionalTarget ) {

			var result = optionalTarget || new Vector2();
			return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( optionalTarget ) {

			var result = optionalTarget || new Vector2();
			return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new Vector2();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		intersectsBox: function ( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector2();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector2();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {

		var vertexBuffer, elementBuffer;
		var shader, program, attributes, uniforms;

		var tempTexture, occlusionTexture;

		function init() {

			var vertices = new Float32Array( [
				- 1, - 1, 0, 0,
				  1, - 1, 1, 0,
				  1, 1, 1, 1,
				- 1, 1, 0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			// buffers

			vertexBuffer = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			// textures

			tempTexture = gl.createTexture();
			occlusionTexture = gl.createTexture();

			state.bindTexture( gl.TEXTURE_2D, tempTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

			shader = {

				vertexShader: [

					'uniform lowp int renderType;',

					'uniform vec3 screenPosition;',
					'uniform vec2 scale;',
					'uniform float rotation;',

					'uniform sampler2D occlusionMap;',

					'attribute vec2 position;',
					'attribute vec2 uv;',

					'varying vec2 vUV;',
					'varying float vVisibility;',

					'void main() {',

					'	vUV = uv;',

					'	vec2 pos = position;',

					'	if ( renderType == 2 ) {',

					'		vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',
					'		visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',

					'		vVisibility =        visibility.r / 9.0;',
					'		vVisibility *= 1.0 - visibility.g / 9.0;',
					'		vVisibility *=       visibility.b / 9.0;',
					'		vVisibility *= 1.0 - visibility.a / 9.0;',

					'		pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',
					'		pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',

					'	}',

					'	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',

					'}'

				].join( '\n' ),

				fragmentShader: [

					'uniform lowp int renderType;',

					'uniform sampler2D map;',
					'uniform float opacity;',
					'uniform vec3 color;',

					'varying vec2 vUV;',
					'varying float vVisibility;',

					'void main() {',

					// pink square

					'	if ( renderType == 0 ) {',

					'		gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',

					// restore

					'	} else if ( renderType == 1 ) {',

					'		gl_FragColor = texture2D( map, vUV );',

					// flare

					'	} else {',

					'		vec4 texture = texture2D( map, vUV );',
					'		texture.a *= opacity * vVisibility;',
					'		gl_FragColor = texture;',
					'		gl_FragColor.rgb *= color;',

					'	}',

					'}'

				].join( '\n' )

			};

			program = createProgram( shader );

			attributes = {
				vertex: gl.getAttribLocation( program, 'position' ),
				uv: gl.getAttribLocation( program, 'uv' )
			};

			uniforms = {
				renderType: gl.getUniformLocation( program, 'renderType' ),
				map: gl.getUniformLocation( program, 'map' ),
				occlusionMap: gl.getUniformLocation( program, 'occlusionMap' ),
				opacity: gl.getUniformLocation( program, 'opacity' ),
				color: gl.getUniformLocation( program, 'color' ),
				scale: gl.getUniformLocation( program, 'scale' ),
				rotation: gl.getUniformLocation( program, 'rotation' ),
				screenPosition: gl.getUniformLocation( program, 'screenPosition' )
			};

		}

		/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */

		this.render = function ( flares, scene, camera, viewport ) {

			if ( flares.length === 0 ) return;

			var tempPosition = new Vector3();

			var invAspect = viewport.w / viewport.z,
				halfViewportWidth = viewport.z * 0.5,
				halfViewportHeight = viewport.w * 0.5;

			var size = 16 / viewport.w,
				scale = new Vector2( size * invAspect, size );

			var screenPosition = new Vector3( 1, 1, 0 ),
				screenPositionPixels = new Vector2( 1, 1 );

			var validArea = new Box2();

			validArea.min.set( viewport.x, viewport.y );
			validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

			if ( program === undefined ) {

				init();

			}

			state.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.vertex );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			// loop through all lens flares to update their occlusion and positions
			// setup gl and common used attribs/uniforms

			gl.uniform1i( uniforms.occlusionMap, 0 );
			gl.uniform1i( uniforms.map, 1 );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			state.disable( gl.CULL_FACE );
			state.buffers.depth.setMask( false );

			for ( var i = 0, l = flares.length; i < l; i ++ ) {

				size = 16 / viewport.w;
				scale.set( size * invAspect, size );

				// calc object screen position

				var flare = flares[ i ];

				tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

				tempPosition.applyMatrix4( camera.matrixWorldInverse );
				tempPosition.applyMatrix4( camera.projectionMatrix );

				// setup arrays for gl programs

				screenPosition.copy( tempPosition );

				// horizontal and vertical coordinate of the lower left corner of the pixels to copy

				screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
				screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

				// screen cull

				if ( validArea.containsPoint( screenPositionPixels ) === true ) {

					// save current RGB to temp texture

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, null );
					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


					// render pink quad

					gl.uniform1i( uniforms.renderType, 0 );
					gl.uniform2f( uniforms.scale, scale.x, scale.y );
					gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

					state.disable( gl.BLEND );
					state.enable( gl.DEPTH_TEST );

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// copy result to occlusionMap

					state.activeTexture( gl.TEXTURE0 );
					state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
					gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


					// restore graphics

					gl.uniform1i( uniforms.renderType, 1 );
					state.disable( gl.DEPTH_TEST );

					state.activeTexture( gl.TEXTURE1 );
					state.bindTexture( gl.TEXTURE_2D, tempTexture );
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


					// update object positions

					flare.positionScreen.copy( screenPosition );

					if ( flare.customUpdateCallback ) {

						flare.customUpdateCallback( flare );

					} else {

						flare.updateLensFlares();

					}

					// render flares

					gl.uniform1i( uniforms.renderType, 2 );
					state.enable( gl.BLEND );

					for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

						var sprite = flare.lensFlares[ j ];

						if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

							screenPosition.x = sprite.x;
							screenPosition.y = sprite.y;
							screenPosition.z = sprite.z;

							size = sprite.size * sprite.scale / viewport.w;

							scale.x = size * invAspect;
							scale.y = size;

							gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
							gl.uniform2f( uniforms.scale, scale.x, scale.y );
							gl.uniform1f( uniforms.rotation, sprite.rotation );

							gl.uniform1f( uniforms.opacity, sprite.opacity );
							gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

							state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );

							textures.setTexture2D( sprite.texture, 1 );

							gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

						}

					}

				}

			}

			// restore gl

			state.enable( gl.CULL_FACE );
			state.enable( gl.DEPTH_TEST );
			state.buffers.depth.setMask( true );

			state.reset();

		};

		function createProgram( shader ) {

			var program = gl.createProgram();

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
			var vertexShader = gl.createShader( gl.VERTEX_SHADER );

			var prefix = 'precision ' + capabilities.precision + ' float;\n';

			gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
			gl.shaderSource( vertexShader, prefix + shader.vertexShader );

			gl.compileShader( fragmentShader );
			gl.compileShader( vertexShader );

			gl.attachShader( program, fragmentShader );
			gl.attachShader( program, vertexShader );

			gl.linkProgram( program );

			return program;

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new Vector3();
		var spriteRotation = new Quaternion();
		var spriteScale = new Vector3();

		function init() {

			var vertices = new Float32Array( [
				- 0.5, - 0.5, 0, 0,
				  0.5, - 0.5, 1, 0,
				  0.5, 0.5, 1, 1,
				- 0.5, 0.5, 0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position: gl.getAttribLocation( program, 'position' ),
				uv: gl.getAttribLocation( program, 'uv' )
			};

			uniforms = {
				uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
				uvScale: gl.getUniformLocation( program, 'uvScale' ),

				rotation: gl.getUniformLocation( program, 'rotation' ),
				scale: gl.getUniformLocation( program, 'scale' ),

				color: gl.getUniformLocation( program, 'color' ),
				map: gl.getUniformLocation( program, 'map' ),
				opacity: gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType: gl.getUniformLocation( program, 'fogType' ),
				fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
				fogNear: gl.getUniformLocation( program, 'fogNear' ),
				fogFar: gl.getUniformLocation( program, 'fogFar' ),
				fogColor: gl.getUniformLocation( program, 'fogColor' ),
				fogDepth: gl.getUniformLocation( program, 'fogDepth' ),

				alphaTest: gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new CanvasTexture( canvas );

		}

		this.render = function ( sprites, scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			state.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog.isFog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog.isFogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				if ( material.visible === false ) continue;

				sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.scale, scale );

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
				state.buffers.depth.setTest( material.depthTest );
				state.buffers.depth.setMask( material.depthWrite );
				state.buffers.color.setMask( material.colorWrite );

				textures.setTexture2D( material.map || texture, 0 );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

				sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );

			}

			// restore gl

			state.enable( gl.CULL_FACE );

			state.reset();

		};

		function createProgram() {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + capabilities.precision + ' float;',

				'#define SHADER_NAME ' + 'SpriteMaterial',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',
				'varying float fogDepth;',

				'void main() {',

				'	vUV = uvOffset + uv * uvScale;',

				'	vec2 alignedPosition = position * scale;',

				'	vec2 rotatedPosition;',
				'	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'	vec4 mvPosition;',

				'	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'	mvPosition.xy += rotatedPosition;',

				'	gl_Position = projectionMatrix * mvPosition;',

				'	fogDepth = - mvPosition.z;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + capabilities.precision + ' float;',

				'#define SHADER_NAME ' + 'SpriteMaterial',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',
				'varying float fogDepth;',

				'void main() {',

				'	vec4 texture = texture2D( map, vUV );',

				'	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'	if ( gl_FragColor.a < alphaTest ) discard;',

				'	if ( fogType > 0 ) {',

				'		float fogFactor = 0.0;',

				'		if ( fogType == 1 ) {',

				'			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',

				'		} else {',

				'			const float LOG2 = 1.442695;',
				'			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
				'			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

				'		}',

				'		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',

				'	}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		}

		function painterSortStable( a, b ) {

			if ( a.renderOrder !== b.renderOrder ) {

				return a.renderOrder - b.renderOrder;

			} else if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}
			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalScale = this.normalScale.toArray();

			}
			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}
			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.overdraw = source.overdraw;

			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector3();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var scope, i, l;

			var v1 = new Vector3();

			function traverse( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			}

			return function expandByObject( object ) {

				scope = this;

				object.updateMatrixWorld( true );

				object.traverse( traverse );

				return this;

			};

		}(),

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, optionalTarget ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			var result = optionalTarget || new Vector3();

			return result.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: ( function () {

			var closestPoint = new Vector3();

			return function intersectsSphere( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			};

		} )(),

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= plane.constant && max >= plane.constant );

		},

		clampPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector3();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new Vector3();

			return function getBoundingSphere( optionalTarget ) {

				var result = optionalTarget || new Sphere();

				this.getCenter( result.center );

				result.radius = this.getSize( v1 ).length() * 0.5;

				return result;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function () {

			var points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3()
			];

			return function applyMatrix4( matrix ) {

				// transform of empty box is an empty box.
				if ( this.isEmpty() ) return this;

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

				this.setFromPoints( points );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new Box3();

			return function setFromPoints( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, optionalTarget ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			var result = optionalTarget || new Vector3();

			result.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				result.sub( this.center ).normalize();
				result.multiplyScalar( this.radius ).add( this.center );

			}

			return result;

		},

		getBoundingBox: function ( optionalTarget ) {

			var box = optionalTarget || new Box3();

			box.set( this.center, this.center );
			box.expandByScalar( this.radius );

			return box;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function setFromCoplanarPoints( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function () {

			var v1 = new Vector3();

			return function intersectLine( line, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return result.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return result.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return result.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new Vector3();
			var m1 = new Matrix3();

			return function applyMatrix4( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new Sphere();

			return function intersectsObject( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSprite: function () {

			var sphere = new Sphere();

			return function intersectsSprite( sprite ) {

				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new Vector3(),
				p2 = new Vector3();

			return function intersectsBox( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];

		// init

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ i ] = depthMaterial;

			//

			var distanceMaterial = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.renderReverseSided = true;
		this.renderSingleSided = true;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			// TODO Clean up (needed in case of contextlost)
			var _gl = _renderer.context;
			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.disable( _gl.BLEND );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			var faceCount;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );

				if ( isPointLight ) {

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				}

				if ( shadow.map === null ) {

					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";

					shadowCamera.updateProjectionMatrix();

				}

				if ( shadow.isSpotLightShadow ) {

					shadow.update( light );

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				if ( isPointLight ) {

					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

				} else {

					faceCount = 1;

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				}

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();

						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );

					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					renderObject( scene, camera, shadowCamera, isPointLight );

				}

			}

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = false;

				if ( material.morphTargets ) {

					if ( geometry && geometry.isBufferGeometry ) {

						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

					} else if ( geometry && geometry.isGeometry ) {

						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

					}

				}

				if ( object.isSkinnedMesh && material.skinning === false ) {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

				var useSkinning = object.isSkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				result = materialVariants[ variantIndex ];

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			var side = material.side;

			if ( scope.renderSingleSided && side == DoubleSide ) {

				side = FrontSide;

			}

			if ( scope.renderReverseSided ) {

				if ( side === FrontSide ) side = BackSide;
				else if ( side === BackSide ) side = FrontSide;

			}

			result.side = side;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( isPointLight && result.isMeshDistanceMaterial ) {

				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, isPointLight ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, isPointLight );

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl ) {

		var buffers = {};

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = gl.FLOAT;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = gl.UNSIGNED_SHORT;

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( attribute.dynamic === false ) {

				gl.bufferData( bufferType, array, gl.STATIC_DRAW );

			} else if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else if ( updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers[ attribute.uuid ];

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers[ attribute.uuid ];

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				delete buffers[ attribute.uuid ];

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers[ attribute.uuid ];

			if ( data === undefined ) {

				buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = _Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix = new Matrix4();

			return function setFromQuaternion( q, order, update ) {

				matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( matrix, order, update );

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new Quaternion();

			return function reorder( newOrder ) {

				q.setFromEuler( this );

				return this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	var object3DId = 0;

	function Object3D() {

		Object.defineProperty( this, 'id', { value: object3DId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new Quaternion();

			return function rotateOnAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateOnWorldAxis: function () {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			var q1 = new Quaternion();

			return function rotateOnWorldAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function rotateX( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function rotateY( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function rotateZ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new Vector3();

			return function translateOnAxis( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function translateX( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function translateY( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function translateZ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new Matrix4();

			return function worldToLocal( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This method does not support objects with rotated and/or translated parent(s)

			var m1 = new Matrix4();
			var vector = new Vector3();

			return function lookAt( x, y, z ) {

				if ( x.isVector3 ) {

					vector.copy( x );

				} else {

					vector.set( x, y, z );

				}

				if ( this.isCamera ) {

					m1.lookAt( this.position, vector, this.up );

				} else {

					m1.lookAt( vector, this.position, this.up );

				}

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.updateMatrixWorld( true );

			return result.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new Vector3();
			var scale = new Vector3();

			return function getWorldQuaternion( optionalTarget ) {

				var result = optionalTarget || new Quaternion();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, result, scale );

				return result;

			};

		}(),

		getWorldRotation: function () {

			var quaternion = new Quaternion();

			return function getWorldRotation( optionalTarget ) {

				var result = optionalTarget || new Euler();

				this.getWorldQuaternion( quaternion );

				return result.setFromQuaternion( quaternion, this.rotation.order, false );

			};

		}(),

		getWorldScale: function () {

			var position = new Vector3();
			var quaternion = new Quaternion();

			return function getWorldScale( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, result );

				return result;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.matrix = this.matrix.toArray();

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.geometry !== undefined ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		},

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}(),

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;

				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {

		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

				scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.getCenter().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeLineDistances: function () {

			var d = 0;
			var vertices = this.vertices;

			for ( var i = 0, il = vertices.length; i < il; i ++ ) {

				if ( i > 0 ) {

					d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

				}

				this.lineDistances[ i ] = d;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			mesh.matrixAutoUpdate && mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = source.morphTargets;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				this.morphTargets.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.uuid = _Math.generateUUID();
		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.onUploadCallback = function () {};

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyIndicesArray: function ( indices ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				var index = indices[ i ];

				array[ offset ++ ] = index.a;
				array[ offset ++ ] = index.b;
				array[ offset ++ ] = index.c;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {

		this.indices = [];
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Object.assign( DirectGeometry.prototype, {

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex = undefined;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		addAttribute: function ( name, attribute ) {

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

				return;

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return;

			}

			this.attributes[ name ] = attribute;

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			this.computeBoundingBox();

			var offset = this.boundingBox.getCenter().negate();

			this.translate( offset.x, offset.y, offset.z );

			return offset;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			if ( geometry.indices.length > 0 ) {

				var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
				var indices = new TypeArray( geometry.indices.length * 3 );
				this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var position = this.attributes.position;

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			var box = new Box3();
			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;

				if ( position ) {

					var center = this.boundingSphere.center;

					box.setFromBufferAttribute( position );
					box.getCenter( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						vector.x = position.getX( i );
						vector.y = position.getY( i );
						vector.z = position.getZ( i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) offset = 0;

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var vector = new Vector3();

			return function normalizeNormals() {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );

					vector.normalize();

					normals.setXYZ( i, vector.x, vector.y, vector.z );

				}

			};

		}(),

		toNonIndexed: function () {

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		BufferGeometry.call( this );

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

		Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = UniformsUtils.clone( source.uniforms );

		this.defines = source.defines;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();

	}

	Object.assign( Ray.prototype, {

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		lookAt: function ( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		},

		recast: function () {

			var v1 = new Vector3();

			return function recast( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, optionalTarget ) {

			var result = optionalTarget || new Vector3();
			result.subVectors( point, this.origin );
			var directionDistance = result.dot( this.direction );

			if ( directionDistance < 0 ) {

				return result.copy( this.origin );

			}

			return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new Vector3();

			return function distanceSqToPoint( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();

			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new Vector3();

			return function intersectSphere( sphere, optionalTarget ) {

				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, optionalTarget );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, optionalTarget );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function ( plane, optionalTarget ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, optionalTarget );

		},

		intersectsPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function ( box, optionalTarget ) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

		},

		intersectsBox: ( function () {

			var v = new Vector3();

			return function intersectsBox( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		} )(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();

			return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, optionalTarget );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	Object.assign( Line3.prototype, {

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		getCenter: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new Vector3();
			var startEnd = new Vector3();

			return function closestPointToPointParameter( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = _Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			var result = optionalTarget || new Vector3();

			return this.delta( result ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		normal: function () {

			var v0 = new Vector3();

			return function normal( a, b, c, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );

				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {

					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

				}

				return result.set( 0, 0, 0 );

			};

		}(),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		barycoordFromPoint: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				var result = optionalTarget || new Vector3();

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );

			};

		}(),

		containsPoint: function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

			};

		}()

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		area: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();

			return function area() {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		midpoint: function ( optionalTarget ) {

			var result = optionalTarget || new Vector3();
			return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		normal: function ( optionalTarget ) {

			return Triangle.normal( this.a, this.b, this.c, optionalTarget );

		},

		plane: function ( optionalTarget ) {

			var result = optionalTarget || new Plane();

			return result.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		barycoordFromPoint: function ( point, optionalTarget ) {

			return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		closestPointToPoint: function () {

			var plane = new Plane();
			var edgeList = [ new Line3(), new Line3(), new Line3() ];
			var projectedPoint = new Vector3();
			var closestPoint = new Vector3();

			return function closestPointToPoint( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				var minDistance = Infinity;

				// project the point onto the plane of the triangle

				plane.setFromCoplanarPoints( this.a, this.b, this.c );
				plane.projectPoint( point, projectedPoint );

				// check if the projection lies within the triangle

				if ( this.containsPoint( projectedPoint ) === true ) {

					// if so, this is the closest point

					result.copy( projectedPoint );

				} else {

					// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

					edgeList[ 0 ].set( this.a, this.b );
					edgeList[ 1 ].set( this.b, this.c );
					edgeList[ 2 ].set( this.c, this.a );

					for ( var i = 0; i < edgeList.length; i ++ ) {

						edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

						var distance = projectedPoint.distanceToSquared( closestPoint );

						if ( distance < minDistance ) {

							minDistance = distance;

							result.copy( closestPoint );

						}

					}

				}

				return result;

			};

		}(),

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode: function ( value ) {

			this.drawMode = value;

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.drawMode = source.drawMode;

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						name = morphTargets[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		},

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			var barycoord = new Vector3();

			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();

			function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

				Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

				uv1.multiplyScalar( barycoord.x );
				uv2.multiplyScalar( barycoord.y );
				uv3.multiplyScalar( barycoord.z );

				uv1.add( uv2 ).add( uv3 );

				return uv1.clone();

			}

			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

				var intersect;

				if ( material.side === BackSide ) {

					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

				} else {

					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

				}

				if ( intersect === null ) return null;

				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

				if ( distance < raycaster.near || distance > raycaster.far ) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );

				var intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );

				if ( intersection ) {

					if ( uv ) {

						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );

						intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

					}

					intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
					intersection.faceIndex = a;

				}

				return intersection;

			}

			return function raycast( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) return;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var uv = geometry.attributes.uv;
					var i, l;

					if ( index !== null ) {

						// indexed buffer geometry

						for ( i = 0, l = index.count; i < l; i += 3 ) {

							a = index.getX( i );
							b = index.getX( i + 1 );
							c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
								intersects.push( intersection );

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						for ( i = 0, l = position.count; i < l; i += 3 ) {

							a = i;
							b = i + 1;
							c = i + 2;

							intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

							if ( intersection ) {

								intersection.index = a; // triangle number in positions buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) continue;

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						if ( faceMaterial.morphTargets === true ) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;

							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );

							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

								var influence = morphInfluences[ t ];

								if ( influence === 0 ) continue;

								var targets = morphTargets[ t ].vertices;

								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

							}

							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );

							fvA = vA;
							fvB = vB;
							fvC = vC;

						}

						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );

								intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeCamera, planeMesh;
		var boxMesh;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && background.isCubeTexture ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							uniforms: ShaderLib.cube.uniforms,
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: true,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					geometries.update( boxMesh.geometry );

				}

				boxMesh.material.uniforms.tCube.value = background;

				renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeCamera === undefined ) {

					planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
					);

					geometries.update( planeMesh.geometry );

				}

				planeMesh.material.map = background;

				// TODO Push this to renderList

				renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program && b.program && a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function push( object, geometry, material, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			( material.transparent === true ? transparent : opaque ).push( renderItem );

			renderItemsIndex ++;

		}

		function sort() {

			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = {};

		function get( scene, camera ) {

			var hash = scene.id + ',' + camera.id;
			var list = lists[ hash ];

			if ( list === undefined ) {

				// console.log( 'THREE.WebGLRenderLists:', hash );

				list = new WebGLRenderList();
				lists[ hash ] = list;

			}

			return list;

		}

		function dispose() {

			lists = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			var length = objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {

					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {

						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			infoRender.calls ++;
			infoRender.vertices += count;

			if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += count;

		}

		function renderInstances( geometry, start, count ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

			infoRender.calls ++;
			infoRender.vertices += count * geometry.maxInstancedCount;

			if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, infoRender ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			infoRender.calls ++;
			infoRender.vertices += count;

			if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += count;

		}

		function renderInstances( geometry, start, count ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			var position = geometry.attributes.position;

			if ( position.isInterleavedBufferAttribute ) {

				count = position.data.count;

				extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

			} else {

				extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

			}

			infoRender.calls ++;
			infoRender.vertices += count * geometry.maxInstancedCount;

			if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
			else if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, infoMemory ) {

		var geometries = {};
		var wireframeAttributes = {};

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			// TODO Remove duplicate code

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ geometry.id ];

			}

			attribute = wireframeAttributes[ buffergeometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];

			}

			//

			infoMemory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			infoMemory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function getWireframeAttribute( geometry ) {

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) return attribute;

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryAttributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

			attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

			wireframeAttributes[ geometry.id ] = attribute;

			return attribute;

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function WebGLLights() {

		var cache = new UniformsCache();

		var state = {

			hash: '',

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms = cache.get( light );

					// (a) intensity controls irradiance of entire light
					uniforms.color
						.copy( color )
						.multiplyScalar( intensity / ( light.width * light.height ) );

					// (b) intensity controls the radiance per light area
					// uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;

					}

					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms = cache.get( light );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			// TODO (sam-g-steel) why aren't we using join
			state.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( geometries, infoRender ) {

		var updateList = {};

		function update( object ) {

			var frame = infoRender.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateList[ buffergeometry.id ] !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateList[ buffergeometry.id ] = frame;

			}

			return buffergeometry;

		}

		function clear() {

			updateList = {};

		}

		return {

			update: update,
			clear: clear

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function parseIncludes( string ) {

		var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

		function replace( match, include ) {

			var replace = ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = generateExtensions( material.extensions, parameters, extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
				'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );

		if ( ! material.isShaderMaterial ) {

			vertexShader = unrollLoops( vertexShader );
			fragmentShader = unrollLoops( fragmentShader );

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program );
		var vertexLog = gl.getShaderInfoLog( glVertexShader );
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program, renderer );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];


		function allocateBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( capabilities.floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

				encoding = GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( material.fragmentShader );
				array.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					array.push( name );
					array.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( material.onBeforeCompile.toString() );

			array.push( renderer.gammaOutput );

			return array.join();

		};

		this.acquireProgram = function ( material, shader, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {

		var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );
		var _videoTextures = {};

		//

		function clampToMaxSize( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

		}

		function makePowerOfTwo( image ) {

			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = _Math.floorPowerOfTwo( image.width );
				canvas.height = _Math.floorPowerOfTwo( image.height );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function textureNeedsPowerOfTwo( texture ) {

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

			return texture.generateMipmaps && isPowerOfTwo &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				delete _videoTextures[ texture.id ];

			}

			infoMemory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			infoMemory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//



		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						infoMemory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

						_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setTextureCubeDynamic( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

			var extension;

			if ( isPowerOfTwoImage ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				if ( texture.isVideoTexture ) {

					_videoTextures[ texture.id ] = texture;

				}

				infoMemory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

				image = makePowerOfTwo( image );

			}

			var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				var internalFormat = _gl.DEPTH_COMPONENT;

				if ( texture.type === FloatType ) {

					if ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					internalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( _isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					internalFormat = _gl.DEPTH_COMPONENT16;

				}

				if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					internalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

					}

				} else {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			infoMemory.textures ++;

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

				var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				_gl.generateMipmap( target );
				state.bindTexture( target, null );

			}

		}

		function updateVideoTextures() {

			for ( var id in _videoTextures ) {

				_videoTextures[ id ].update();

			}

		}

		this.setTexture2D = setTexture2D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateVideoTextures = updateVideoTextures;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = {};

		function get( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		}

		function remove( object ) {

			delete properties[ object.uuid ];

		}

		function clear() {

			properties = {};

		}

		return {
			get: get,
			remove: remove,
			clear: clear
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, utils ) {

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( gl.NEVER );
									break;

								case AlwaysDepth:

									gl.depthFunc( gl.ALWAYS );
									break;

								case LessDepth:

									gl.depthFunc( gl.LESS );
									break;

								case LessEqualDepth:

									gl.depthFunc( gl.LEQUAL );
									break;

								case EqualDepth:

									gl.depthFunc( gl.EQUAL );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( gl.GEQUAL );
									break;

								case GreaterDepth:

									gl.depthFunc( gl.GREATER );
									break;

								case NotEqualDepth:

									gl.depthFunc( gl.NOTEQUAL );
									break;

								default:

									gl.depthFunc( gl.LEQUAL );

							}

						} else {

							gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
		var lineWidthAvailable = parseFloat( version ) >= 1.0;

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== 0 ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				extension.vertexAttribDivisorANGLE( attribute, 0 );
				attributeDivisors[ attribute ] = 0;

			}

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( capabilities[ id ] !== true ) {

				gl.enable( id );
				capabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( capabilities[ id ] !== false ) {

				gl.disable( id );
				capabilities[ id ] = false;

			}

		}

		function getCompressedTextureFormats() {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending !== NoBlending ) {

				enable( gl.BLEND );

			} else {

				disable( gl.BLEND );

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					switch ( blending ) {

						case AdditiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

							}
							break;

						case SubtractiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

							}
							break;

						case MultiplyBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

							}
							break;

						default:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							}

					}

				}

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			} else {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			material.transparent === true
				? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
				: setBlending( NoBlending );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		return {

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera( array ) {

		PerspectiveCamera.call( this );

		this.cameras = array || [];

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager( renderer ) {

		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

			frameData = new window.VRFrameData();

		}

		var matrixWorldInverse = new Matrix4();

		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );

		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		var currentSize, currentPixelRatio;

		function onVRDisplayPresentChange() {

			if ( device !== null && device.isPresenting ) {

				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth;
				var renderHeight = eyeParameters.renderHeight;

				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();

				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

			} else if ( scope.enabled ) {

				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

			}

		}

		if ( typeof window !== 'undefined' ) {

			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

		}

		//

		this.enabled = false;

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

		};

		this.setPoseTarget = function ( object ) {

			if ( object !== undefined ) poseTarget = object;

		};

		this.getCamera = function ( camera ) {

			if ( device === null ) return camera;

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData( frameData );

			//

			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;

			if ( pose.position !== null ) {

				poseObject.position.fromArray( pose.position );

			} else {

				poseObject.position.set( 0, 0, 0 );

			}

			if ( pose.orientation !== null ) {

				poseObject.quaternion.fromArray( pose.orientation );

			}

			poseObject.updateMatrixWorld();

			if ( device.isPresenting === false ) return camera;

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraVR.matrixWorld.copy( camera.matrixWorld );
			cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

			var parent = poseObject.parent;

			if ( parent !== null ) {

				matrixWorldInverse.getInverse( parent.matrixWorld );

				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

			// HACK @mrdoob
			// https://github.com/w3c/webvr/issues/203

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			//

			var layers = device.getLayers();

			if ( layers.length ) {

				var layer = layers[ 0 ];

				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

					cameraL.bounds.fromArray( layer.leftBounds );

				}

				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

					cameraR.bounds.fromArray( layer.rightBounds );

				}

			}

			return cameraVR;

		};

		this.submitFrame = function () {

			if ( device && device.isPresenting ) device.submitFrame();

		};

		this.dispose = function () {

			if ( typeof window !== 'undefined' ) {

				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					case 'WEBGL_compressed_texture_etc1':
						extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;

			return dstArray;

		}

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions ) {

		function convert( p ) {

			var extension;

			if ( p === RepeatWrapping ) return gl.REPEAT;
			if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
			if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

			if ( p === NearestFilter ) return gl.NEAREST;
			if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
			if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

			if ( p === LinearFilter ) return gl.LINEAR;
			if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
			if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) return extension.HALF_FLOAT_OES;

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			if ( p === AddEquation ) return gl.FUNC_ADD;
			if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
			if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

			if ( p === ZeroFactor ) return gl.ZERO;
			if ( p === OneFactor ) return gl.ONE;
			if ( p === SrcColorFactor ) return gl.SRC_COLOR;
			if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
			if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
			if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
			if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
			if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

			if ( p === DstColorFactor ) return gl.DST_COLOR;
			if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
			if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			if ( p === MinEquation || p === MaxEquation ) {

				extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;

				}

			}

			if ( p === UnsignedInt248Type ) {

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

			}

			return 0;

		}

		return { convert: convert };

	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		console.log( 'THREE.WebGLRenderer', REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		var lightsArray = [];
		var shadowsArray = [];

		var currentRenderList = null;

		var spritesArray = [];
		var flaresArray = [];

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_usedTextureUnits = 0,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3(),

			// info

			_infoMemory = {
				geometries: 0,
				textures: 0
			},

			_infoRender = {

				frame: 0,
				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			};

		this.info = {

			render: _infoRender,
			memory: _infoMemory,
			programs: null

		};

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );

		}

		var extensions, capabilities, state;
		var properties, textures, attributes, geometries, objects, lights;
		var programCache, renderLists;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
		var flareRenderer, spriteRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'ANGLE_instanced_arrays' );

			utils = new WebGLUtils( _gl, extensions );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			state = new WebGLState( _gl, extensions, utils );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
			objects = new WebGLObjects( geometries, _infoRender );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			lights = new WebGLLights();
			renderLists = new WebGLRenderLists();

			background = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

			flareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );
			spriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );

			_this.info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;

		}

		initGLContext();

		// vr

		var vr = new WebVRManager( _this );

		this.vr = vr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			var device = vr.getDevice();

			if ( device && device.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function () {

			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio
			};

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport( 0, 0, width, height );

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewport.set( x, _height - y - height, width, height );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissor = function ( x, y, width, height ) {

			_scissor.set( x, _height - y - height, width, height );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();

			vr.dispose();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program, material ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program, material );

			} );

		}

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

				if ( ! material.isMeshPhongMaterial &&
					! material.isMeshStandardMaterial &&
					! material.isMeshNormalMaterial &&
					material.flatShading === true ) {

					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

						var array = object.normalArray;

						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;

						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;

						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.normal );

				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.uv );

				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.color );

				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			state.setMaterial( material, frontFaceCW );

			var program = setProgram( camera, fog, material, object );
			var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

			var updateBuffers = false;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( object.morphTargetInfluences ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

				}

			}

			//

			var dataCount = 0;

			if ( index !== null ) {

				dataCount = index.count;

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					switch ( object.drawMode ) {

						case TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;

						case TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;

						case TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;

					}

				}


			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			}

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry, drawStart, drawCount );

				}

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry, startIndex ) {

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			if ( startIndex === undefined ) startIndex = 0;

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			lightsArray.length = 0;
			shadowsArray.length = 0;

			scene.traverse( function ( object ) {

				if ( object.isLight ) {

					lightsArray.push( object );

					if ( object.castShadow ) {

						shadowsArray.push( object );

					}

				}

			} );

			lights.setup( lightsArray, shadowsArray, camera );

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							initMaterial( object.material[ i ], scene.fog, object );

						}

					} else {

						initMaterial( object.material, scene.fog, object );

					}

				}

			} );

		};

		// Animation Loop

		var isAnimating = false;
		var onAnimationFrame = null;

		function start() {

			if ( isAnimating ) return;

			var device = vr.getDevice();

			if ( device && device.isPresenting ) {

				device.requestAnimationFrame( loop );

			} else {

				window.requestAnimationFrame( loop );

			}

			isAnimating = true;

		}

		function loop( time ) {

			if ( onAnimationFrame !== null ) onAnimationFrame( time );

			var device = vr.getDevice();

			if ( device && device.isPresenting ) {

				device.requestAnimationFrame( loop );

			} else {

				window.requestAnimationFrame( loop );

			}

		}

		this.animate = function ( callback ) {

			onAnimationFrame = callback;
			start();

		};

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( vr.enabled ) {

				camera = vr.getCamera( camera );

			}

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			lightsArray.length = 0;
			shadowsArray.length = 0;

			spritesArray.length = 0;
			flaresArray.length = 0;

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, _this.sortObjects );

			if ( _this.sortObjects === true ) {

				currentRenderList.sort();

			}

			//

			textures.updateVideoTextures();

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			shadowMap.render( shadowsArray, scene, camera );

			lights.setup( lightsArray, shadowsArray, camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			_infoRender.frame ++;
			_infoRender.calls = 0;
			_infoRender.vertices = 0;
			_infoRender.faces = 0;
			_infoRender.points = 0;

			if ( renderTarget === undefined ) {

				renderTarget = null;

			}

			this.setRenderTarget( renderTarget );

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			// custom renderers

			spriteRenderer.render( spritesArray, scene, camera );
			flareRenderer.render( flaresArray, scene, camera, _currentViewport );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget ) {

				textures.updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			if ( vr.enabled ) {

				vr.submitFrame();

			}

			// _gl.finish();

		};

		/*
		// TODO Duplicated code (Frustum)

		var _sphere = new Sphere();

		function isObjectViewable( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSpriteViewable( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSphereViewable( sphere ) {

			if ( ! _frustum.intersectsSphere( sphere ) ) return false;

			var numPlanes = _clipping.numPlanes;

			if ( numPlanes === 0 ) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

			} while ( ++ i !== numPlanes );

			return true;

		}
		*/

		function projectObject( object, camera, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isLight ) {

					lightsArray.push( object );

					if ( object.castShadow ) {

						shadowsArray.push( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						spritesArray.push( object );

					}

				} else if ( object.isLensFlare ) {

					flaresArray.push( object );

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						object.skeleton.update();

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							var bounds = camera2.bounds;

							var x = bounds.x * _width;
							var y = bounds.y * _height;
							var width = bounds.z * _width;
							var height = bounds.w * _height;

							state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				state.setMaterial( material, frontFaceCW );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram = '';

				renderObjectImmediate( object, program, material );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function initMaterial( material, fog, object ) {

			var materialProperties = properties.get( material );

			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = ShaderLib[ parameters.shaderID ];

					materialProperties.shader = {
						name: material.type,
						uniforms: UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.onBeforeCompile( materialProperties.shader );

				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.shader.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = fog;

			// store the light setup it was created for

			materialProperties.lightsHash = lights.state.hash;

			if ( material.lights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.needsUpdate === false ) {

				if ( materialProperties.program === undefined ) {

					material.needsUpdate = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					material.needsUpdate = true;

				} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {

					material.needsUpdate = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					material.needsUpdate = true;

				}

			}

			if ( material.needsUpdate ) {

				initMaterial( material, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// Avoid unneeded uniform updates per ArrayCamera's sub-camera

				if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

					_currentCamera = ( _currentArrayCamera || camera );

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( material.lights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshLambertMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );

				} else if ( material.isMeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else {

						refreshUniformsPhong( m_uniforms, material );

					}

				} else if ( material.isMeshStandardMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else {

						refreshUniformsStandard( m_uniforms, material );

					}

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshDistanceMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
				if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;

				WebGLUniforms.upload(
					_gl, materialProperties.uniformsList, m_uniforms, _this );

			}


			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value = material.color;

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;
					var rotation = uvScaleMap.rotation;
					var center = uvScaleMap.center;

					uvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					var offset = material.map.offset;
					var repeat = material.map.repeat;
					var rotation = material.map.rotation;
					var center = material.map.center;

					material.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			refreshUniformsPhong( uniforms, material );

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

			refreshUniformsStandard( uniforms, material );

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		// GL state setting

		this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

			state.setCullFace( cullFace );
			state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

		};

		// Textures

		function allocTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		this.allocTextureUnit = allocTextureUnit;

		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function () {

			var warned = false;

			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {

				if ( texture && texture.isWebGLRenderTarget ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTexture = ( function () {

			var warned = false;

			return function setTexture( texture, slot ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTextureCube = ( function () {

			var warned = false;

			return function setTextureCube( texture, slot ) {

				// backwards compatibility: peel texture.texture
				if ( texture && texture.isWebGLRenderTargetCube ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture && texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );

				} else {

					// assumed: texture property of THREE.WebGLRenderTargetCube

					textures.setTextureCubeDynamic( texture, slot );

				}

			};

		}() );

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget ) {

			_currentRenderTarget = renderTarget;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = null;
			var isCube = false;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLRenderTargetCube ) {

					framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
					isCube = true;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2( color, density ) {

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	FogExp2.prototype.isFogExp2 = true;

	FogExp2.prototype.clone = function () {

		return new FogExp2( this.color.getHex(), this.density );

	};

	FogExp2.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog( color, near, far ) {

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	Fog.prototype.isFog = true;

	Fog.prototype.clone = function () {

		return new Fog( this.color.getHex(), this.near, this.far );

	};

	Fog.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function LensFlare( texture, size, distance, blending, color ) {

		Object3D.call( this );

		this.lensFlares = [];

		this.positionScreen = new Vector3();
		this.customUpdateCallback = undefined;

		if ( texture !== undefined ) {

			this.add( texture, size, distance, blending, color );

		}

	}

	LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LensFlare,

		isLensFlare: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.positionScreen.copy( source.positionScreen );
			this.customUpdateCallback = source.customUpdateCallback;

			for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

				this.lensFlares.push( source.lensFlares[ i ] );

			}

			return this;

		},

		add: function ( texture, size, distance, blending, color, opacity ) {

			if ( size === undefined ) size = - 1;
			if ( distance === undefined ) distance = 0;
			if ( opacity === undefined ) opacity = 1;
			if ( color === undefined ) color = new Color( 0xffffff );
			if ( blending === undefined ) blending = NormalBlending;

			distance = Math.min( distance, Math.max( 0, distance ) );

			this.lensFlares.push( {
				texture: texture,	// THREE.Texture
				size: size, 		// size in pixels (-1 = use texture.width)
				distance: distance, 	// distance (0-1) from light source (0=at light source)
				x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
				scale: 1, 		// scale
				rotation: 0, 		// rotation
				opacity: opacity,	// opacity
				color: color,		// color
				blending: blending	// blending
			} );

		},

		/*
		 * Update lens flares update positions on all flares based on the screen position
		 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
		 */

		updateLensFlares: function () {

			var f, fl = this.lensFlares.length;
			var flare;
			var vecX = - this.positionScreen.x * 2;
			var vecY = - this.positionScreen.y * 2;

			for ( f = 0; f < fl; f ++ ) {

				flare = this.lensFlares[ f ];

				flare.x = this.positionScreen.x + vecX * flare.distance;
				flare.y = this.positionScreen.y + vecY * flare.distance;

				flare.wantedRotation = flare.x * Math.PI * 0.25;
				flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */

	function SpriteMaterial( parameters ) {

		Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		return this;

	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Sprite( material ) {

		Object3D.call( this );

		this.type = 'Sprite';

		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

	}

	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Sprite,

		isSprite: true,

		raycast: ( function () {

			var intersectPoint = new Vector3();
			var worldPosition = new Vector3();
			var worldScale = new Vector3();

			return function raycast( raycaster, intersects ) {

				worldPosition.setFromMatrixPosition( this.matrixWorld );
				raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

				worldScale.setFromMatrixScale( this.matrixWorld );
				var guessSizeSq = worldScale.x * worldScale.y / 4;

				if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					point: intersectPoint.clone(),
					face: null,
					object: this

				} );

			};

		}() ),

		clone: function () {

			return new this.constructor( this.material ).copy( this );

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {

		Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		},

		raycast: ( function () {

			var matrixPosition = new Vector3();

			return function raycast( raycaster, intersects ) {

				matrixPosition.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			};

		}() ),

		update: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function update( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );

					var distance = v1.distanceTo( v2 );

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton( bones, boneInverses ) {

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	Object.assign( Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.getInverse( this.bones[ i ].matrixWorld );

				}

				this.boneInverses.push( inverse );

			}

		},

		pose: function () {

			var bone, i, il;

			// recover the bind-time world matrices

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		},

		update: ( function () {

			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();

			return function update() {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			};

		} )(),

		clone: function () {

			return new Skeleton( this.bones, this.boneInverses );

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh( geometry, material ) {

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

		var bones = this.initBones();
		var skeleton = new Skeleton( bones );

		this.bind( skeleton, this.matrixWorld );

		this.normalizeSkinWeights();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		initBones: function () {

			var bones = [], bone, gbone;
			var i, il;

			if ( this.geometry && this.geometry.bones !== undefined ) {

				// first, create array of 'Bone' objects from geometry data

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					// create new 'Bone' object

					bone = new Bone();
					bones.push( bone );

					// apply values

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				// second, create bone hierarchy

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

						// subsequent bones in the hierarchy

						bones[ gbone.parent ].add( bones[ i ] );

					} else {

						// topmost bone, immediate child of the skinned mesh

						this.add( bones[ i ] );

					}

				}

			}

			// now the bones are part of the scene graph and children of the skinned mesh.
			// let's update the corresponding matrices

			this.updateMatrixWorld( true );

			return bones;

		},

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var scale, i;

			if ( this.geometry && this.geometry.isGeometry ) {

				for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

					var sw = this.geometry.skinWeights[ i ];

					scale = 1.0 / sw.manhattanLength();

					if ( scale !== Infinity ) {

						sw.multiplyScalar( scale );

					} else {

						sw.set( 1, 0, 0, 0 ); // do something reasonable

					}

				}

			} else if ( this.geometry && this.geometry.isBufferGeometry ) {

				var vec = new Vector4();

				var skinWeight = this.geometry.attributes.skinWeight;

				for ( i = 0; i < skinWeight.count; i ++ ) {

					vec.x = skinWeight.getX( i );
					vec.y = skinWeight.getY( i );
					vec.z = skinWeight.getZ( i );
					vec.w = skinWeight.getW( i );

					scale = 1.0 / vec.manhattanLength();

					if ( scale !== Infinity ) {

						vec.multiplyScalar( scale );

					} else {

						vec.set( 1, 0, 0, 0 ); // do something reasonable

					}

					skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

				}

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.getInverse( this.matrixWorld );

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.getInverse( this.bindMatrix );

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new LineSegments( geometry, material );

		}

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true

	} );

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineLoop';

	}

	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineLoop,

		isLineLoop: true,

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.lights = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points( geometry, material ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();

				function testPoint( point, index ) {

					var rayPointDistanceSq = ray.distanceSqToPoint( point );

					if ( rayPointDistanceSq < localThresholdSq ) {

						var intersectPoint = ray.closestPointToPoint( point );
						intersectPoint.applyMatrix4( matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

						if ( distance < raycaster.near || distance > raycaster.far ) return;

						intersects.push( {

							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						} );

					}

				}

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							position.fromArray( positions, i * 3 );

							testPoint( position, i );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

		// Set needsUpdate when first frame is ready

		var scope = this;

		function onLoaded() {

			video.removeEventListener( 'loadeddata', onLoaded, false );
			scope.needsUpdate = true;

		}

		video.addEventListener( 'loadeddata', onLoaded, false );

	}

	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update: function () {

			var video = this.image;

			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry( geometry ) {

		BufferGeometry.call( this );

		this.type = 'WireframeGeometry';

		// buffer

		var vertices = [];

		// helper variables

		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			var faces = geometry.faces;

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			var position, indices, groups;
			var group, start, count;
			var index1, index2;

			vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

					group = groups[ o ];

					start = group.start;
					count = group.count;

					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( j = 0; j < 3; j ++ ) {

							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry( func, slices, stacks ) {

		Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();

	}

	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		var i, j;

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				p0 = func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					p1 = func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					p1 = func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					p1 = func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					p1 = func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry( vertices, indices, radius, detail ) {

		Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

		BufferGeometry.call( this );

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		var vertexBuffer = [];
		var uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( var i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			var cols = Math.pow( 2, detail );

			// we use this multidimensional array as a data structure for creating the subdivision

			var v = [];

			var i, j;

			// construct all of the vertices for this subdivision

			for ( i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );

				var rows = cols - i;

				for ( j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( i = 0; i < cols; i ++ ) {

				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function appplyRadius( radius ) {

			var vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			var vertex = new Vector3();

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];

				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			var stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			var centroid = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				var azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (1, 1, 1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, 1/, )
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,

			// (1/, , 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,

			// (, 0, 1/)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

		Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

		BufferGeometry.call( this );

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();

		var i, j;

		// buffer

		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( j = 0; j <= radialSegments; j ++ ) {

				var v = j / radialSegments * Math.PI * 2;

				var sin = Math.sin( v );
				var cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				for ( j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

		BufferGeometry.call( this );

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, j;

		var vertex = new Vector3();
		var normal = new Vector3();

		var P1 = new Vector3();
		var P2 = new Vector3();

		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();

		// generate vertices, normals and uvs

		for ( i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				// indices

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		BufferGeometry.call( this );

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= radialSegments; j ++ ) {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= radialSegments; j ++ ) {

			for ( i = 1; i <= tubularSegments; i ++ ) {

				// indices

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];

			if ( ! outerNode ) return triangles;

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points

	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		var p = start, again;

		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order

		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		var stop = ear, prev, next;

		// iterate through ears, slicing them one by one

		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if ( ear === stop ) {

				// try filtering points and slicing again

				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

				return false;

			}

			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;

		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		// first look for points inside the triangle in increasing z-order

		var p = ear.nextZ;

		while ( p && p.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;

		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;

			p = p.prevZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;

		do {

			var a = p.prev, b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved

				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return p;

	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two

		var a = start;

		do {

			var b = a.next.next;

			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal

					var c = splitPolygon( a, b );

					// filter colinear points around the cuts

					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half

					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [], i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right

		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );

		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge( hole, outerNode ) {

		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

				if ( x <= hx && x > qx ) {

					qx = x;

					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;

		p = m.next;

		while ( p !== stop ) {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		}

		return m;

	}

	// interlink polygon nodes in z-order

	function indexCurve( start, minX, minY, invSize ) {

		var p = start;

		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;

				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring

	function getLeftmost( start ) {

		var p = start, leftmost = start;

		do {

			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle

	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

	}

	// signed area of a triangle

	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal

	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect

	function intersects( p1, q1, p2, q2 ) {

		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon( a, b ) {

		var p = a;

		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {

				return true;

			}

			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside( a, b ) {

		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;

		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

				inside = ! inside;

			}

			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;

		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			function removeDupEndPts( points ) {

				var l = points.length;

				if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

					points.pop();

				}

			}

			function addContour( vertices, contour ) {

				for ( var i = 0; i < contour.length; i ++ ) {

					vertices.push( contour[ i ].x );
					vertices.push( contour[ i ].y );

				}

			}

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;
			holes.forEach( removeDupEndPts );

			for ( i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *  frames: <Object> // containing arrays of tangents, normals, binormals
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry( shapes, options ) {

		Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry( shapes, options ) {

		if ( typeof ( shapes ) === "undefined" ) {

			return;

		}

		BufferGeometry.call( this );

		this.type = 'ExtrudeBufferGeometry';

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		this.addShapeList( shapes, options );

		this.computeVertexNormals();

		// can't really use automatic vertex normals
		// as then front and back sides get smoothed too
		// should do separate smoothing just for sides

		//this.computeVertexNormals();

		//console.log( "took", ( Date.now() - startTime ) );

	}

	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.getArrays = function () {

		var positionAttribute = this.getAttribute( "position" );
		var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

		var uvAttribute = this.getAttribute( "uv" );
		var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

		var IndexAttribute = this.index;
		var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

		return {
			position: verticesArray,
			uv: uvArray,
			index: indicesArray
		};

	};

	ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {

		var sl = shapes.length;
		options.arrays = this.getArrays();

		for ( var s = 0; s < sl; s ++ ) {

			var shape = shapes[ s ];
			this.addShape( shape, options );

		}

		this.setIndex( options.arrays.index );
		this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );

	};

	ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {

		var arrays = options.arrays ? options.arrays : this.getArrays();
		var verticesArray = arrays.position;
		var indicesArray = arrays.index;
		var uvArray = arrays.uv;

		var placeholder = [];


		var amount = options.amount !== undefined ? options.amount : 100;

		var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
		var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
		var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

		var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

		var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

		var steps = options.steps !== undefined ? options.steps : 1;

		var extrudePath = options.extrudePath;
		var extrudePts, extrudeByPath = false;

		// Use default WorldUVGenerator if no UV generators are specified.
		var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

		var splineTube, binormal, normal, position2;
		if ( extrudePath ) {

			extrudePts = extrudePath.getSpacedPoints( steps );

			extrudeByPath = true;
			bevelEnabled = false; // bevels not supported for path extrusion

			// SETUP TNB variables

			// TODO1 - have a .isClosed in spline?

			splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

			// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

			binormal = new Vector3();
			normal = new Vector3();
			position2 = new Vector3();

		}

		// Safeguards if bevels are not enabled

		if ( ! bevelEnabled ) {

			bevelSegments = 0;
			bevelThickness = 0;
			bevelSize = 0;

		}

		// Variables initialization

		var ahole, h, hl; // looping of holes
		var scope = this;

		var shapePoints = shape.extractPoints( curveSegments );

		var vertices = shapePoints.shape;
		var holes = shapePoints.holes;

		var reverse = ! ShapeUtils.isClockWise( vertices );

		if ( reverse ) {

			vertices = vertices.reverse();

			// Maybe we should also check if holes are in the opposite direction, just to be safe ...

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				if ( ShapeUtils.isClockWise( ahole ) ) {

					holes[ h ] = ahole.reverse();

				}

			}

		}


		var faces = ShapeUtils.triangulateShape( vertices, holes );

		/* Vertices */

		var contour = vertices; // vertices has all points but contour has only points of circumference

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			vertices = vertices.concat( ahole );

		}


		function scalePt2( pt, vec, size ) {

			if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

			return vec.clone().multiplyScalar( size ).add( pt );

		}

		var b, bs, t, z,
			vert, vlen = vertices.length,
			face, flen = faces.length;


		// Find directions for point movement


		function getBevelVec( inPt, inPrev, inNext ) {

			// computes for inPt the corresponding point inPt' on a new contour
			//   shifted by 1 unit (length of normalized vector) to the left
			// if we walk along contour clockwise, this new contour is outside the old one
			//
			// inPt' is the intersection of the two lines parallel to the two
			//  adjacent edges of inPt at a distance of 1 unit on the left side.

			var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

			// good reading for geometry algorithms (here: line-line intersection)
			// http://geomalgorithms.com/a05-_intersect-1.html

			var v_prev_x = inPt.x - inPrev.x,
				v_prev_y = inPt.y - inPrev.y;
			var v_next_x = inNext.x - inPt.x,
				v_next_y = inNext.y - inPt.y;

			var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

			// check for collinear edges
			var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			if ( Math.abs( collinear0 ) > Number.EPSILON ) {

				// not collinear

				// length of vectors for normalizing

				var v_prev_len = Math.sqrt( v_prev_lensq );
				var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

				// shift adjacent points by unit vectors to the left

				var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
				var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

				var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
				var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

				// scaling factor for v_prev to intersection point

				var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
					( v_prev_x * v_next_y - v_prev_y * v_next_x );

				// vector from inPt to intersection point

				v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
				v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

				// Don't normalize!, otherwise sharp corners become ugly
				//  but prevent crazy spikes
				var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
				if ( v_trans_lensq <= 2 ) {

					return new Vector2( v_trans_x, v_trans_y );

				} else {

					shrink_by = Math.sqrt( v_trans_lensq / 2 );

				}

			} else {

				// handle special case of collinear edges

				var direction_eq = false; // assumes: opposite
				if ( v_prev_x > Number.EPSILON ) {

					if ( v_next_x > Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( v_prev_x < - Number.EPSILON ) {

						if ( v_next_x < - Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

							direction_eq = true;

						}

					}

				}

				if ( direction_eq ) {

					// console.log("Warning: lines are a straight sequence");
					v_trans_x = - v_prev_y;
					v_trans_y = v_prev_x;
					shrink_by = Math.sqrt( v_prev_lensq );

				} else {

					// console.log("Warning: lines are a straight spike");
					v_trans_x = v_prev_x;
					v_trans_y = v_prev_y;
					shrink_by = Math.sqrt( v_prev_lensq / 2 );

				}

			}

			return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

		}


		var contourMovements = [];

		for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			// console.log('i,j,k', i, j , k)

			contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

		}

		var holesMovements = [],
			oneHoleMovements, verticesMovements = contourMovements.concat();

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			oneHoleMovements = [];

			for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

			}

			holesMovements.push( oneHoleMovements );
			verticesMovements = verticesMovements.concat( oneHoleMovements );

		}


		// Loop bevelSegments, 1 for the front, 1 for the back

		for ( b = 0; b < bevelSegments; b ++ ) {

			//for ( b = bevelSegments; b > 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

				v( vert.x, vert.y, - z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

			}

		}

		bs = bevelSize;

		// Back facing vertices

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, 0 );

			} else {

				// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

				normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

		// Add stepped vertices...
		// Including front facing vertices

		var s;

		for ( s = 1; s <= steps; s ++ ) {

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, amount / steps * s );

				} else {

					// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

					normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

		}


		// Add bevel segments planes

		//for ( b = 1; b <= bevelSegments; b ++ ) {
		for ( b = bevelSegments - 1; b >= 0; b -- ) {

			t = b / bevelSegments;
			z = bevelThickness * Math.cos( t * Math.PI / 2 );
			bs = bevelSize * Math.sin( t * Math.PI / 2 );

			// contract shape

			for ( i = 0, il = contour.length; i < il; i ++ ) {

				vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
				v( vert.x, vert.y, amount + z );

			}

			// expand holes

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				oneHoleMovements = holesMovements[ h ];

				for ( i = 0, il = ahole.length; i < il; i ++ ) {

					vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, amount + z );

					} else {

						v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

					}

				}

			}

		}

		/* Faces */

		// Top and bottom faces

		buildLidFaces();

		// Sides faces

		buildSideFaces();


		/////  Internal functions

		function buildLidFaces() {

			var start = verticesArray.length / 3;

			if ( bevelEnabled ) {

				var layer = 0; // steps + 1
				var offset = vlen * layer;

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

				}

				layer = steps + bevelSegments * 2;
				offset = vlen * layer;

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

				}

			} else {

				// Bottom faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 2 ], face[ 1 ], face[ 0 ] );

				}

				// Top faces

				for ( i = 0; i < flen; i ++ ) {

					face = faces[ i ];
					f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

				}

			}

			scope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );

		}

		// Create faces for the z-sides of the shape

		function buildSideFaces() {

			var start = verticesArray.length / 3;
			var layeroffset = 0;
			sidewalls( contour, layeroffset );
			layeroffset += contour.length;

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];
				sidewalls( ahole, layeroffset );

				//, true
				layeroffset += ahole.length;

			}


			scope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );


		}

		function sidewalls( contour, layeroffset ) {

			var j, k;
			i = contour.length;

			while ( -- i >= 0 ) {

				j = i;
				k = i - 1;
				if ( k < 0 ) k = contour.length - 1;

				//console.log('b', i,j, i-1, k,vertices.length);

				var s = 0,
					sl = steps + bevelSegments * 2;

				for ( s = 0; s < sl; s ++ ) {

					var slen1 = vlen * s;
					var slen2 = vlen * ( s + 1 );

					var a = layeroffset + j + slen1,
						b = layeroffset + k + slen1,
						c = layeroffset + k + slen2,
						d = layeroffset + j + slen2;

					f4( a, b, c, d );

				}

			}

		}

		function v( x, y, z ) {

			placeholder.push( x );
			placeholder.push( y );
			placeholder.push( z );

		}


		function f3( a, b, c ) {

			addVertex( a );
			addVertex( b );
			addVertex( c );

			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );

		}

		function f4( a, b, c, d ) {

			addVertex( a );
			addVertex( b );
			addVertex( d );

			addVertex( b );
			addVertex( c );
			addVertex( d );


			var nextIndex = verticesArray.length / 3;
			var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

			addUV( uvs[ 0 ] );
			addUV( uvs[ 1 ] );
			addUV( uvs[ 3 ] );

			addUV( uvs[ 1 ] );
			addUV( uvs[ 2 ] );
			addUV( uvs[ 3 ] );

		}

		function addVertex( index ) {

			indicesArray.push( verticesArray.length / 3 );
			verticesArray.push( placeholder[ index * 3 + 0 ] );
			verticesArray.push( placeholder[ index * 3 + 1 ] );
			verticesArray.push( placeholder[ index * 3 + 2 ] );

		}


		function addUV( vector2 ) {

			uvArray.push( vector2.x );
			uvArray.push( vector2.y );

		}

		if ( ! options.arrays ) {

			this.setIndex( indicesArray );
			this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		}

	};

	ExtrudeGeometry.WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}
	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry( text, parameters ) {

		Geometry.call( this );

		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry( text, parameters ) {

		parameters = parameters || {};

		var font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();

		}

		var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

		// translate parameters to ExtrudeGeometry API

		parameters.amount = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call( this, shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( vertex.x, vertex.y, vertex.z ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// some helper variables

		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= phiSegments; j ++ ) {

			for ( i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( j = 0; j < phiSegments; j ++ ) {

			var thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( i = 0; i < thetaSegments; i ++ ) {

				segment = i + thetaSegmentLevel;

				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry( points, segments, phiStart, phiLength ) {

		Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

		BufferGeometry.call( this );

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


		// buffers

		var indices = [];
		var vertices = [];
		var uvs = [];

		// helper variables

		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;

		// generate vertices and uvs

		for ( i = 0; i <= segments; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin( phi );
			var cos = Math.cos( phi );

			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

				base = j + i * points.length;

				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry( shapes, curveSegments ) {

		Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry( shapes, curveSegments ) {

		BufferGeometry.call( this );

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		curveSegments = curveSegments || 12;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var groupStart = 0;
		var groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( var i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			var i, l, shapeHole;

			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );

			var shapeVertices = points.shape;
			var shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

				// also check if holes are in the opposite direction

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

			}

			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

				var vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON( shapes, data );

	};

	//

	function toJSON( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry( geometry, thresholdAngle ) {

		BufferGeometry.call( this );

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		// buffer

		var vertices = [];

		// helper variables

		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];

		// prepare source geometry

		var geometry2;

		if ( geometry.isBufferGeometry ) {

			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					edges[ key ].face2 = i;

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			var e = edges[ key ];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( y = 0; y <= heightSegments; y ++ ) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row

				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				for ( y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new Vector2();
			var vertex = new Vector3();

			var groupCount = 0;

			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			var segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



	var Geometries = Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>,
	 *  opacity: <float>
	 * }
	 */

	function ShadowMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.opacity = 1.0;

		this.lights = true;
		this.transparent = true;

		this.setValues( parameters );

	}

	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial( parameters ) {

		MeshPhongMaterial.call( this );

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues( parameters );

	}

	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function ( source ) {

		MeshPhongMaterial.prototype.copy.call( this, source );

		this.gradientMap = source.gradientMap;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial( parameters ) {

		LineBasicMaterial.call( this );

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function ( source ) {

		LineBasicMaterial.prototype.copy.call( this, source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};



	var Materials = Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;
			return this;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FileLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = window.decodeURIComponent( data );

				if ( isBase64 ) data = window.atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					Cache.add( url, response );

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 ) {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else if ( this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( CompressedTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( DataTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ImageLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( ImageLoader.prototype, {

		crossOrigin: 'Anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			image.addEventListener( 'load', function () {

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}, false );

			/*
			image.addEventListener( 'progress', function ( event ) {

				if ( onProgress ) onProgress( event );

			}, false );
			*/

			image.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			}, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( CubeTextureLoader.prototype, {

		crossOrigin: 'Anonymous',

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function TextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( TextureLoader.prototype, {

		crossOrigin: 'Anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly();
	var py = new CubicPoly();
	var pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && curve.isLineCurve ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light( color, intensity ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.matrix = new Matrix4();

	}

	Object.assign( LightShadow.prototype, {

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {

		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	}

	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update: function ( light ) {

			var camera = this.camera;

			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

		Light.call( this, color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				return this.intensity * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				this.intensity = power / Math.PI;

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: SpotLight,

		isSpotLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight( color, intensity, distance, decay ) {

		Light.call( this, color, intensity );

		this.type = 'PointLight';

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
				this.intensity = power / ( 4 * Math.PI );

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	}

	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: PointLight,

		isPointLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow( ) {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight( color, intensity, width, height ) {

		Light.call( this, color, intensity );

		this.type = 'RectAreaLight';

		this.position.set( 0, 1, 0 );
		this.updateMatrix();

		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;

		// TODO (abelnation): distance/decay

		// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

		// TODO (abelnation): shadows

	}

	// TODO (abelnation): RectAreaLight update when light shape is changed
	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	} );

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined

	} );

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack( name, times, values ) {

		KeyframeTrack.call( this, name, times, values );

	}

	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	} );

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset = i1 * stride,

				alpha = ( t - t0 ) / ( t1 - t0 );

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear: function ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	} );

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	} );

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		}

	};

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

		this.validate();
		this.optimize();

	}

	// Static methods:

	Object.assign( KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		parse: function ( json ) {

			if ( json.type === undefined ) {

				throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

			}

			var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

			if ( json.times === undefined ) {

				var times = [], values = [];

				AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

				json.times = times;
				json.values = values;

			}

			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {

				return trackType.parse( json );

			} else {

				// by default, we assume a constructor compatible with the base
				return new trackType( json.name, json.times, json.values, json.interpolation );

			}

		},

		toJSON: function ( track ) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				var interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		},

		_getTrackTypeForValueTypeName: function ( typeName ) {

			switch ( typeName.toLowerCase() ) {

				case 'scalar':
				case 'double':
				case 'float':
				case 'number':
				case 'integer':

					return NumberKeyframeTrack;

				case 'vector':
				case 'vector2':
				case 'vector3':
				case 'vector4':

					return VectorKeyframeTrack;

				case 'color':

					return ColorKeyframeTrack;

				case 'quaternion':

					return QuaternionKeyframeTrack;

				case 'bool':
				case 'boolean':

					return BooleanKeyframeTrack;

				case 'string':

					return StringKeyframeTrack;

			}

			throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

		}

	} );

	Object.assign( KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function ( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodLinear: function ( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: function ( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		setInterpolation: function ( interpolation ) {

			var factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return;

			}

			this.createInterpolant = factoryMethod;

		},

		getInterpolation: function () {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {

			if ( timeScale !== 1.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			var prevTime = null;

			for ( var i = 0; i !== nKeys; i ++ ) {

				var currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( var i = 0, n = values.length; i !== n; ++ i ) {

						var value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				writeIndex = 1,
				lastIndex = times.length - 1;

			for ( var i = 1; i < lastIndex; ++ i ) {

				var keep = false;

				var time = times[ i ];
				var timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( var j = 0; j !== stride; ++ j ) {

							var value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( var j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			}

			return this;

		}

	} );

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

		this.optimize();

	}

	Object.assign( AnimationClip, {

		parse: function ( json ) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

			}

			return new AnimationClip( json.name, json.duration, tracks );

		},

		toJSON: function ( clip ) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks

			};

			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		},

		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for ( var i = 0; i < numMorphTargets; i ++ ) {

				var times = [];
				var values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new AnimationClip( name, - 1, tracks );

		},

		findByName: function ( objectOrClipArray, name ) {

			var clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( var i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					var name = parts[ 1 ];

					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			var clips = [];

			for ( var name in animationToMorphTargets ) {

				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					var times = [];
					var values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

				var animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};

					for ( var k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {

						var times = [];
						var values = [];

						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							var animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					var boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			var clip = new AnimationClip( clipName, duration, tracks );

			return clip;

		}

	} );

	Object.assign( AnimationClip.prototype, {

		resetDuration: function () {

			var tracks = this.tracks, duration = 0;

			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

				var track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

		},

		trim: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		optimize: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};

	}

	Object.assign( MaterialLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		parse: function ( json ) {

			var textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			var material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalScale !== undefined ) {

				var normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			return material;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( BufferGeometryLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var geometry = new BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	} );

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {

		this.onLoadStart = function () {};
		this.onLoadProgress = function () {};
		this.onLoadComplete = function () {};

	}

	Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	Object.assign( Loader.prototype, {

		crossOrigin: undefined,

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};

			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();

			return function createMaterial( m, texturePath, crossOrigin ) {

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = _Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {

						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = [ value, value ];
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;

					}

				}

				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	} );

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			return s;

		},

		extractUrlBase: function ( url ) {

			var parts = url.split( '/' );

			if ( parts.length === 1 ) return './';

			parts.pop();

			return parts.join( '/' ) + '/';

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function JSONLoader( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.withCredentials = false;

	}

	Object.assign( JSONLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );

			var loader = new FileLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					var type = metadata.type;

					if ( type !== undefined ) {

						if ( type.toLowerCase() === 'object' ) {

							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;

						}

						if ( type.toLowerCase() === 'scene' ) {

							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
							return;

						}

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		parse: ( function () {

			function parseModel( json, geometry ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

					offset, zLength,

					colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

					vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					scale = json.scale,

					nUvLayers = 0;


				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];

					isQuad = isBitSet( type, 0 );
					hasMaterial = isBitSet( type, 1 );
					hasFaceVertexUv = isBitSet( type, 3 );
					hasFaceNormal = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor = isBitSet( type, 6 );
					hasFaceVertexColor = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			}

			function parseSkin( json, geometry ) {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x = json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a = json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}

			}

			function parseMorphing( json, geometry ) {

				var scale = json.scale;

				if ( json.morphTargets !== undefined ) {

					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;

						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						faces[ i ].color.fromArray( morphColors, i * 3 );

					}

				}

			}

			function parseAnimations( json, geometry ) {

				var outputAnimations = [];

				// parse old style Bone/Hierarchy animations
				var animations = [];

				if ( json.animation !== undefined ) {

					animations.push( json.animation );

				}

				if ( json.animations !== undefined ) {

					if ( json.animations.length ) {

						animations = animations.concat( json.animations );

					} else {

						animations.push( json.animations );

					}

				}

				for ( var i = 0; i < animations.length; i ++ ) {

					var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );

				}

				// parse implicit morph animations
				if ( geometry.morphTargets ) {

					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );

				}

				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

			}

			return function ( json, texturePath ) {

				if ( json.data !== undefined ) {

					// Geometry 4.0 spec
					json = json.data;

				}

				if ( json.scale !== undefined ) {

					json.scale = 1.0 / json.scale;

				} else {

					json.scale = 1.0;

				}

				var geometry = new Geometry();

				parseModel( json, geometry );
				parseSkin( json, geometry );
				parseMorphing( json, geometry );
				parseAnimations( json, geometry );

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.texturePath = '';

	}

	Object.assign( ObjectLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				var json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				var metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;

		},

		parse: function ( json, onLoad ) {

			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseShape: function ( json ) {

			var shapes = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		},

		parseGeometries: function ( json, shapes ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new JSONLoader();
				var bufferGeometryLoader = new BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							var geometryShapes = [];

							for ( var i = 0, l = data.shapes.length; i < l; i ++ ) {

								var shape = shapes[ data.shapes[ i ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						var array = [];

						for ( var j = 0; j < data.materials.length; j ++ ) {

							array.push( loader.parse( data.materials[ j ] ) );

						}

						materials[ data.uuid ] = array;

					} else {

						materials[ data.uuid ] = loader.parse( data );

					}

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var clip = AnimationClip.parse( json[ i ] );

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new LoadingManager( onLoad );

				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var image = json[ i ];
					var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

					images[ image.uuid ] = loadImage( path );

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture = new Texture( images[ data.image ] );
					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function () {

			var matrix = new Matrix4();

			return function parseObject( data, geometries, materials ) {

				var object;

				function getGeometry( name ) {

					if ( geometries[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

					}

					return geometries[ name ];

				}

				function getMaterial( name ) {

					if ( name === undefined ) return undefined;

					if ( Array.isArray( name ) ) {

						var array = [];

						for ( var i = 0, l = name.length; i < l; i ++ ) {

							var uuid = name[ i ];

							if ( materials[ uuid ] === undefined ) {

								console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

							}

							array.push( materials[ uuid ] );

						}

						return array;

					}

					if ( materials[ name ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', name );

					}

					return materials[ name ];

				}

				switch ( data.type ) {

					case 'Scene':

						object = new Scene();

						if ( data.background !== undefined ) {

							if ( Number.isInteger( data.background ) ) {

								object.background = new Color( data.background );

							}

						}

						if ( data.fog !== undefined ) {

							if ( data.fog.type === 'Fog' ) {

								object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

							} else if ( data.fog.type === 'FogExp2' ) {

								object.fog = new FogExp2( data.fog.color, data.fog.density );

							}

						}

						break;

					case 'PerspectiveCamera':

						object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

						if ( data.focus !== undefined ) object.focus = data.focus;
						if ( data.zoom !== undefined ) object.zoom = data.zoom;
						if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
						if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
						if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

						break;

					case 'OrthographicCamera':

						object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

						break;

					case 'AmbientLight':

						object = new AmbientLight( data.color, data.intensity );

						break;

					case 'DirectionalLight':

						object = new DirectionalLight( data.color, data.intensity );

						break;

					case 'PointLight':

						object = new PointLight( data.color, data.intensity, data.distance, data.decay );

						break;

					case 'RectAreaLight':

						object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

						break;

					case 'SpotLight':

						object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

						break;

					case 'HemisphereLight':

						object = new HemisphereLight( data.color, data.groundColor, data.intensity );

						break;

					case 'SkinnedMesh':

						console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

					case 'Mesh':

						var geometry = getGeometry( data.geometry );
						var material = getMaterial( data.material );

						if ( geometry.bones && geometry.bones.length > 0 ) {

							object = new SkinnedMesh( geometry, material );

						} else {

							object = new Mesh( geometry, material );

						}

						break;

					case 'LOD':

						object = new LOD();

						break;

					case 'Line':

						object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

						break;

					case 'LineLoop':

						object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'LineSegments':

						object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'PointCloud':
					case 'Points':

						object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

						break;

					case 'Sprite':

						object = new Sprite( getMaterial( data.material ) );

						break;

					case 'Group':

						object = new Group();

						break;

					default:

						object = new Object3D();

				}

				object.uuid = data.uuid;

				if ( data.name !== undefined ) object.name = data.name;
				if ( data.matrix !== undefined ) {

					matrix.fromArray( data.matrix );
					matrix.decompose( object.position, object.quaternion, object.scale );

				} else {

					if ( data.position !== undefined ) object.position.fromArray( data.position );
					if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
					if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
					if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

				}

				if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
				if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

				if ( data.shadow ) {

					if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
					if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
					if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
					if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

				}

				if ( data.visible !== undefined ) object.visible = data.visible;
				if ( data.userData !== undefined ) object.userData = data.userData;

				if ( data.children !== undefined ) {

					var children = data.children;

					for ( var i = 0; i < children.length; i ++ ) {

						object.add( this.parseObject( children[ i ], geometries, materials ) );

					}

				}

				if ( data.type === 'LOD' ) {

					var levels = data.levels;

					for ( var l = 0; l < levels.length; l ++ ) {

						var level = levels[ l ];
						var child = object.getObjectByProperty( 'uuid', level.object );

						if ( child !== undefined ) {

							object.addLevel( child, level.distance );

						}

					}

				}

				return object;

			};

		}()

	} );

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */

	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;

	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, scope.options );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			} );

		},

		setCrossOrigin: function ( /* value */ ) {

			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size, divisions ) {

			function createPaths( text ) {

				var chars = String( text ).split( '' );
				var scale = size / data.resolution;
				var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

				var offsetX = 0, offsetY = 0;

				var paths = [];

				for ( var i = 0; i < chars.length; i ++ ) {

					var char = chars[ i ];

					if ( char === '\n' ) {

						offsetX = 0;
						offsetY -= line_height;

					} else {

						var ret = createPath( char, scale, offsetX, offsetY );
						offsetX += ret.offsetX;
						paths.push( ret.path );

					}

				}

				return paths;

			}

			function createPath( c, scale, offsetX, offsetY ) {

				var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

				if ( ! glyph ) return;

				var path = new ShapePath();

				var pts = [];
				var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

				if ( glyph.o ) {

					var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

					for ( var i = 0, l = outline.length; i < l; ) {

						var action = outline[ i ++ ];

						switch ( action ) {

							case 'm': // moveTo

								x = outline[ i ++ ] * scale + offsetX;
								y = outline[ i ++ ] * scale + offsetY;

								path.moveTo( x, y );

								break;

							case 'l': // lineTo

								x = outline[ i ++ ] * scale + offsetX;
								y = outline[ i ++ ] * scale + offsetY;

								path.lineTo( x, y );

								break;

							case 'q': // quadraticCurveTo

								cpx = outline[ i ++ ] * scale + offsetX;
								cpy = outline[ i ++ ] * scale + offsetY;
								cpx1 = outline[ i ++ ] * scale + offsetX;
								cpy1 = outline[ i ++ ] * scale + offsetY;

								path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

								laste = pts[ pts.length - 1 ];

								if ( laste ) {

									cpx0 = laste.x;
									cpy0 = laste.y;

									

								}

								break;

							case 'b': // bezierCurveTo

								cpx = outline[ i ++ ] * scale + offsetX;
								cpy = outline[ i ++ ] * scale + offsetY;
								cpx1 = outline[ i ++ ] * scale + offsetX;
								cpy1 = outline[ i ++ ] * scale + offsetY;
								cpx2 = outline[ i ++ ] * scale + offsetX;
								cpy2 = outline[ i ++ ] * scale + offsetY;

								path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

								laste = pts[ pts.length - 1 ];

								if ( laste ) {

									cpx0 = laste.x;
									cpy0 = laste.y;

									

								}

								break;

						}

					}

				}

				return { offsetX: glyph.ha * scale, path: path };

			}

			//

			if ( size === undefined ) size = 100;
			if ( divisions === undefined ) divisions = 4;

			var data = this.data;

			var paths = createPaths( text );
			var shapes = [];

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FontLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json;

				try {

					json = JSON.parse( text );

				} catch ( e ) {

					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );

				}

				var font = scope.parse( json );

				if ( onLoad ) onLoad( font );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			return new Font( json );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var context;

	var AudioContext = {

		getContext: function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AudioLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.load( url, function ( buffer ) {

				var context = AudioContext.getContext();

				context.decodeAudioData( buffer, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			}, onProgress, onError );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

	}

	Object.assign( StereoCamera.prototype, {

		update: ( function () {

			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();

			return function update( camera ) {

				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

			};

		} )()

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera( near, far, cubeResolution ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget( renderTarget );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( null );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.value = value;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

				if ( listener.positionX ) {

					listener.positionX.setValueAtTime( position.x, this.context.currentTime );
					listener.positionY.setValueAtTime( position.y, this.context.currentTime );
					listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
					listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
					listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
					listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
					listener.upX.setValueAtTime( up.x, this.context.currentTime );
					listener.upY.setValueAtTime( up.y, this.context.currentTime );
					listener.upZ.setValueAtTime( up.z, this.context.currentTime );

				} else {

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function () {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );

			this.isPlaying = true;

			this.source = source;

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this.source.stop();
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.offset = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.value = value;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				position.setFromMatrixPosition( this.matrixWorld );

				this.panner.setPosition( position.x, position.y, position.z );

			};

		} )()


	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				break;

			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;

			default:
				mixFunction = this._lerp;

		}

		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	Object.assign( PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		},


		// mix functions

		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		},

		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		},

		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

			var s = 1 - t;

			for ( var i = 0; i !== stride; ++ i ) {

				var j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

	} );

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: function ( name ) {

			return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );

		},

		parseTrackName: function () {

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:[\w-]+[\/:])*)/;

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /([\w-\.]+)?/;

			// Object on target node, and accessor. Name may contain only word
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

			// Property and accessor. May contain only word characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe.source
				+ nodeRe.source
				+ objectRe.source
				+ propertyRe.source
				+ '$'
			);

			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

			return function ( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

		}(),

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var searchSkeleton = function ( skeleton ) {

					for ( var i = 0; i < skeleton.bones.length; i ++ ) {

						var bone = skeleton.bones[ i ];

						if ( bone.name === nodeName ) {

							return bone;

						}

					}

					return null;

				};

				var bone = searchSkeleton( root.skeleton );

				if ( bone ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {

		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	Object.assign( AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ],
					knownObject = undefined;

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
							'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function () {

			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function ( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		},

		unsubscribe_: function ( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	} );

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction( mixer, clip, localRoot ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( var i = 0; i !== nTracks; ++ i ) {

			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants;	// bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; 		// no. of repetitions when looping

		this.paused = false;				// true -> zero effective time scale
		this.enabled = true;				// false -> zero effective weight

		this.clampWhenFinished 	= false;	// keep feeding the last frame?

		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

	}

	Object.assign( AnimationAction.prototype, {

		// State & Scheduling

		play: function () {

			this._mixer._activateAction( this );

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction( this );

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0;			// restart clip
			this._loopCount = - 1;	// forget previous loops
			this._startTime = null;	// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this );

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction( this );

		},

		startAt: function ( time ) {

			this._startTime = time;

			return this;

		},

		setLoop: function ( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function ( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		},

		fadeOut: function ( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		},

		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		},

		crossFadeTo: function ( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function ( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function ( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function ( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		},

		warp: function ( startTimeScale, endTimeScale, duration ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			var startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight( time );

			if ( weight > 0 ) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );

				}

			}

		},

		_updateWeight: function ( time ) {

			var weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function ( time ) {

			var timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function ( deltaTime ) {

			var time = this.time + deltaTime;

			if ( deltaTime === 0 ) return time;

			var duration = this._clip.duration,

				loop = this.loop,
				loopCount = this._loopCount;

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else break handle_stop;

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				var pingPong = ( loop === LoopPingPong );

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending < 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 0 ) {

							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function ( atStart, atEnd, pingPong ) {

			var settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart 	= ZeroSlopeEnding;
				settings.endingEnd		= ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function ( duration, weightNow, weightThen ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

			return this;

		}

	} );

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer( root ) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	}

	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: AnimationMixer,

		_bindAction: function ( action, prototypeAction ) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( var i = 0; i !== nTracks; ++ i ) {

				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function ( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		},

		_deactivateAction: function ( action ) {

			if ( this._isActiveAction( action ) ) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< AnimationAction >	- used as prototypes
			// 		actionByRoot: AnimationAction			- lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		},

		// Memory management for AnimationAction objects

		_isActiveAction: function ( action ) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		},

		_removeInactiveAction: function ( action ) {

			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		},

		_removeInactiveBindingsForAction: function ( action ) {

			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		},

		_lendAction: function ( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		},

		_takeBackAction: function ( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				bindings = this._bindings;

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		},

		_removeInactiveBinding: function ( binding ) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			remove_empty_map: {

				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[ rootUuid ];

			}

		},

		_lendBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		},

		_takeBackBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function ( interpolant ) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;

			if ( actionsForClip !== undefined ) {

				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		},

		// get an existing action
		existingAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for ( var i = 0; i !== nActions; ++ i ) {

				actions[ i ].reset();

			}

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function ( deltaTime ) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( var i = 0; i !== nActions; ++ i ) {

				var action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					var action = actionsToRemove[ i ];

					this._deactivateAction( action );

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( var clipUuid in actionsByClip ) {

				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( var trackName in bindingByName ) {

					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {

			var action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.uuid = _Math.generateUUID();

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.uuid = _Math.generateUUID();

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.onUploadCallback = function () {};

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

		BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( ( camera && camera.isPerspectiveCamera ) ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( ( camera && camera.isOrthographicCamera ) ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
		this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = vec3.length();

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
				this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

			}

			return this;

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	Object.assign( Cylindrical.prototype, {

		set: function ( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
			this.theta = Math.atan2( vec3.x, vec3.z );
			this.y = vec3.y;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	}

	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new BufferGeometry();

		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	SpotLightHelper.prototype.update = function () {

		var vector = new Vector3();
		var vector2 = new Vector3();

		return function update() {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

	}();

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList( object ) {

		var boneList = [];

		if ( object && object.isBone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	function SkeletonHelper( object ) {

		var bones = getBoneList( object );

		var geometry = new BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		LineSegments.call( this, geometry, material );

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = function () {

		var vector = new Vector3();

		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();

		return function updateMatrixWorld( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper( light, sphereSize, color ) {

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

		Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	}

	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	PointLightHelper.prototype.update = function () {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function RectAreaLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var material = new LineBasicMaterial( { fog: false } );

		var geometry = new BufferGeometry();

		geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );

		this.line = new Line( geometry, material );
		this.add( this.line );


		this.update();

	}

	RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	RectAreaLightHelper.prototype.update = function () {

		// calculate new dimensions of the helper

		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;

		var position = this.line.geometry.attributes.position;
		var array = position.array;

		// update vertices

		array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
		array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
		array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
		array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
		array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;

		position.needsUpdate = true;

		if ( this.color !== undefined ) {

			this.line.material.color.set( this.color );

		} else {

			this.line.material.color.copy( this.light.color );

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );

		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	HemisphereLightHelper.prototype.update = function () {

		var vector = new Vector3();

		var color1 = new Color();
		var color2 = new Color();

		return function update() {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper( size, divisions, color1, color2 ) {

		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;

		var vertices = [], colors = [];

		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			var color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	GridHelper.prototype = Object.create( LineSegments.prototype );
	GridHelper.prototype.constructor = GridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var vertices = [];
		var colors = [];

		var x, z;
		var v, i, j, r, color;

		// create the radials

		for ( i = 0; i <= radials; i ++ ) {

			v = ( i / radials ) * ( Math.PI * 2 );

			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( i = 0; i <= circles; i ++ ) {

			color = ( i & 1 ) ? color1 : color2;

			r = radius - ( radius / circles * i );

			for ( j = 0; j < divisions; j ++ ) {

				// first vertex

				v = ( j / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	}

	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	DirectionalLightHelper.prototype.update = function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();

		return function update() {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( v3 );
			this.targetLine.scale.z = v3.length();

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper( camera ) {

		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

		var vertices = [];
		var colors = [];

		var pointMap = {};

		// colors

		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		LineSegments.call( this, geometry, material );

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new Vector3();
		var camera = new Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );

			// near

			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );

			// far

			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );

			// up

			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );

			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper( object, color ) {

		this.object = object;

		if ( color === undefined ) color = 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.matrixAutoUpdate = false;

		this.update();

	}

	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = ( function () {

		var box = new Box3();

		return function update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				box.setFromObject( this.object );

			}

			if ( box.isEmpty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	} )();

	BoxHelper.prototype.setFromObject = function ( object ) {

		this.object = object;
		this.update();

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper( box, hex ) {

		this.type = 'Box3Helper';

		this.box = box;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		var geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.geometry.computeBoundingSphere();

	}

	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

		var box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper( plane, size, hex ) {

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = ( size === undefined ) ? 1 : size;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		//

		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

	}

	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

		var scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.lookAt( this.plane.normal );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	var lineGeometry;
	var coneGeometry;

	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( lineGeometry === undefined ) {

			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = ( function () {

		var axis = new Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );

	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper( size ) {

		size = size || 1;

		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	var SceneUtils = {

		createMultiMaterialObject: function ( geometry, materials ) {

			var group = new Group();

			for ( var i = 0, l = materials.length; i < l; i ++ ) {

				group.add( new Mesh( geometry, materials[ i ] ) );

			}

			return group;

		},

		detach: function ( child, parent, scene ) {

			child.applyMatrix( parent.matrixWorld );
			parent.remove( child );
			scene.add( child );

		},

		attach: function ( child, scene, parent ) {

			child.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );

			scene.remove( child );
			parent.add( child );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;

	var LinePieces = 1;

	function MeshFaceMaterial( materials ) {

		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;

	}

	function MultiMaterial( materials ) {

		if ( materials === undefined ) materials = [];

		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {

			return materials.slice();

		};
		return materials;

	}

	function PointCloud( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function Particle( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );

	}

	function ParticleSystem( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function PointCloudMaterial( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleBasicMaterial( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleSystemMaterial( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function Vertex( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );

	}

	//

	function DynamicBufferAttribute( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );

	}

	function Int8Attribute( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );

	}

	function Uint8Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );

	}

	function Uint8ClampedAttribute( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );

	}

	function Int16Attribute( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );

	}

	function Uint16Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );

	}

	function Int32Attribute( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );

	}

	function Uint32Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );

	}

	function Float32Attribute( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );

	}

	function Float64Attribute( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	//

	function AxisHelper( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );

	}

	function BoundingBoxHelper( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );

	}

	function EdgesHelper( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	function WireframeHelper( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	function XHRLoader( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );

	}

	function BinaryTextureLoader( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );

	}

	//

	Object.assign( Box2.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Line3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Object.assign( _Math, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			var v1;

			return function getPosition() {

				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );

			};

		}(),
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Ray.prototype, {

		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionPlane: function ( plane ) {

			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Geometry.prototype.computeTangents = function () {

		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

	};

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		}

	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},
		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},

		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},

		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},

		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},

		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				return this.shadowMap.cullFace;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
				this.shadowMap.cullFace = value;

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				return this.renderReverseSided ? CullFaceFront : CullFaceBack;

			},
			set: function ( cullFace ) {

				var value = ( cullFace !== CullFaceBack );
				console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
				this.renderReverseSided = value;

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.assign( WebVRManager.prototype, {

		getStandingMatrix: function () {

			console.warn( 'THREE.WebVRManager: .getStandingMatrix() has been removed.' );

		}

	} );

	Object.defineProperties( WebVRManager.prototype, {

		standing: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	var ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

			var loader = new TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( url, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadTextureCube: function ( urls, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

			var loader = new CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( urls, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

		}

	};

	//

	function Projector() {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function () {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	}

	//

	function CanvasRenderer() {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	}

	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.LensFlare = LensFlare;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.JSONLoader = JSONLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ShapeUtils = ShapeUtils;
	exports.SceneUtils = SceneUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.CubeGeometry = BoxGeometry;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.ImageUtils = ImageUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;

	Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Clip_js__ = __webpack_require__(3);


function render(url, container, callback){
  new __WEBPACK_IMPORTED_MODULE_0__Clip_js__["a" /* default */]().render(url, container, callback);
}

global.HMI3DRenderer = {
  render: render,
}

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__libs_three_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__libs_three_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__libs_three_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BlendLoader_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__OrbitControls_js__ = __webpack_require__(5);
/**
 * A 3D clip
 */





const CONTROL_MIN_DISTANCE = 10;
const CONTROL_MAX_DISTANCE = 50;

function Clip() { }
Clip.enableStats = false;

Clip.prototype.size = function () {
  return {
    width: this.container.clientWidth,
    height: this.container.clientHeight
  }
}

/**
 * 
 * @param {Object} parameters 
 * @param {string} parameter.url : the url to the file
 * @param {domElement} parameters.container : the containter of the Clip
 * @param {function()} parameters.sucess : callback function when load success
 * @param {function(error)} parameters.error : callback function when load error  
 */
Clip.prototype.render = function (parameters){
  this.container = parameters.container;
  this.renderer = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["WebGLRenderer"]({ antialias: true });

  /**
   * fix to disable "extension 'GL_ARB_gpu_shader5' is not supported" log
   * @see https://github.com/mrdoob/three.js/issues/9716
   */
  this.renderer.context.getShaderInfoLog = function () { return '' };

  var width = this.size().width;
  var height = this.size().height;
  var that = this;
  this.camera = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["PerspectiveCamera"](75, width / height, 0.1, 1000);
  var controls = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["OrbitControls"](this.camera, this.renderer.domElement);

  this.container.appendChild(this.renderer.domElement);

  controls.maxPolarAngle = Math.PI * 0.5;
  controls.minDistance = CONTROL_MIN_DISTANCE;
  controls.maxDistance = CONTROL_MAX_DISTANCE;

  Object(__WEBPACK_IMPORTED_MODULE_1__BlendLoader_js__["a" /* default */])(parameters.url, (scene) => {
    that.scene = scene;
    controls.reset();
    that.animate();
    if (parameters.callback) {
      parameters.callback(this);
    }
  });
};

Clip.prototype.animate = function () {
  var size = this.size();
  requestAnimationFrame(this.animate.bind(this));
  this.renderer.setSize(size.width, size.height);
  this.renderer.render(this.scene, this.camera);
};

/* harmony default export */ __webpack_exports__["a"] = (Clip);


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = load;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__libs_three_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__libs_three_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__libs_three_js__);


function load(path, callback) {
  var loader = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["ObjectLoader"]();
  var res = null;

  loader.load(
    path,
    function (obj) {
      callback(obj)
    },
    function (xhr) {
      //console.log((xhr.loaded / xhr.total * 100) + '% loaded');
    },
    function (error) {
      console.error('An error happened');
      console.log(error);
    }
  );
}



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__libs_three_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__libs_three_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__libs_three_js__);
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe


__WEBPACK_IMPORTED_MODULE_0__libs_three_js__["OrbitControls"] = function ( object, domElement ) {

	this.object = object;

	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the object orbits around
	this.target = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();

	// How far you can dolly in and out ( PerspectiveCamera only )
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// How far you can zoom in and out ( OrthographicCamera only )
	this.minZoom = 0;
	this.maxZoom = Infinity;

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = - Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to enable damping (inertia)
	// If damping is enabled, you must call controls.update() in your animation loop
	this.enableDamping = false;
	this.dampingFactor = 0.25;

	// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
	// Set to false to disable zooming
	this.enableZoom = true;
	this.zoomSpeed = 1.0;

	// Set to false to disable rotating
	this.enableRotate = true;
	this.rotateSpeed = 1.0;

	// Set to false to disable panning
	this.enablePan = true;
	this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	// If auto-rotate is enabled, you must call controls.update() in your animation loop
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// Set to false to disable use of the keys
	this.enableKeys = true;

	// The four arrow keys
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

	// Mouse buttons
	this.mouseButtons = { ORBIT: __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["MOUSE"].LEFT, ZOOM: __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["MOUSE"].MIDDLE, PAN: __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["MOUSE"].RIGHT };

	// for reset
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;

	//
	// public methods
	//

	this.getPolarAngle = function () {

		return spherical.phi;

	};

	this.getAzimuthalAngle = function () {

		return spherical.theta;

	};

	this.saveState = function () {

		scope.target0.copy( scope.target );
		scope.position0.copy( scope.object.position );
		scope.zoom0 = scope.object.zoom;

	};

	this.reset = function () {

		scope.target.copy( scope.target0 );
		scope.object.position.copy( scope.position0 );
		scope.object.zoom = scope.zoom0;

		scope.object.updateProjectionMatrix();
		scope.dispatchEvent( changeEvent );

		scope.update();

		state = STATE.NONE;

	};

	// this method is exposed, but perhaps it would be better if we can make it private...
	this.update = function () {

		var offset = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();

		// so camera.up is the orbit axis
		var quat = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Quaternion"]().setFromUnitVectors( object.up, new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]( 0, 1, 0 ) );
		var quatInverse = quat.clone().inverse();

		var lastPosition = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();
		var lastQuaternion = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Quaternion"]();

		return function update() {

			var position = scope.object.position;

			offset.copy( position ).sub( scope.target );

			// rotate offset to "y-axis-is-up" space
			offset.applyQuaternion( quat );

			// angle from z-axis around y-axis
			spherical.setFromVector3( offset );

			if ( scope.autoRotate && state === STATE.NONE ) {

				rotateLeft( getAutoRotationAngle() );

			}

			spherical.theta += sphericalDelta.theta;
			spherical.phi += sphericalDelta.phi;

			// restrict theta to be between desired limits
			spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

			// restrict phi to be between desired limits
			spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

			spherical.makeSafe();


			spherical.radius *= scale;

			// restrict radius to be between desired limits
			spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

			// move target to panned location
			scope.target.add( panOffset );

			offset.setFromSpherical( spherical );

			// rotate offset back to "camera-up-vector-is-up" space
			offset.applyQuaternion( quatInverse );

			position.copy( scope.target ).add( offset );

			scope.object.lookAt( scope.target );

			if ( scope.enableDamping === true ) {

				sphericalDelta.theta *= ( 1 - scope.dampingFactor );
				sphericalDelta.phi *= ( 1 - scope.dampingFactor );

			} else {

				sphericalDelta.set( 0, 0, 0 );

			}

			scale = 1;
			panOffset.set( 0, 0, 0 );

			// update condition is:
			// min(camera displacement, camera rotation in radians)^2 > EPS
			// using small-angle approximation cos(x/2) = 1 - x^2 / 8

			if ( zoomChanged ||
				lastPosition.distanceToSquared( scope.object.position ) > EPS ||
				8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

				scope.dispatchEvent( changeEvent );

				lastPosition.copy( scope.object.position );
				lastQuaternion.copy( scope.object.quaternion );
				zoomChanged = false;

				return true;

			}

			return false;

		};

	}();

	this.dispose = function () {

		scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
		scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		window.removeEventListener( 'keydown', onKeyDown, false );

		//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

	};

	//
	// internals
	//

	var scope = this;

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start' };
	var endEvent = { type: 'end' };

	var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

	var state = STATE.NONE;

	var EPS = 0.000001;

	// current position in spherical coordinates
	var spherical = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Spherical"]();
	var sphericalDelta = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Spherical"]();

	var scale = 1;
	var panOffset = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();
	var zoomChanged = false;

	var rotateStart = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();
	var rotateEnd = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();
	var rotateDelta = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();

	var panStart = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();
	var panEnd = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();
	var panDelta = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();

	var dollyStart = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();
	var dollyEnd = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();
	var dollyDelta = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector2"]();

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow( 0.95, scope.zoomSpeed );

	}

	function rotateLeft( angle ) {

		sphericalDelta.theta -= angle;

	}

	function rotateUp( angle ) {

		sphericalDelta.phi -= angle;

	}

	var panLeft = function () {

		var v = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();

		return function panLeft( distance, objectMatrix ) {

			v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
			v.multiplyScalar( - distance );

			panOffset.add( v );

		};

	}();

	var panUp = function () {

		var v = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();

		return function panUp( distance, objectMatrix ) {

			v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
			v.multiplyScalar( distance );

			panOffset.add( v );

		};

	}();

	// deltaX and deltaY are in pixels; right and down are positive
	var pan = function () {

		var offset = new __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["Vector3"]();

		return function pan( deltaX, deltaY ) {

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			if ( scope.object.isPerspectiveCamera ) {

				// perspective
				var position = scope.object.position;
				offset.copy( position ).sub( scope.target );
				var targetDistance = offset.length();

				// half of the fov is center to top of screen
				targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

				// we actually don't use screenWidth, since perspective camera is fixed to screen height
				panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
				panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

			} else if ( scope.object.isOrthographicCamera ) {

				// orthographic
				panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
				panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

			} else {

				// camera neither orthographic nor perspective
				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
				scope.enablePan = false;

			}

		};

	}();

	function dollyIn( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) {

			scale /= dollyScale;

		} else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	function dollyOut( dollyScale ) {

		if ( scope.object.isPerspectiveCamera ) {

			scale *= dollyScale;

		} else if ( scope.object.isOrthographicCamera ) {

			scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
			scope.object.updateProjectionMatrix();
			zoomChanged = true;

		} else {

			console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
			scope.enableZoom = false;

		}

	}

	//
	// event callbacks - update the object state
	//

	function handleMouseDownRotate( event ) {

		//console.log( 'handleMouseDownRotate' );

		rotateStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownDolly( event ) {

		//console.log( 'handleMouseDownDolly' );

		dollyStart.set( event.clientX, event.clientY );

	}

	function handleMouseDownPan( event ) {

		//console.log( 'handleMouseDownPan' );

		panStart.set( event.clientX, event.clientY );

	}

	function handleMouseMoveRotate( event ) {

		//console.log( 'handleMouseMoveRotate' );

		rotateEnd.set( event.clientX, event.clientY );
		rotateDelta.subVectors( rotateEnd, rotateStart );

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleMouseMoveDolly( event ) {

		//console.log( 'handleMouseMoveDolly' );

		dollyEnd.set( event.clientX, event.clientY );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyIn( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyOut( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleMouseMovePan( event ) {

		//console.log( 'handleMouseMovePan' );

		panEnd.set( event.clientX, event.clientY );

		panDelta.subVectors( panEnd, panStart );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleMouseUp( event ) {

		// console.log( 'handleMouseUp' );

	}

	function handleMouseWheel( event ) {

		// console.log( 'handleMouseWheel' );

		if ( event.deltaY < 0 ) {

			dollyOut( getZoomScale() );

		} else if ( event.deltaY > 0 ) {

			dollyIn( getZoomScale() );

		}

		scope.update();

	}

	function handleKeyDown( event ) {

		//console.log( 'handleKeyDown' );

		switch ( event.keyCode ) {

			case scope.keys.UP:
				pan( 0, scope.keyPanSpeed );
				scope.update();
				break;

			case scope.keys.BOTTOM:
				pan( 0, - scope.keyPanSpeed );
				scope.update();
				break;

			case scope.keys.LEFT:
				pan( scope.keyPanSpeed, 0 );
				scope.update();
				break;

			case scope.keys.RIGHT:
				pan( - scope.keyPanSpeed, 0 );
				scope.update();
				break;

		}

	}

	function handleTouchStartRotate( event ) {

		//console.log( 'handleTouchStartRotate' );

		rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

	}

	function handleTouchStartDolly( event ) {

		//console.log( 'handleTouchStartDolly' );

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		dollyStart.set( 0, distance );

	}

	function handleTouchStartPan( event ) {

		//console.log( 'handleTouchStartPan' );

		panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

	}

	function handleTouchMoveRotate( event ) {

		//console.log( 'handleTouchMoveRotate' );

		rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
		rotateDelta.subVectors( rotateEnd, rotateStart );

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		// rotating across whole screen goes 360 degrees around
		rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

		// rotating up and down along whole screen attempts to go 360, but limited to 180
		rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

		rotateStart.copy( rotateEnd );

		scope.update();

	}

	function handleTouchMoveDolly( event ) {

		//console.log( 'handleTouchMoveDolly' );

		var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
		var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

		var distance = Math.sqrt( dx * dx + dy * dy );

		dollyEnd.set( 0, distance );

		dollyDelta.subVectors( dollyEnd, dollyStart );

		if ( dollyDelta.y > 0 ) {

			dollyOut( getZoomScale() );

		} else if ( dollyDelta.y < 0 ) {

			dollyIn( getZoomScale() );

		}

		dollyStart.copy( dollyEnd );

		scope.update();

	}

	function handleTouchMovePan( event ) {

		//console.log( 'handleTouchMovePan' );

		panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		panDelta.subVectors( panEnd, panStart );

		pan( panDelta.x, panDelta.y );

		panStart.copy( panEnd );

		scope.update();

	}

	function handleTouchEnd( event ) {

		//console.log( 'handleTouchEnd' );

	}

	//
	// event handlers - FSM: listen for events and reset state
	//

	function onMouseDown( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( event.button ) {

			case scope.mouseButtons.ORBIT:

				if ( scope.enableRotate === false ) return;

				handleMouseDownRotate( event );

				state = STATE.ROTATE;

				break;

			case scope.mouseButtons.ZOOM:

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

				break;

			case scope.mouseButtons.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseDownPan( event );

				state = STATE.PAN;

				break;

		}

		if ( state !== STATE.NONE ) {

			document.addEventListener( 'mousemove', onMouseMove, false );
			document.addEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( startEvent );

		}

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		switch ( state ) {

			case STATE.ROTATE:

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

				break;

			case STATE.DOLLY:

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

				break;

			case STATE.PAN:

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

				break;

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;

		handleMouseUp( event );

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

		event.preventDefault();
		event.stopPropagation();

		handleMouseWheel( event );

		scope.dispatchEvent( startEvent ); // not sure why these are here...
		scope.dispatchEvent( endEvent );

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

		handleKeyDown( event );

	}

	function onTouchStart( event ) {

		if ( scope.enabled === false ) return;

		switch ( event.touches.length ) {

			case 1:	// one-fingered touch: rotate

				if ( scope.enableRotate === false ) return;

				handleTouchStartRotate( event );

				state = STATE.TOUCH_ROTATE;

				break;

			case 2:	// two-fingered touch: dolly

				if ( scope.enableZoom === false ) return;

				handleTouchStartDolly( event );

				state = STATE.TOUCH_DOLLY;

				break;

			case 3: // three-fingered touch: pan

				if ( scope.enablePan === false ) return;

				handleTouchStartPan( event );

				state = STATE.TOUCH_PAN;

				break;

			default:

				state = STATE.NONE;

		}

		if ( state !== STATE.NONE ) {

			scope.dispatchEvent( startEvent );

		}

	}

	function onTouchMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		switch ( event.touches.length ) {

			case 1: // one-fingered touch: rotate

				if ( scope.enableRotate === false ) return;
				if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

				handleTouchMoveRotate( event );

				break;

			case 2: // two-fingered touch: dolly

				if ( scope.enableZoom === false ) return;
				if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

				handleTouchMoveDolly( event );

				break;

			case 3: // three-fingered touch: pan

				if ( scope.enablePan === false ) return;
				if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

				handleTouchMovePan( event );

				break;

			default:

				state = STATE.NONE;

		}

	}

	function onTouchEnd( event ) {

		if ( scope.enabled === false ) return;

		handleTouchEnd( event );

		scope.dispatchEvent( endEvent );

		state = STATE.NONE;

	}

	function onContextMenu( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

	}

	//

	scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

	scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
	scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

	scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
	scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
	scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

	window.addEventListener( 'keydown', onKeyDown, false );

	// force an update at start

	this.update();

};

__WEBPACK_IMPORTED_MODULE_0__libs_three_js__["OrbitControls"].prototype = Object.create( __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["EventDispatcher"].prototype );
__WEBPACK_IMPORTED_MODULE_0__libs_three_js__["OrbitControls"].prototype.constructor = __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["OrbitControls"];

Object.defineProperties( __WEBPACK_IMPORTED_MODULE_0__libs_three_js__["OrbitControls"].prototype, {

	center: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
			return this.target;

		}

	},

	// backward compatibility

	noZoom: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
			return ! this.enableZoom;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
			this.enableZoom = ! value;

		}

	},

	noRotate: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
			return ! this.enableRotate;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
			this.enableRotate = ! value;

		}

	},

	noPan: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
			return ! this.enablePan;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
			this.enablePan = ! value;

		}

	},

	noKeys: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
			return ! this.enableKeys;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
			this.enableKeys = ! value;

		}

	},

	staticMoving: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
			return ! this.enableDamping;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
			this.enableDamping = ! value;

		}

	},

	dynamicDampingFactor: {

		get: function () {

			console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
			return this.dampingFactor;

		},

		set: function ( value ) {

			console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
			this.dampingFactor = value;

		}

	}

} );


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMGJiNDRhYjk3ZGQzMjgwNzI2YTMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvbGlicy90aHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9tYWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvQ2xpcC5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9CbGVuZExvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9PcmJpdENvbnRyb2xzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsQ0FBQyw0QkFBNEI7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLDBCQUEwQjs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixTQUFTOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQixlQUFlLGVBQWU7QUFDL0MsaUJBQWlCLGVBQWUsZUFBZTtBQUMvQyxpQkFBaUIsZUFBZSxnQkFBZ0I7QUFDaEQsaUJBQWlCLGVBQWUsZ0JBQWdCOztBQUVoRDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUIsbUJBQW1CO0FBQzNELHFCQUFxQixtQkFBbUIsbUJBQW1CO0FBQzNELHFCQUFxQixtQkFBbUIscUJBQXFCO0FBQzdELHVCQUF1QixxQkFBcUIscUJBQXFCOztBQUVqRTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQyxrQkFBa0IsZUFBZTtBQUNqQyxrQkFBa0IsZUFBZTs7QUFFakM7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxnQkFBZ0IsY0FBYyxjQUFjO0FBQzVDLGdCQUFnQixjQUFjLGNBQWM7QUFDNUMsZ0JBQWdCLGNBQWMsZUFBZTtBQUM3QyxnQkFBZ0IsY0FBYyxlQUFlOztBQUU3Qzs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQyxpQkFBaUIsbUJBQW1CO0FBQ3BDLGlCQUFpQixtQkFBbUI7O0FBRXBDLGlCQUFpQixvQkFBb0I7QUFDckMsaUJBQWlCLG9CQUFvQjtBQUNyQyxrQkFBa0IscUJBQXFCOztBQUV2Qzs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYzs7QUFFOUI7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxhQUFhLGFBQWE7QUFDekMsZUFBZSxhQUFhLGFBQWE7QUFDekMsZUFBZSxhQUFhLGNBQWM7QUFDMUMsZUFBZSxhQUFhLGdCQUFnQjs7QUFFNUM7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWEsYUFBYTtBQUM3QyxlQUFlLGlCQUFpQixhQUFhO0FBQzdDLGVBQWUsYUFBYSxvQkFBb0I7QUFDaEQsZUFBZSxhQUFhLGNBQWM7O0FBRTFDOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxtQkFBbUIsUUFBUTs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7O0FBRWhDOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEMscUJBQXFCLG1CQUFtQjtBQUN4QyxxQkFBcUIsbUJBQW1COztBQUV4Qzs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsY0FBYzs7QUFFOUI7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsaUJBQWlCOztBQUVqQzs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLGVBQWU7O0FBRWhDOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSwyQkFBMkIseUJBQXlCO0FBQ3BELDJCQUEyQix5QkFBeUI7O0FBRXBEOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0Msc0JBQXNCOztBQUU1RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDOztBQUV2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0IsZUFBZTs7QUFFOUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DOztBQUVuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQzs7QUFFbkMsK0NBQStDO0FBQy9DLGtDQUFrQzs7QUFFbEMsK0NBQStDO0FBQy9DLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFNBQVM7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQzs7QUFFbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLFNBQVM7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLEVBQUU7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLGtDQUFrQyxTQUFTOztBQUUzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLFNBQVM7O0FBRTNDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsZ0NBQWdDOztBQUVoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBLHlEQUF5RDtBQUN6RCx5Q0FBeUM7QUFDekMseUNBQXlDOztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLGNBQWMsWUFBWTs7QUFFMUI7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSwrQkFBK0I7QUFDNUMsYUFBYSxhQUFhOztBQUUxQixTQUFTLGNBQWM7QUFDdkIsaUJBQWlCLHVCQUF1Qjs7QUFFeEMsY0FBYyxjQUFjOztBQUU1QixHQUFHOztBQUVIOztBQUVBLGlCQUFpQixjQUFjOztBQUUvQixHQUFHOztBQUVIOztBQUVBLFlBQVksY0FBYztBQUMxQixnQkFBZ0IsYUFBYTtBQUM3QixrQkFBa0IsYUFBYTtBQUMvQixxQkFBcUI7O0FBRXJCLEdBQUc7O0FBRUg7O0FBRUEsV0FBVyxjQUFjO0FBQ3pCLG9CQUFvQjs7QUFFcEIsR0FBRzs7QUFFSDs7QUFFQSxjQUFjLGNBQWM7QUFDNUIsdUJBQXVCOztBQUV2QixHQUFHOztBQUVIOztBQUVBLGlCQUFpQjs7QUFFakIsR0FBRzs7QUFFSDs7QUFFQSxhQUFhLGNBQWM7QUFDM0IsZUFBZTs7QUFFZixHQUFHOztBQUVIOztBQUVBLGVBQWUsY0FBYztBQUM3QixpQkFBaUI7O0FBRWpCLEdBQUc7O0FBRUg7O0FBRUEscUJBQXFCLGNBQWM7QUFDbkMsdUJBQXVCLFdBQVc7QUFDbEMsc0JBQXNCOztBQUV0QixHQUFHOztBQUVIOztBQUVBLGtCQUFrQjs7QUFFbEIsR0FBRzs7QUFFSDs7QUFFQSxrQkFBa0I7O0FBRWxCLEdBQUc7O0FBRUg7O0FBRUEsaUJBQWlCOztBQUVqQixHQUFHOztBQUVIOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakMsYUFBYSxXQUFXO0FBQ3hCLFlBQVksY0FBYztBQUMxQixjQUFjOztBQUVkLEdBQUc7O0FBRUg7O0FBRUEsdUJBQXVCLFlBQVk7O0FBRW5DLHVCQUF1QjtBQUN2QixpQkFBaUI7QUFDakIsYUFBYTs7QUFFYixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjtBQUNBLElBQUksRUFBRTs7QUFFTiwwQkFBMEIsWUFBWTtBQUN0Qyw2QkFBNkIsWUFBWTs7QUFFekMsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGFBQWE7O0FBRWIsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEI7QUFDQSxJQUFJLEVBQUU7O0FBRU4sbUJBQW1CLFlBQVk7QUFDL0Isc0JBQXNCLFlBQVk7O0FBRWxDLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixnQkFBZ0I7O0FBRWhCLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEI7QUFDQSxJQUFJLEVBQUU7O0FBRU4sb0JBQW9CLFlBQVk7QUFDaEMsdUJBQXVCLFlBQVk7O0FBRW5DLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0EsSUFBSSxFQUFFOztBQUVOO0FBQ0Esb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0EsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsYUFBYTtBQUMxQixVQUFVLGFBQWE7QUFDdkIsV0FBVyxhQUFhO0FBQ3hCLFNBQVMsY0FBYztBQUN2QixpQkFBaUI7O0FBRWpCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxnR0FBZ0c7O0FBRWhHLGlGQUFpRjs7QUFFakYseUZBQXlGOztBQUV6RixnSUFBZ0ksdURBQXVELDZIQUE2SCx5SEFBeUg7O0FBRTdhLHdFQUF3RSxpQ0FBaUM7O0FBRXpHLDJEQUEyRDs7QUFFM0QsZ0VBQWdFOztBQUVoRSwySkFBMkosK0JBQStCLGdJQUFnSSx1R0FBdUcsdURBQXVELDRGQUE0RixhQUFhLGVBQWUsR0FBRywyREFBMkQsd0NBQXdDLEdBQUcsdUVBQXVFLG1FQUFtRSw2REFBNkQsR0FBRyx5RkFBeUYsNkJBQTZCLGlFQUFpRSxpRUFBaUUsNkJBQTZCLEdBQUcsbUdBQW1HLDZCQUE2QixpRUFBaUUsaUVBQWlFLHlDQUF5QyxHQUFHLDZEQUE2RCw2QkFBNkIscURBQXFELDhDQUE4QyxHQUFHLDZKQUE2SixvQ0FBb0MsMkVBQTJFLDhFQUE4RSx1RUFBdUUsOERBQThELHNFQUFzRSwrQ0FBK0MsMkRBQTJELG9DQUFvQyx5QkFBeUIsR0FBRyw2RUFBNkUsaUNBQWlDLDBEQUEwRCwyQ0FBMkMsc0NBQXNDLGdHQUFnRyxtQ0FBbUMsY0FBYyxHQUFHLHdEQUF3RCwwQkFBMEIscURBQXFELEdBQUcsdUVBQXVFLDRCQUE0Qix1QkFBdUIscURBQXFELDBDQUEwQyxvQkFBb0IsZ0ZBQWdGLDRDQUE0QyxHQUFHLDZIQUE2SCxnREFBZ0QsZ0RBQWdELHVDQUF1QywyRUFBMkUsZ0JBQWdCLDBDQUEwQywwQkFBMEIseURBQXlELHFCQUFxQixnREFBZ0QsZ0RBQWdELGdEQUFnRCxnREFBZ0QsMkNBQTJDLDJDQUEyQywyQ0FBMkMsMkNBQTJDLHdDQUF3Qyw2RUFBNkUsNkVBQTZFLDZFQUE2RSw2RUFBNkUsMEVBQTBFLGtCQUFrQixHQUFHLG1JQUFtSSx1RUFBdUUsMERBQTBELG9EQUFvRCxpQ0FBaUMsc0VBQXNFLGdEQUFnRCx1Q0FBdUMsR0FBRyxrQ0FBa0MsZ0JBQWdCLEdBQUcsd0VBQXdFLCtFQUErRSxHQUFHLG9LQUFvSywyRUFBMkUsOERBQThELHNFQUFzRSwrQ0FBK0MsdUNBQXVDLCtDQUErQyx5QkFBeUIsR0FBRyxvRUFBb0UseURBQXlELEdBQUcscUVBQXFFLGlEQUFpRCxHQUFHOztBQUV4OEwsOEVBQThFLDRCQUE0QixzQkFBc0IsK0JBQStCLCtCQUErQiwwREFBMEQsd0VBQXdFLHdFQUF3RSw4QkFBOEIsS0FBSyx3RUFBd0Usd0ZBQXdGLHdGQUF3RiwwQkFBMEIscUNBQXFDLHFDQUFxQyxzQ0FBc0Msa0VBQWtFLDBEQUEwRCxLQUFLOztBQUU5NkIsZ0ZBQWdGLDJCQUEyQixTQUFTLHVDQUF1QywrREFBK0QsS0FBSyxtRkFBbUYsMENBQTBDLHlCQUF5QixTQUFTLHlDQUF5QywyRUFBMkUsT0FBTyw2QkFBNkI7O0FBRXRoQixxSkFBcUosaUVBQWlFOztBQUV0Tiw2SUFBNkk7O0FBRTdJLDhJQUE4STs7QUFFOUksc0VBQXNFOztBQUV0RSxvRUFBb0U7O0FBRXBFLGtFQUFrRTs7QUFFbEUsZ0VBQWdFOztBQUVoRSx3VkFBd1YsWUFBWSxFQUFFLGtDQUFrQyxjQUFjLEVBQUUsa0NBQWtDLGdCQUFnQixjQUFjLEVBQUUsd0NBQXdDLHFDQUFxQyxFQUFFLHdDQUF3Qyw4REFBOEQsbUVBQW1FLDhCQUE4QixHQUFHLHdCQUF3QixlQUFlLG1CQUFtQixpQkFBaUIsSUFBSSx5QkFBeUIsdUJBQXVCLHdCQUF3Qix5QkFBeUIsMEJBQTBCLElBQUksMkJBQTJCLGtCQUFrQixnQkFBZ0IsaUJBQWlCLElBQUksMERBQTBELDBEQUEwRCxHQUFHLGlFQUFpRSwwREFBMEQsR0FBRyxrRkFBa0YsOERBQThELDRDQUE0QyxHQUFHLGlGQUFpRiw0REFBNEQsR0FBRyxvSEFBb0gsZ0lBQWdJLEdBQUcseUNBQXlDLGFBQWEsb0RBQW9ELG9EQUFvRCxvREFBb0QsZUFBZSxHQUFHLDBEQUEwRCxrREFBa0QscUNBQXFDLEdBQUc7O0FBRXRzRSwrSUFBK0ksdUNBQXVDLGtCQUFrQiwyQ0FBMkMsbUZBQW1GLG1EQUFtRCxLQUFLLFVBQVUsbUZBQW1GLG1EQUFtRCxLQUFLLGdCQUFnQixHQUFHLDZMQUE2TCx5REFBeUQsd0NBQXdDLHdDQUF3QyxnREFBZ0QsZ0RBQWdELGtEQUFrRCx5Q0FBeUMsbUNBQW1DLGtEQUFrRCxHQUFHLGlNQUFpTSx1RUFBdUUsMkNBQTJDLGdFQUFnRSxxREFBcUQsbURBQW1ELCtEQUErRCx5RUFBeUUsZ0NBQWdDLDZDQUE2QyxXQUFXLGdCQUFnQiwrQ0FBK0MsdUNBQXVDLG9CQUFvQix1REFBdUQsc0RBQXNELDJEQUEyRCxLQUFLLHlCQUF5QixzREFBc0QseURBQXlELDJEQUEyRCxLQUFLLHlCQUF5QixzREFBc0QsNkRBQTZELDJEQUEyRCxLQUFLLHlCQUF5QixzREFBc0QscURBQXFELDZEQUE2RCxLQUFLLHlCQUF5Qix1REFBdUQsd0RBQXdELDZEQUE2RCxLQUFLLFVBQVUsdURBQXVELDREQUE0RCw2REFBNkQsS0FBSyxxQkFBcUIsb0RBQW9ELHVEQUF1RCw2Q0FBNkMsb0RBQW9ELEdBQUcsZ0lBQWdJLG9EQUFvRCxtQ0FBbUMsd0JBQXdCLGtDQUFrQyxtRUFBbUUsd0JBQXdCLDZCQUE2QixnQ0FBZ0MseUNBQXlDLDJDQUEyQywyREFBMkQsaUVBQWlFLDJEQUEyRCxpRUFBaUUsMkNBQTJDLGlDQUFpQyxHQUFHOztBQUU1bUksa0ZBQWtGLCtEQUErRDs7QUFFakosb0dBQW9HLG9DQUFvQyxtQ0FBbUM7O0FBRTNLLHNMQUFzTDs7QUFFdEwsMEdBQTBHLHNFQUFzRSwrQ0FBK0M7O0FBRS9OLDBGQUEwRjs7QUFFMUYsZ0ZBQWdGOztBQUVoRix3RUFBd0UsaUJBQWlCLEdBQUcsNkRBQTZELGtFQUFrRSxHQUFHLDZEQUE2RCx3RUFBd0UsR0FBRyxzQ0FBc0Msc0xBQXNMLEdBQUcsc0NBQXNDLHVLQUF1SyxHQUFHLHNDQUFzQyxvRUFBb0UsR0FBRyxzQ0FBc0MsaUVBQWlFLHNFQUFzRSxzRUFBc0UsR0FBRyx5REFBeUQsdURBQXVELEdBQUcseURBQXlELDJEQUEyRCx3REFBd0QsNkNBQTZDLG1EQUFtRCxHQUFHLHlEQUF5RCx1RUFBdUUsR0FBRyx5REFBeUQsMkRBQTJELGlEQUFpRCxrREFBa0QsK0RBQStELEdBQUcsdUdBQXVHLHlDQUF5QywwQ0FBMEMsdURBQXVELGlCQUFpQiw0Q0FBNEMsK0NBQStDLDBCQUEwQiw0REFBNEQsbUJBQW1CLEdBQUcsbUhBQW1ILHdDQUF3Qyx5Q0FBeUMsbUJBQW1CLDJDQUEyQyx3Q0FBd0Msd0NBQXdDLGdEQUFnRCx1Q0FBdUMsR0FBRzs7QUFFM3dGLGdNQUFnTSx5RUFBeUUsb0dBQW9HLDZGQUE2RixzREFBc0QsbUlBQW1JLDREQUE0RCwyQ0FBMkMsbUZBQW1GLDZFQUE2RSxvREFBb0Qsa0ZBQWtGLDJHQUEyRyxzRUFBc0UsMkNBQTJDLHlEQUF5RCw2SUFBNkksa0lBQWtJLDhHQUE4Rzs7QUFFbHFELDRHQUE0RyxrQ0FBa0Msd0tBQXdLLHNFQUFzRSx3Q0FBd0MsdUNBQXVDLHlJQUF5SSxxQ0FBcUM7O0FBRXpuQiw0SkFBNEoscUNBQXFDLG9DQUFvQzs7QUFFck8sOEpBQThKLHFGQUFxRixvRkFBb0YsNkZBQTZGLHNGQUFzRjs7QUFFMWYsOERBQThEOztBQUU5RCxpRUFBaUU7O0FBRWpFLGdLQUFnSyx5RUFBeUUsOEVBQThFOztBQUV2VCxrRUFBa0UsMkJBQTJCLGtEQUFrRCxxQ0FBcUMsMkJBQTJCOztBQUUvTSwrRUFBK0Usb0VBQW9FLGtEQUFrRCxrREFBa0QsK0VBQStFLHdFQUF3RSxpQkFBaUI7O0FBRS9aLDRJQUE0STs7QUFFNUksaUZBQWlGLG9DQUFvQzs7QUFFckgseURBQXlELDRCQUE0QixxQ0FBcUMsbURBQW1ELGtEQUFrRCxnQ0FBZ0MsNENBQTRDLHlDQUF5QywwQ0FBMEMsNEJBQTRCLGtEQUFrRCxvQ0FBb0MsY0FBYyxnQ0FBZ0MsOENBQThDLHNCQUFzQixTQUFTLCtFQUErRSw0REFBNEQsd0RBQXdELGtFQUFrRSw2RkFBNkYsaUJBQWlCLHFEQUFxRCxxQkFBcUIsU0FBUyw2RUFBNkUsNERBQTRELHdEQUF3RCxrRUFBa0UsNkZBQTZGLGlCQUFpQixvREFBb0Qsb0JBQW9CLFNBQVMsMkZBQTJGLDREQUE0RCx3REFBd0Qsa0VBQWtFLDZGQUE2RixpQkFBaUIscURBQXFELHFCQUFxQixTQUFTLHFGQUFxRixtSEFBbUgsaUJBQWlCOztBQUU5cEUsbURBQW1ELHFFQUFxRSx3Q0FBd0MsNERBQTRELGdDQUFnQyxHQUFHLHFEQUFxRCxxQkFBcUIsaUJBQWlCLGlCQUFpQix1QkFBdUIseUJBQXlCLHlCQUF5QixNQUFNLGlFQUFpRSwrSkFBK0osaURBQWlELHlEQUF5RCxpQ0FBaUMsS0FBSyx5REFBeUQsb0JBQW9CLGlCQUFpQixxQkFBcUIsa0JBQWtCLGlCQUFpQix1QkFBdUIseUJBQXlCLHlCQUF5Qiw2QkFBNkIsNEJBQTRCLE1BQU0sdURBQXVELDZJQUE2SSw2REFBNkQsbURBQW1ELDhDQUE4QywyQ0FBMkMsNEhBQTRILGlFQUFpRSxLQUFLLHVEQUF1RCxvQkFBb0IscUJBQXFCLGlCQUFpQixxQkFBcUIsa0JBQWtCLG9CQUFvQix3QkFBd0IsaUJBQWlCLHVCQUF1Qix5QkFBeUIseUJBQXlCLE1BQU0sb0RBQW9ELDJJQUEySSw0REFBNEQsbURBQW1ELDhDQUE4Qyx5RUFBeUUsMkNBQTJDLDRGQUE0Riw0Q0FBNEMseUlBQXlJLG1DQUFtQyxPQUFPLE9BQU8sd0NBQXdDLG9DQUFvQyxPQUFPLEtBQUssZ0VBQWdFLGlCQUFpQixvQkFBb0IscUJBQXFCLHNCQUFzQixNQUFNLDZCQUE2QiwyQkFBMkIsaUVBQWlFLDZEQUE2RCxxQkFBcUIsb0JBQW9CLHVCQUF1QixNQUFNLGdFQUFnRSxpSEFBaUgsZ0VBQWdFLGtEQUFrRCw0RkFBNEYsZ0VBQWdFLG9DQUFvQyxLQUFLLG9LQUFvSyxrRkFBa0Ysd0dBQXdHLHVIQUF1SCxnR0FBZ0csK0VBQStFLHFIQUFxSCwwREFBMEQsa0RBQWtELGdFQUFnRSxLQUFLLGtHQUFrRyxxREFBcUQsK0dBQStHLDhEQUE4RCxLQUFLLCtJQUErSSwyR0FBMkcsb0dBQW9HLG1GQUFtRiwwRkFBMEYsNkdBQTZHLDBIQUEwSCxtR0FBbUcsK0VBQStFLDBIQUEwSCwrR0FBK0csZ0VBQWdFLHFGQUFxRiwrRUFBK0UsaUhBQWlILDBGQUEwRiwrRUFBK0Usb0pBQW9KLG1JQUFtSSw0R0FBNEcsK0VBQStFLDJEQUEyRCxLQUFLOztBQUUvaU8sMERBQTBELDJDQUEyQyxvQ0FBb0MseUNBQXlDLCtDQUErQzs7QUFFak8sOERBQThELDhDQUE4QyxxQ0FBcUMsdUJBQXVCLHdCQUF3Qiw2QkFBNkIsNEJBQTRCLElBQUksa0xBQWtMLDJIQUEySCx1RkFBdUYsa0RBQWtELHNFQUFzRSx5R0FBeUcsb0xBQW9MLEdBQUcsaUxBQWlMLGlHQUFpRyxHQUFHOztBQUU5eUMsMkRBQTJELHVFQUF1RSxtRUFBbUUsNkhBQTZILDBJQUEwSSwrQ0FBK0MsdUVBQXVFOztBQUVsa0IsK0RBQStELHVCQUF1Qiw2QkFBNkIsd0JBQXdCLDBDQUEwQywrQkFBK0IsY0FBYyxvS0FBb0ssNklBQTZJLEdBQUcseU5BQXlOLG9DQUFvQyxzQ0FBc0Msd0NBQXdDLDZDQUE2QywrQ0FBK0MsaURBQWlELDRDQUE0QyxtREFBbUQsMkJBQTJCLDBEQUEwRCx3REFBd0QsMERBQTBELDBEQUEwRCxxREFBcUQsNkNBQTZDLHVDQUF1Qyx3SEFBd0gsZ0pBQWdKLDRJQUE0SSxLQUFLLHNMQUFzTCw0RUFBNEUsZ0RBQWdELDREQUE0RCx1SUFBdUksd0NBQXdDLG9MQUFvTCx3SEFBd0gsMk1BQTJNLGFBQWEsNktBQTZLLGlHQUFpRyxHQUFHLDZNQUE2TSw2RkFBNkYsMEJBQTBCLHlHQUF5Ryx3Q0FBd0MsbUxBQW1MLG1OQUFtTixhQUFhLGtrQkFBa2tCLGtIQUFrSCxHQUFHOztBQUVqc0osb0RBQW9ELHNDQUFzQywyQkFBMkIsZ0RBQWdELDRCQUE0QixnRkFBZ0Ysb0JBQW9CLHNCQUFzQixTQUFTLG9DQUFvQyx5RUFBeUUscVRBQXFULCtFQUErRSxLQUFLLHFGQUFxRixvQkFBb0IscUJBQXFCLFNBQVMsa0NBQWtDLHVFQUF1RSxpUEFBaVAsK0VBQStFLEtBQUssa0dBQWtHLG9CQUFvQixvQkFBb0IsU0FBUyxnREFBZ0QscUZBQXFGLDJSQUEyUiwrRUFBK0UsS0FBSywyR0FBMkcsb0JBQW9CLDBCQUEwQixTQUFTLDBDQUEwQyw4RUFBOEUsS0FBSyxnSEFBZ0gsMkdBQTJHLHdFQUF3RSxtREFBbUQsK0RBQStELHFCQUFxQixTQUFTLHNGQUFzRixPQUFPLG1LQUFtSyxtRkFBbUYsbUxBQW1MLHVKQUF1SixvREFBb0QscUdBQXFHOztBQUU5L0csNEpBQTRKOztBQUU1Six3RkFBd0YsNkRBQTZEOztBQUVySixtSEFBbUgsMENBQTBDOztBQUU3SixzSEFBc0gsaUdBQWlHLHFDQUFxQzs7QUFFNVAsK0VBQStFLGdEQUFnRCwrQkFBK0I7O0FBRTlKLGtFQUFrRTs7QUFFbEUsaUlBQWlJLHlDQUF5QyxpREFBaUQ7O0FBRTNOLDhFQUE4RSwwQkFBMEI7O0FBRXhHLGdFQUFnRSxrRkFBa0Ysd0NBQXdDOztBQUUxTCw2RkFBNkY7O0FBRTdGLDZIQUE2SCwyRUFBMkUsMkVBQTJFLDJFQUEyRTs7QUFFOVYsZ0lBQWdJLHNEQUFzRDs7QUFFdEwsOEhBQThILDRFQUE0RSw0RUFBNEUsNEVBQTRFLHdHQUF3Ryw0RUFBNEUsNEVBQTRFLDRFQUE0RTs7QUFFOXFCLDJJQUEySSxpR0FBaUcsaURBQWlELDhDQUE4Qyx1RkFBdUYsaUdBQWlHLG1HQUFtRzs7QUFFdG1CLG9GQUFvRiw2QkFBNkIsNERBQTRELGdGQUFnRixnRkFBZ0YsZ0NBQWdDLGdDQUFnQyxvREFBb0QscURBQXFELHNDQUFzQyw4REFBOEQsc0NBQXNDLGlDQUFpQyxxQ0FBcUMsS0FBSzs7QUFFM3NCLDhEQUE4RCwyQ0FBMkMsR0FBRywrQ0FBK0MsK0JBQStCLEdBQUcsd0NBQXdDLDBDQUEwQywwRUFBMEUsdUVBQXVFLHNDQUFzQyw0Q0FBNEMsaURBQWlELGlDQUFpQyx5QkFBeUIsR0FBRyw4Q0FBOEMsbUNBQW1DLEdBQUcsbUdBQW1HLDZDQUE2QyxHQUFHLHlHQUF5RywrQ0FBK0MsR0FBRyxrR0FBa0csaUVBQWlFLEdBQUcscUdBQXFHLGdFQUFnRSxHQUFHOztBQUVoekMsc0dBQXNHOztBQUV0RyxvRkFBb0YsOENBQThDOztBQUVsSSx3R0FBd0c7O0FBRXhHLDBGQUEwRixvREFBb0QsZ0ZBQWdGLCtGQUErRixzQ0FBc0MsS0FBSzs7QUFFeFcsZ0VBQWdFLGtGQUFrRix3Q0FBd0M7O0FBRTFMLDZGQUE2Rjs7QUFFN0YsNklBQTZJLDZEQUE2RCw4RkFBOEYsdURBQXVELGlHQUFpRyx5REFBeUQsa0ZBQWtGLDJFQUEyRSxLQUFLLHNGQUFzRiwyQ0FBMkMsMENBQTBDLHdEQUF3RCx5RkFBeUYseUZBQXlGLHlGQUF5Rix5RkFBeUYsd0NBQXdDLG1DQUFtQyxtQ0FBbUMsaUNBQWlDLGVBQWUsS0FBSyx3SEFBd0gseUJBQXlCLHVDQUF1QyxrQ0FBa0MsNEhBQTRILDJDQUEyQyxzRUFBc0UsK0NBQStDLDBCQUEwQiw0RkFBNEYsaURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELDAwQkFBMDBCLG1HQUFtRyxpREFBaUQsaURBQWlELGlEQUFpRCxpREFBaUQsNCtCQUE0K0IseUZBQXlGLG1CQUFtQixvQkFBb0IsS0FBSywrQ0FBK0MsMkJBQTJCLHFFQUFxRSwwQkFBMEIsb0RBQW9ELHlCQUF5Qiw0Q0FBNEMsMkNBQTJDLGtDQUFrQyx1REFBdUQsT0FBTyxrQ0FBa0Msa0NBQWtDLDZDQUE2QyxPQUFPLGtDQUFrQyxrQ0FBa0MsMkNBQTJDLHFDQUFxQyxPQUFPLGdFQUFnRSxLQUFLLDRLQUE0SywwRUFBMEUsNkNBQTZDLDJHQUEyRyxxQkFBcUIsK0NBQStDLCtJQUErSSw0ekJBQTR6QiwyRkFBMkYsaUJBQWlCOztBQUVycU4seUlBQXlJLDZEQUE2RCw0RkFBNEYsdURBQXVELCtGQUErRix5REFBeUQ7O0FBRWpmLDJGQUEyRixvQkFBb0IsU0FBUyxrRkFBa0YsS0FBSyx5REFBeUQscUJBQXFCLFNBQVMsb0VBQW9FLEtBQUssMERBQTBELHNCQUFzQixTQUFTLHNFQUFzRSxLQUFLOztBQUVuaEIsd0RBQXdELHVCQUF1Qix3RkFBd0Ysb0JBQW9CLG9CQUFvQixTQUFTLGdEQUFnRCx5TkFBeU4sS0FBSyw2REFBNkQsb0JBQW9CLHFCQUFxQixTQUFTLGtDQUFrQywrS0FBK0ssS0FBSyxnRUFBZ0Usb0JBQW9CLHNCQUFzQixTQUFTLG9DQUFvQyxtUEFBbVAsS0FBSyxzQ0FBc0MsR0FBRzs7QUFFbnVDLDRGQUE0RixpREFBaUQsaURBQWlELGlEQUFpRDs7QUFFL08sNEVBQTRFLG1DQUFtQywyREFBMkQsa0NBQWtDLDhDQUE4QywwQkFBMEIscURBQXFELHdEQUF3RCxrREFBa0Qsa0RBQWtELDZCQUE2Qix3RUFBd0Usd0VBQXdFLHdFQUF3RSx3RUFBd0UsMkNBQTJDLG9CQUFvQixPQUFPLHNEQUFzRCw4Q0FBOEMsMkNBQTJDLG9CQUFvQixPQUFPOztBQUVsaEMsdUdBQXVHLCtCQUErQixvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0Qsc0RBQXNEOztBQUU1WSwrRUFBK0UsMENBQTBDLDBDQUEwQywwQ0FBMEMsMENBQTBDLDhEQUE4RCxzRUFBc0U7O0FBRTNYLG9EQUFvRCwrRUFBK0UsdUNBQXVDLGtDQUFrQzs7QUFFNU0sMEZBQTBGOztBQUUxRiwrR0FBK0c7O0FBRS9HLDBJQUEwSSxzQ0FBc0Msd0NBQXdDLHVDQUF1QyxHQUFHLDBDQUEwQyxpQ0FBaUMsdURBQXVELEdBQUcsOE1BQThNLGlDQUFpQyxxR0FBcUcsR0FBRyxpREFBaUQsaUNBQWlDLDhDQUE4Qyw0R0FBNEcsR0FBRzs7QUFFNzhCLCtRQUErUTs7QUFFL1EsNlFBQTZRLDZCQUE2Qjs7QUFFMVMsZ1NBQWdTOztBQUVoUyxtR0FBbUc7O0FBRW5HLGtHQUFrRyxzQkFBc0I7O0FBRXhILHFGQUFxRjs7QUFFckYscUtBQXFLOztBQUVySyw0Q0FBNEMsc0JBQXNCLHdCQUF3Qiw4QkFBOEIsZUFBZSw2RkFBNkYsOEJBQThCLEdBQUc7O0FBRXJRLDhDQUE4QyxrQ0FBa0MsaUVBQWlFLDBGQUEwRixHQUFHOztBQUU5TyxzRUFBc0UsNE9BQTRPLDJFQUEyRSw0REFBNEQsbU9BQW1PLHNGQUFzRixhQUFhOztBQUUvdkIsdVFBQXVRLDJhQUEyYTs7QUFFbHJCLDJFQUEyRSw2QkFBNkIsNEJBQTRCLDhCQUE4QiwrTEFBK0wsMkVBQTJFLDBKQUEwSixvRUFBb0UsNEJBQTRCLDJDQUEyQyxHQUFHOztBQUVwdEIsd0VBQXdFLGtOQUFrTiw0Y0FBNGMsR0FBRzs7QUFFenVCLGtEQUFrRCw4QkFBOEIsa0NBQWtDLGlEQUFpRCxrQkFBa0IsZ0ZBQWdGLHlFQUF5RSxvREFBb0QsR0FBRzs7QUFFclksa0RBQWtELGtDQUFrQyxpRUFBaUUsMkRBQTJEOztBQUVoTiw2Q0FBNkMsd0JBQXdCLHlCQUF5QiwwQkFBMEIsOEJBQThCLGdMQUFnTCw4RkFBOEYsY0FBYyxLQUFLLHFDQUFxQyxpREFBaUQscUdBQXFHLHlEQUF5RCw2SUFBNkk7O0FBRXh6Qiw0Q0FBNEMsK0JBQStCLDhCQUE4Qix3S0FBd0ssb0VBQW9FLDhEQUE4RCxnREFBZ0Qsa0dBQWtHOztBQUVyaUIsNENBQTRDLHdCQUF3Qiw4Q0FBOEMsOGJBQThiLHdGQUF3Rix3U0FBd1MsbUhBQW1ILDZEQUE2RCw4RkFBOEYsd0RBQXdELHVGQUF1Riw2SUFBNkk7O0FBRTE5Qyx3VkFBd1YsaWlCQUFpaUI7O0FBRXozQiw4Q0FBOEMsd0JBQXdCLHdCQUF3QiwyQkFBMkIsaURBQWlELCtvQkFBK29CLHdGQUF3Rix5R0FBeUcsMENBQTBDLHNUQUFzVCwrR0FBK0csMEdBQTBHLDBEQUEwRCx5R0FBeUcsNElBQTRJLHVGQUF1Riw4S0FBOEs7O0FBRXZtRSxtRUFBbUUsaURBQWlELHVaQUF1Wixxa0JBQXFrQjs7QUFFaGxDLDJEQUEyRCx3QkFBd0Isd0JBQXdCLDBCQUEwQix3QkFBd0IscXZCQUFxdkIsd0ZBQXdGLHlHQUF5RywwQ0FBMEMsZ2hCQUFnaEIsdUZBQXVGLDhLQUE4Szs7QUFFbDVELGlFQUFpRSw4Q0FBOEMscVpBQXFaLGlUQUFpVCwrUUFBK1EscUhBQXFIOztBQUV6ckMsaUVBQWlFLHdCQUF3QiwwQkFBMEIsMEJBQTBCLHdCQUF3Qiw4Q0FBOEMscUNBQXFDLHFDQUFxQyw4Q0FBOEMsMHlCQUEweUIsd0ZBQXdGLHlHQUF5RywwQ0FBMEMsd2pCQUF3akIseURBQXlELDhLQUE4Szs7QUFFL25FLHVFQUF1RSw4Q0FBOEMsc1hBQXNYLGlUQUFpVCwrUUFBK1EseUZBQXlGOztBQUVwb0MsMERBQTBELGlIQUFpSCxzREFBc0Qsb0xBQW9MLCtIQUErSCxHQUFHOztBQUV2aEIsbUpBQW1KLHNEQUFzRCxtTUFBbU0sNlBBQTZQLDRUQUE0VCxXQUFXOztBQUVoOUIseUNBQXlDLHdCQUF3QiwrUUFBK1EsNEVBQTRFLGlEQUFpRCwwS0FBMEsseURBQXlELDZJQUE2STs7QUFFN3pCLHVDQUF1QyxzQkFBc0IsME1BQTBNLHdLQUF3SyxtQ0FBbUMseUtBQXlLOztBQUUzbkIsdUNBQXVDLHdCQUF3Qix1TUFBdU0sc0VBQXNFLDhCQUE4Qjs7QUFFMVcsK0ZBQStGLGlKQUFpSjs7QUFFaFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGdCQUFnQiwrQkFBK0I7QUFDL0MsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGlCQUFpQixhQUFhO0FBQzlCLGlCQUFpQixhQUFhO0FBQzlCLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixnQkFBZ0IsV0FBVztBQUMzQixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxhQUFhO0FBQ3pCLGNBQWM7QUFDZCxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRCxvQkFBb0IsV0FBVztBQUMvQixtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQyxlQUFlO0FBQ2YsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0M7O0FBRWxDLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIsNkJBQTZCOztBQUU3QixxQ0FBcUM7O0FBRXJDLDhCQUE4QjtBQUM5Qix3QkFBd0I7O0FBRXhCLHVCQUF1QjtBQUN2QixnQ0FBZ0M7O0FBRWhDLG1CQUFtQjs7QUFFbkIsZ0JBQWdCOztBQUVoQiwyQkFBMkI7O0FBRTNCLCtCQUErQjs7QUFFL0Isc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFLGtFQUFrRTtBQUNsRSxrRUFBa0U7O0FBRWxFLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDs7QUFFaEQsNEVBQTRFO0FBQzVFLDRFQUE0RTs7QUFFNUUsUUFBUTs7QUFFUiwyRkFBMkY7O0FBRTNGLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsa0NBQWtDOztBQUVsQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLHlCQUF5Qjs7QUFFekIsdUJBQXVCO0FBQ3ZCLGdDQUFnQzs7QUFFaEMsbUJBQW1COztBQUVuQjs7QUFFQSwrQkFBK0I7O0FBRS9CLGtEQUFrRDs7QUFFbEQ7O0FBRUEsUUFBUSw4QkFBOEI7O0FBRXRDLDZDQUE2Qzs7QUFFN0M7O0FBRUEsUUFBUSxPQUFPOztBQUVmLDZDQUE2QztBQUM3QywyQ0FBMkM7QUFDM0MsK0JBQStCO0FBQy9CLGtDQUFrQzs7QUFFbEMsUUFBUTs7QUFFUixPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtREFBbUQsUUFBUTs7QUFFM0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW9EOztBQUVwRDs7QUFFQSxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLDBCQUEwQjs7QUFFMUIsNkJBQTZCO0FBQzdCLHVCQUF1Qjs7QUFFdkIsc0JBQXNCO0FBQ3RCLDRCQUE0Qjs7QUFFNUIsa0JBQWtCOztBQUVsQixvQ0FBb0M7O0FBRXBDLDhDQUE4Qzs7QUFFOUMsMkJBQTJCO0FBQzNCLG9HQUFvRztBQUNwRyxvR0FBb0c7O0FBRXBHLHNCQUFzQjs7QUFFdEIsZ0VBQWdFO0FBQ2hFLHVDQUF1Qzs7QUFFdkMsa0RBQWtEOztBQUVsRCxnQ0FBZ0M7O0FBRWhDLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsb0RBQW9EOztBQUVwRDs7QUFFQSx3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCLDJCQUEyQjs7QUFFM0IseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiw2QkFBNkI7O0FBRTdCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7O0FBRTVCLGtCQUFrQjs7QUFFbEIsMkNBQTJDOztBQUUzQyxzRUFBc0U7O0FBRXRFLGdEQUFnRDs7QUFFaEQsMEJBQTBCOztBQUUxQiw2QkFBNkI7O0FBRTdCLDRCQUE0Qjs7QUFFNUIsNERBQTREOztBQUU1RCxRQUFRLE9BQU87O0FBRWYsb0NBQW9DO0FBQ3BDLG1GQUFtRjtBQUNuRix1REFBdUQ7O0FBRXZELFFBQVE7O0FBRVIsdUVBQXVFOztBQUV2RSxPQUFPOztBQUVQLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUJBQXVCOztBQUU3RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsd0NBQXdDLE9BQU87O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsaUNBQWlDOztBQUVuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIsa0JBQWtCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVCQUF1Qjs7QUFFN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQztBQUNoQywrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsb0JBQW9CLHNCQUFzQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixnQkFBZ0I7O0FBRTNDOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxvQkFBb0Isc0JBQXNCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsa0JBQWtCOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgseUJBQXlCOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQyxPQUFPOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiwwQkFBMEI7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiw0QkFBNEI7O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7O0FBRTlEOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTs7QUFFakU7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEscURBQXFELFFBQVE7O0FBRTdEOztBQUVBOztBQUVBLG9EQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjs7QUFFQSxzQ0FBc0MseUJBQXlCOztBQUUvRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4QyxRQUFROztBQUV0RDtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDtBQUNBOztBQUVBLG9EQUFvRCxRQUFROztBQUU1RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsc0JBQXNCOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixtQkFBbUI7O0FBRXZDOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxxQkFBcUIsb0JBQW9COztBQUV6Qzs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLHFCQUFxQiwwQkFBMEI7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFROztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLGdEQUFnRCxRQUFROztBQUV4RDs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1ELFFBQVE7O0FBRTNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRCxRQUFROztBQUUxRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQyxRQUFROztBQUV6Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0MsUUFBUTs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7O0FBRUEsZ0RBQWdELFFBQVE7O0FBRXhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsWUFBWTs7QUFFL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixZQUFZOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLDBCQUEwQjs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCOztBQUUxQzs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MsUUFBUTs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFROztBQUVuRDs7QUFFQSxrQ0FBa0MsUUFBUTs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlELFFBQVE7O0FBRWpFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdEQUF3RCxRQUFROztBQUVoRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsUUFBUTs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOERBQThELFFBQVE7O0FBRXRFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDREQUE0RCxRQUFROztBQUVwRTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsUUFBUTs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0NBQXdDLFFBQVE7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxRQUFROztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLHdCQUF3QixrQkFBa0I7O0FBRTFDOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixrQkFBa0I7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHdCQUF3Qjs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isd0JBQXdCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGtCQUFrQjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isd0JBQXdCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0Isd0JBQXdCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQyxPQUFPOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBLHNDQUFzQywrQkFBK0I7O0FBRXJFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnREFBZ0QsNEJBQTRCOztBQUU1RTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsT0FBTzs7QUFFL0M7O0FBRUEscUJBQXFCLGNBQWM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixlQUFlOztBQUUvQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpELDJDQUEyQyxPQUFPOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MsT0FBTzs7QUFFekM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsd0JBQXdCLGtCQUFrQjs7QUFFMUM7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnR0FBZ0c7QUFDaEcsZ0dBQWdHO0FBQ2hHLDJGQUEyRjtBQUMzRiwrRkFBK0Y7QUFDL0YsOEZBQThGO0FBQzlGLGtHQUFrRzs7QUFFbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixhQUFhOztBQUU3Qjs7QUFFQSxpQkFBaUIsYUFBYTs7QUFFOUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTs7QUFFNUIsaUJBQWlCLFlBQVk7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxhQUFhOztBQUU1Qjs7QUFFQSxnQkFBZ0IsYUFBYTs7QUFFN0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLFlBQVk7O0FBRTNCLGdCQUFnQixZQUFZOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZ0JBQWdCLGdCQUFnQixhQUFhLGlCQUFpQixZQUFZLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQyw2RUFBNkUsR0FBRztBQUNwSCxzQ0FBc0MsOENBQThDLEdBQUc7O0FBRXZGOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix3QkFBd0I7O0FBRXhCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFCQUFxQjs7QUFFMUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDhFQUE4RSxrQ0FBa0M7O0FBRWhIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtEOztBQUVsRDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFROztBQUV0RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxPQUFPOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFROztBQUVoRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsUUFBUTs7QUFFekQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixrREFBa0Q7QUFDaEY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsWUFBWTs7QUFFaEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsWUFBWTs7QUFFL0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsWUFBWTs7QUFFL0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxrREFBa0QsT0FBTzs7QUFFekQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbURBQW1ELCtEQUErRCxFQUFFOztBQUVwSDs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCwwREFBMEQsRUFBRTs7QUFFL0c7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELG9EQUFvRCxFQUFFOztBQUV6Rzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87O0FBRXpCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxZQUFZLGFBQWEsZUFBZSxHQUFHOztBQUVuRjs7QUFFQTs7QUFFQSxtQ0FBbUMscUJBQXFCOztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsa0RBQWtEO0FBQ2xELGdEQUFnRDs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixpQ0FBaUM7O0FBRWpDLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IsdUJBQXVCOztBQUV2Qjs7QUFFQSwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEM7O0FBRUEsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DOztBQUVuQzs7QUFFQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQixnQ0FBZ0M7O0FBRWhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtEQUFrRDtBQUNsRCxnREFBZ0Q7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCO0FBQzdCLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQiwyQkFBMkI7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUoseUNBQXlDLFFBQVE7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxhQUFhLFFBQVE7O0FBRXJCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsV0FBVzs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCxTQUFTOztBQUUxRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLG9CQUFvQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsOEJBQThCOztBQUVqRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlFQUFpRTs7QUFFakU7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUEsNkJBQTZCOztBQUU3Qjs7QUFFQSxvQkFBb0IsZUFBZTs7QUFFbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxlQUFlOztBQUVwRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLElBQUk7O0FBRUo7O0FBRUEsaURBQWlEOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQiw0QkFBNEI7O0FBRWxEOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiwyQkFBMkI7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQiwyQkFBMkI7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QiwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQsaURBQWlEOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxPQUFPOztBQUV4RDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFROztBQUV2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsbUJBQW1COztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIscUNBQXFDOztBQUU5RDs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWSxPQUFPOztBQUVuQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsUUFBUTs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELFFBQVE7O0FBRXpEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixzQ0FBc0M7O0FBRXREOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sMkJBQTJCOztBQUUzQjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLGdCQUFnQixzQkFBc0I7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sNEJBQTRCOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOEVBQThFLGtDQUFrQzs7QUFFaEg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQ7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQSxNQUFNOztBQUVOLG9EQUFvRCxPQUFPOztBQUUzRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRDs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxxQkFBcUIsb0JBQW9COztBQUV6Qzs7QUFFQTs7QUFFQSxnREFBZ0Q7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkVBQTJFLGtDQUFrQzs7QUFFN0c7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwyQ0FBMkMsUUFBUTs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixnREFBZ0QsT0FBTzs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSwwQ0FBMEMsT0FBTzs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlDQUFpQyxPQUFPOztBQUV4Qzs7QUFFQSxnQkFBZ0IsT0FBTzs7QUFFdkI7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQTs7QUFFQSxzQkFBc0I7O0FBRXRCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLG1EQUFtRDs7QUFFcEU7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5ELGtCQUFrQixPQUFPOztBQUV6QjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5ELGlCQUFpQixPQUFPOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxhQUFhOztBQUUzQjs7QUFFQSxlQUFlLGFBQWE7O0FBRTVCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLFlBQVk7O0FBRTFCLGVBQWUsWUFBWTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQjs7QUFFL0IsR0FBRzs7QUFFSCwyQkFBMkI7O0FBRTNCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0JBQW9COztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxXQUFXOztBQUUxQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixXQUFXOztBQUUzQjs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsVUFBVTs7QUFFekIsZ0JBQWdCLDBCQUEwQjs7QUFFMUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQix5QkFBeUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHlCQUF5Qjs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIscUJBQXFCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHlCQUF5Qjs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWUscUJBQXFCOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxxQkFBcUI7O0FBRXBDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsc0JBQXNCOztBQUVyQyxnQkFBZ0IscUJBQXFCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsc0JBQXNCOztBQUVyQyxnQkFBZ0IscUJBQXFCOztBQUVyQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxzQkFBc0I7O0FBRXBDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUscUJBQXFCOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsc0JBQXNCOztBQUVwQyxlQUFlLHFCQUFxQjs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLHFCQUFxQjs7QUFFbkMsZUFBZSxzQkFBc0I7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGNBQWMscUJBQXFCOztBQUVuQyxlQUFlLHNCQUFzQjs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlFQUF5RTs7QUFFekU7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsY0FBYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLFNBQVM7O0FBRTVCLEdBQUc7O0FBRUgsdUJBQXVCLFlBQVk7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQyxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLGtCQUFrQjs7QUFFaEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLGlDQUFpQywrQkFBK0I7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTOztBQUU5QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QixPQUFPOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLG9CQUFvQjs7QUFFeEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjs7QUFFekM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEseUZBQXlGO0FBQ3pGLDJGQUEyRjtBQUMzRjs7QUFFQSxzRkFBc0Y7O0FBRXRGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEseUJBQXlCOztBQUV6QixpQ0FBaUMsUUFBUTs7QUFFekM7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSw4REFBOEQsUUFBUTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7O0FBRXpDOztBQUVBOztBQUVBLHlEQUF5RCxRQUFROztBQUVqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUEsY0FBYyxtQkFBbUI7O0FBRWpDLDZCQUE2QixPQUFPOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFFBQVE7O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtDQUFrQyxRQUFROztBQUUxQztBQUNBOztBQUVBLG1DQUFtQyxRQUFROztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLFVBQVU7O0FBRXhCOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsWUFBWTs7QUFFMUIsZUFBZSxVQUFVOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLGdCQUFnQixvQkFBb0I7QUFDcEMsOEJBQThCLFFBQVE7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsUUFBUTs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MsUUFBUTs7QUFFMUM7QUFDQTs7QUFFQSxtQ0FBbUMsUUFBUTs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsUUFBUTs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHNCQUFzQjs7QUFFckM7O0FBRUE7O0FBRUEsZ0JBQWdCLHFCQUFxQjs7QUFFckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxxQkFBcUI7O0FBRXBDLGdCQUFnQixvQkFBb0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGtCQUFrQjs7QUFFaEMsZUFBZSxvQkFBb0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLGlCQUFpQjs7QUFFL0I7O0FBRUEsZUFBZSxtQkFBbUI7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGVBQWU7O0FBRTdCOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSw0QkFBNEI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxjQUFjLGNBQWM7O0FBRTVCLGVBQWUsMkJBQTJCOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQixtQkFBbUI7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxtQkFBbUIsbUJBQW1COztBQUV0Qzs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLE9BQU87O0FBRWhEOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DOztBQUVBOztBQUVBLGlDQUFpQyxPQUFPOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxPQUFPOztBQUUzQzs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQixLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLHFCQUFxQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLHFCQUFxQjs7QUFFckM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsb0JBQW9COztBQUVuQyxnQkFBZ0Isb0JBQW9COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFCQUFxQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxxQkFBcUI7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZSxvQkFBb0I7O0FBRW5DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixlQUFlOztBQUVwQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsY0FBYyxlQUFlOztBQUU3Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCOztBQUVsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDOztBQUVyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGlCQUFpQjs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUEsK0NBQStDLGlCQUFpQjs7QUFFaEUsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxRQUFROztBQUVyRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU4sNkNBQTZDLFFBQVE7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLDRDQUE0QyxRQUFROztBQUVwRDtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLFFBQVE7O0FBRXBEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEscUNBQXFDLFFBQVE7O0FBRTdDOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLFdBQVc7O0FBRWpDLHNCQUFzQjs7QUFFdEIsdUJBQXVCLDBCQUEwQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7OztBQUdKOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsZ0JBQWdCOztBQUVuQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxnQkFBZ0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixLQUFLLHlCQUF5Qjs7QUFFOUMsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCOztBQUV2Qjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlLGVBQWU7O0FBRTlCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBLGVBQWUsZUFBZTs7QUFFOUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0ZBQXdGOztBQUV4Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixlQUFlOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjs7QUFFckI7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTRDLE9BQU87O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLGdCQUFnQjs7QUFFbkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsbUJBQW1COztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixnQkFBZ0I7O0FBRXBDOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxPQUFPOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsaUNBQWlDOztBQUVqQyxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87O0FBRWpEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxPQUFPOztBQUVqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLEVBQUU7O0FBRXJDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsRUFBRTs7QUFFckM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxnQkFBZ0I7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYzs7QUFFakM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2Qjs7QUFFN0I7O0FBRUEsOENBQThDOztBQUU5QyxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUzs7QUFFNUI7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0NBQWtDLHVCQUF1Qjs7QUFFekQ7O0FBRUEsb0JBQW9CLGNBQWM7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQzs7QUFFbkM7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixpQ0FBaUM7O0FBRWpDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsU0FBUzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixhQUFhOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGVBQWU7O0FBRWxDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjOztBQUVwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixjQUFjOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3RkFBd0YsY0FBYzs7QUFFdEc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsU0FBUzs7QUFFbkQ7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQiw0QkFBNEI7O0FBRS9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiwwQkFBMEI7O0FBRS9DOztBQUVBLHVCQUF1Qiw0Q0FBNEM7O0FBRW5FOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLDhDQUE4Qzs7QUFFcEU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLFNBQVM7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUEsbUJBQW1CLHdCQUF3Qjs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQSxtQkFBbUIsd0JBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsU0FBUzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUosR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsaUJBQWlCLHFCQUFxQjs7QUFFdEM7O0FBRUE7O0FBRUEsaUJBQWlCLGVBQWU7O0FBRWhDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQzs7QUFFQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBa0QsT0FBTzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0RBQWtELE9BQU87O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1ELE9BQU87O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxRQUFROztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLHVCQUF1Qjs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxhQUFhOztBQUViLEtBQUs7O0FBRUw7O0FBRUEsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLCtDQUErQyxPQUFPOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87O0FBRTVDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQiwyQkFBMkI7O0FBRWpEOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxtQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLE9BQU87O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIscUJBQXFCOztBQUUxQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQkFBcUIsbUJBQW1COztBQUV4QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsMkNBQTJDLE9BQU87O0FBRWxEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxhQUFhOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEMsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBOztBQUVBLGtEQUFrRDtBQUNsRCxtQkFBbUI7O0FBRW5CLE9BQU87O0FBRVA7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBLE1BQU07O0FBRU47QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMLHFDQUFxQyxnQ0FBZ0M7O0FBRXJFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELGFBQWE7O0FBRTdEOztBQUVBOztBQUVBLGdEQUFnRCxhQUFhOztBQUU3RDs7QUFFQSx3QkFBd0IsbUJBQW1COztBQUUzQztBQUNBOztBQUVBLDBCQUEwQiwwQkFBMEI7O0FBRXBEOztBQUVBLDhDQUE4QyxzQ0FBc0M7QUFDcEY7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGtCQUFrQjs7QUFFdEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsWUFBWTs7QUFFWjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSixHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxJQUFJOztBQUVKOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSw2Q0FBNkMsT0FBTzs7QUFFcEQ7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLGNBQWM7O0FBRWxDOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlEQUFpRCxTQUFTOztBQUUxRDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsY0FBYzs7QUFFbEM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLG1CQUFtQixjQUFjOztBQUVqQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsU0FBUzs7QUFFcEM7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixTQUFTOztBQUVwQzs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFNBQVM7O0FBRXBDOztBQUVBOztBQUVBOztBQUVBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsMkJBQTJCOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixxQkFBcUI7O0FBRTFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUYsNENBQTRDOztBQUU1QztBQUNBLHVDQUF1QztBQUN2Qyx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLHVDQUF1QyxTQUFTOztBQUVoRDs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLHNDQUFzQyxTQUFTOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IseUJBQXlCOztBQUUvQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxEO0FBQ0E7O0FBRUEsSUFBSSxnRUFBZ0U7O0FBRXBFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isd0RBQXdEOztBQUU5RTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLDRDQUE0Qzs7QUFFbEU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDLHdDQUF3QyxTQUFTOztBQUVqRDs7QUFFQTs7QUFFQSxtQkFBbUI7QUFDbkIseUJBQXlCLGdCQUFnQjtBQUN6QyxzQkFBc0I7QUFDdEIsbUNBQW1DOztBQUVuQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFNBQVM7O0FBRTdDOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFNBQVM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBLEtBQUs7O0FBRUwsSUFBSTs7QUFFSjs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvQ0FBb0MsU0FBUzs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQyxTQUFTOztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQXFDLFNBQVM7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixLQUFLOztBQUVMLElBQUk7O0FBRUo7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxTQUFTOztBQUU3RDtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUIsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEIsa0NBQWtDOztBQUVsQyxnQ0FBZ0M7QUFDaEMsOEJBQThCOztBQUU5Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIseUJBQXlCO0FBQ3pCLDBCQUEwQjs7QUFFMUI7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxZQUFZOztBQUVaOztBQUVBOztBQUVBLDJCQUEyQjtBQUMzQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBLElBQUksT0FBTzs7QUFFWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsK0JBQStCOztBQUUvQjs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7O0FBRWxEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxTQUFTOztBQUVsRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsdUJBQXVCO0FBQ3ZCOztBQUVBLG9DQUFvQzs7O0FBR3BDLGtDQUFrQztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLHdDQUF3QyxTQUFTOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMERBQTBEOztBQUUxRDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7O0FBR0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCOztBQUVuQzs7QUFFQTs7QUFFQSxtQkFBbUIsaUJBQWlCOztBQUVwQzs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixnQkFBZ0I7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjs7QUFFcEM7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdELFNBQVM7O0FBRXpEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTzs7QUFFM0M7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsVUFBVTtBQUNWLFlBQVksZUFBZTtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3QyxPQUFPOztBQUUvQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSiwrSEFBK0g7QUFDL0g7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx1Q0FBdUMsT0FBTzs7QUFFOUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNGQUFzRjs7QUFFdEY7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3QyxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKLDhDQUE4QztBQUM5Qyx3RUFBd0U7O0FBRXhFOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdEQUF3RDtBQUN4RCxtREFBbUQ7QUFDbkQsdUNBQXVDOztBQUV2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw2REFBNkQsaUNBQWlDOztBQUU5Rjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUEscURBQXFELFFBQVE7O0FBRTdEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLFFBQVE7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLE9BQU87O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseUNBQXlDLGFBQWE7O0FBRXREO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0IsNEJBQTRCOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjs7QUFFcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMscUZBQXFGOztBQUU5SDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGtCQUFrQjs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsOEJBQThCOztBQUV2RTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsdURBQXVELGdGQUFnRjs7QUFFdkk7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5Q0FBeUMsYUFBYTs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLGtCQUFrQixpQkFBaUI7QUFDbkMsb0JBQW9CLGlCQUFpQjtBQUNyQyxvQkFBb0Isb0JBQW9CO0FBQ3hDLG1CQUFtQixvQkFBb0I7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsOEJBQThCO0FBQ3hFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUNBQXlDLGdCQUFnQjs7QUFFekQ7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsNkJBQTZCOztBQUV0RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGNBQWM7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGNBQWMsY0FBYzs7QUFFNUI7O0FBRUE7O0FBRUEsZUFBZSxlQUFlOztBQUU5Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsNkJBQTZCOztBQUV0RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkRBQTZELGlDQUFpQzs7QUFFOUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxxQ0FBcUMsT0FBTzs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLGFBQWE7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLDRDQUE0Qzs7QUFFckY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1QyxPQUFPOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsZUFBZTs7QUFFNUU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQyxzQkFBc0Isb0JBQW9CO0FBQzFDLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLHFCQUFxQjtBQUMzQyx1QkFBdUIscUJBQXFCO0FBQzVDLHVCQUF1QixxQkFBcUI7QUFDNUMsdUJBQXVCLHFCQUFxQjtBQUM1Qyx1QkFBdUIscUJBQXFCOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDZEQUE2RCxlQUFlOztBQUU1RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELGVBQWU7O0FBRXBFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsbUVBQW1FOztBQUU1SDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDhEQUE4RCxlQUFlO0FBQzdFO0FBQ0E7O0FBRUEsOERBQThELGVBQWU7QUFDN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsNkJBQTZCOztBQUV0RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseUZBQXlGLDRDQUE0Qzs7QUFFckk7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2RkFBNkYsNENBQTRDOztBQUV6STs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsY0FBYzs7QUFFN0QsQ0FBQzs7Ozs7Ozs7OztBQzk1NUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7O0FDcEJBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsV0FBVztBQUN0QixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxRkFBMkMsa0JBQWtCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQ3BFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsa0JBQWtCLEdBQUc7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGlCQUFpQjs7QUFFakIsY0FBYzs7QUFFZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGLG9DQUFvQztBQUNwQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DO0FBQ3BDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoicHVibGljL2pzL2htaTNkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMGJiNDRhYjk3ZGQzMjgwNzI2YTMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxyXG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxyXG5cdChmYWN0b3J5KChnbG9iYWwuVEhSRUUgPSB7fSkpKTtcclxufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHQvLyBQb2x5ZmlsbHNcclxuXHJcblx0aWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC0gNTIgKTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIE51bWJlci5pc0ludGVnZXIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHQvLyBNaXNzaW5nIGluIElFXHJcblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNJbnRlZ2VyXHJcblxyXG5cdFx0TnVtYmVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSAmJiBNYXRoLmZsb29yKCB2YWx1ZSApID09PSB2YWx1ZTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXHJcblxyXG5cdFx0TWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICggeCA8IDAgKSA/IC0gMSA6ICggeCA+IDAgKSA/IDEgOiArIHg7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoICduYW1lJyBpbiBGdW5jdGlvbi5wcm90b3R5cGUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdC8vIE1pc3NpbmcgaW4gSUVcclxuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWVcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XHJcblxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKS5tYXRjaCggL15cXHMqZnVuY3Rpb25cXHMqKFteXFwoXFxzXSopLyApWyAxIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggT2JqZWN0LmFzc2lnbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdC8vIE1pc3NpbmcgaW4gSUVcclxuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cclxuXHJcblx0XHQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgb3V0cHV0ID0gT2JqZWN0KCB0YXJnZXQgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc291cmNlID0gYXJndW1lbnRzWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG5leHRLZXkgaW4gc291cmNlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggc291cmNlLCBuZXh0S2V5ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b3V0cHV0WyBuZXh0S2V5IF0gPSBzb3VyY2VbIG5leHRLZXkgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9ICkoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge31cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcblxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cclxuXHRcdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblxyXG5cdFx0XHRyZXR1cm4gbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDE7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XHJcblxyXG5cdFx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcclxuXHJcblx0XHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdHZhciBSRVZJU0lPTiA9ICc4OSc7XHJcblx0dmFyIE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XHJcblx0dmFyIEN1bGxGYWNlTm9uZSA9IDA7XHJcblx0dmFyIEN1bGxGYWNlQmFjayA9IDE7XHJcblx0dmFyIEN1bGxGYWNlRnJvbnQgPSAyO1xyXG5cdHZhciBDdWxsRmFjZUZyb250QmFjayA9IDM7XHJcblx0dmFyIEZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcclxuXHR2YXIgRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcclxuXHR2YXIgQmFzaWNTaGFkb3dNYXAgPSAwO1xyXG5cdHZhciBQQ0ZTaGFkb3dNYXAgPSAxO1xyXG5cdHZhciBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcclxuXHR2YXIgRnJvbnRTaWRlID0gMDtcclxuXHR2YXIgQmFja1NpZGUgPSAxO1xyXG5cdHZhciBEb3VibGVTaWRlID0gMjtcclxuXHR2YXIgRmxhdFNoYWRpbmcgPSAxO1xyXG5cdHZhciBTbW9vdGhTaGFkaW5nID0gMjtcclxuXHR2YXIgTm9Db2xvcnMgPSAwO1xyXG5cdHZhciBGYWNlQ29sb3JzID0gMTtcclxuXHR2YXIgVmVydGV4Q29sb3JzID0gMjtcclxuXHR2YXIgTm9CbGVuZGluZyA9IDA7XHJcblx0dmFyIE5vcm1hbEJsZW5kaW5nID0gMTtcclxuXHR2YXIgQWRkaXRpdmVCbGVuZGluZyA9IDI7XHJcblx0dmFyIFN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xyXG5cdHZhciBNdWx0aXBseUJsZW5kaW5nID0gNDtcclxuXHR2YXIgQ3VzdG9tQmxlbmRpbmcgPSA1O1xyXG5cdHZhciBBZGRFcXVhdGlvbiA9IDEwMDtcclxuXHR2YXIgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcclxuXHR2YXIgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XHJcblx0dmFyIE1pbkVxdWF0aW9uID0gMTAzO1xyXG5cdHZhciBNYXhFcXVhdGlvbiA9IDEwNDtcclxuXHR2YXIgWmVyb0ZhY3RvciA9IDIwMDtcclxuXHR2YXIgT25lRmFjdG9yID0gMjAxO1xyXG5cdHZhciBTcmNDb2xvckZhY3RvciA9IDIwMjtcclxuXHR2YXIgT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuXHR2YXIgU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcblx0dmFyIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcblx0dmFyIERzdEFscGhhRmFjdG9yID0gMjA2O1xyXG5cdHZhciBPbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5cdHZhciBEc3RDb2xvckZhY3RvciA9IDIwODtcclxuXHR2YXIgT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcclxuXHR2YXIgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IDIxMDtcclxuXHR2YXIgTmV2ZXJEZXB0aCA9IDA7XHJcblx0dmFyIEFsd2F5c0RlcHRoID0gMTtcclxuXHR2YXIgTGVzc0RlcHRoID0gMjtcclxuXHR2YXIgTGVzc0VxdWFsRGVwdGggPSAzO1xyXG5cdHZhciBFcXVhbERlcHRoID0gNDtcclxuXHR2YXIgR3JlYXRlckVxdWFsRGVwdGggPSA1O1xyXG5cdHZhciBHcmVhdGVyRGVwdGggPSA2O1xyXG5cdHZhciBOb3RFcXVhbERlcHRoID0gNztcclxuXHR2YXIgTXVsdGlwbHlPcGVyYXRpb24gPSAwO1xyXG5cdHZhciBNaXhPcGVyYXRpb24gPSAxO1xyXG5cdHZhciBBZGRPcGVyYXRpb24gPSAyO1xyXG5cdHZhciBOb1RvbmVNYXBwaW5nID0gMDtcclxuXHR2YXIgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xyXG5cdHZhciBSZWluaGFyZFRvbmVNYXBwaW5nID0gMjtcclxuXHR2YXIgVW5jaGFydGVkMlRvbmVNYXBwaW5nID0gMztcclxuXHR2YXIgQ2luZW9uVG9uZU1hcHBpbmcgPSA0O1xyXG5cdHZhciBVVk1hcHBpbmcgPSAzMDA7XHJcblx0dmFyIEN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcclxuXHR2YXIgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xyXG5cdHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcclxuXHR2YXIgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDQ7XHJcblx0dmFyIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gMzA1O1xyXG5cdHZhciBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcclxuXHR2YXIgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDc7XHJcblx0dmFyIFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcclxuXHR2YXIgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XHJcblx0dmFyIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSAxMDAyO1xyXG5cdHZhciBOZWFyZXN0RmlsdGVyID0gMTAwMztcclxuXHR2YXIgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xyXG5cdHZhciBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcclxuXHR2YXIgTGluZWFyRmlsdGVyID0gMTAwNjtcclxuXHR2YXIgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XHJcblx0dmFyIExpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XHJcblx0dmFyIFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5cdHZhciBCeXRlVHlwZSA9IDEwMTA7XHJcblx0dmFyIFNob3J0VHlwZSA9IDEwMTE7XHJcblx0dmFyIFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuXHR2YXIgSW50VHlwZSA9IDEwMTM7XHJcblx0dmFyIFVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XHJcblx0dmFyIEZsb2F0VHlwZSA9IDEwMTU7XHJcblx0dmFyIEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xyXG5cdHZhciBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE3O1xyXG5cdHZhciBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xyXG5cdHZhciBVbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTk7XHJcblx0dmFyIFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XHJcblx0dmFyIEFscGhhRm9ybWF0ID0gMTAyMTtcclxuXHR2YXIgUkdCRm9ybWF0ID0gMTAyMjtcclxuXHR2YXIgUkdCQUZvcm1hdCA9IDEwMjM7XHJcblx0dmFyIEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XHJcblx0dmFyIEx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcclxuXHR2YXIgUkdCRUZvcm1hdCA9IFJHQkFGb3JtYXQ7XHJcblx0dmFyIERlcHRoRm9ybWF0ID0gMTAyNjtcclxuXHR2YXIgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcclxuXHR2YXIgUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xyXG5cdHZhciBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xyXG5cdHZhciBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xyXG5cdHZhciBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xyXG5cdHZhciBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XHJcblx0dmFyIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcclxuXHR2YXIgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcclxuXHR2YXIgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcclxuXHR2YXIgUkdCX0VUQzFfRm9ybWF0ID0gMjE1MTtcclxuXHR2YXIgTG9vcE9uY2UgPSAyMjAwO1xyXG5cdHZhciBMb29wUmVwZWF0ID0gMjIwMTtcclxuXHR2YXIgTG9vcFBpbmdQb25nID0gMjIwMjtcclxuXHR2YXIgSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IDIzMDA7XHJcblx0dmFyIEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcclxuXHR2YXIgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xyXG5cdHZhciBaZXJvQ3VydmF0dXJlRW5kaW5nID0gMjQwMDtcclxuXHR2YXIgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcclxuXHR2YXIgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XHJcblx0dmFyIFRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcclxuXHR2YXIgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcclxuXHR2YXIgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XHJcblx0dmFyIExpbmVhckVuY29kaW5nID0gMzAwMDtcclxuXHR2YXIgc1JHQkVuY29kaW5nID0gMzAwMTtcclxuXHR2YXIgR2FtbWFFbmNvZGluZyA9IDMwMDc7XHJcblx0dmFyIFJHQkVFbmNvZGluZyA9IDMwMDI7XHJcblx0dmFyIExvZ0x1dkVuY29kaW5nID0gMzAwMztcclxuXHR2YXIgUkdCTTdFbmNvZGluZyA9IDMwMDQ7XHJcblx0dmFyIFJHQk0xNkVuY29kaW5nID0gMzAwNTtcclxuXHR2YXIgUkdCREVuY29kaW5nID0gMzAwNjtcclxuXHR2YXIgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xyXG5cdHZhciBSR0JBRGVwdGhQYWNraW5nID0gMzIwMTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHR2YXIgX01hdGggPSB7XHJcblxyXG5cdFx0REVHMlJBRDogTWF0aC5QSSAvIDE4MCxcclxuXHRcdFJBRDJERUc6IDE4MCAvIE1hdGguUEksXHJcblxyXG5cdFx0Z2VuZXJhdGVVVUlEOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxyXG5cclxuXHRcdFx0dmFyIGx1dCA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRsdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApLnRvVXBwZXJDYXNlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHR2YXIgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0XHRcdFx0dmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xyXG5cdFx0XHRcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcclxuXHRcdFx0XHR2YXIgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XHJcblx0XHRcdFx0cmV0dXJuIGx1dFsgZDAgJiAweGZmIF0gKyBsdXRbIGQwID4+IDggJiAweGZmIF0gKyBsdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXHJcblx0XHRcdFx0XHRsdXRbIGQxICYgMHhmZiBdICsgbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgbHV0WyBkMSA+PiAxNiAmIDB4MGYgfCAweDQwIF0gKyBsdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcclxuXHRcdFx0XHRcdGx1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgbHV0WyBkMiA+PiA4ICYgMHhmZiBdICsgJy0nICsgbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIGx1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xyXG5cdFx0XHRcdFx0bHV0WyBkMyAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9ICkoKSxcclxuXHJcblx0XHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXHJcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXHJcblxyXG5cdFx0ZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiAoIG4sIG0gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxyXG5cclxuXHRcdG1hcExpbmVhcjogZnVuY3Rpb24gKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcclxuXHJcblx0XHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cclxuXHJcblx0XHRsZXJwOiBmdW5jdGlvbiAoIHgsIHksIHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCAxIC0gdCApICogeCArIHQgKiB5O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXHJcblxyXG5cdFx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRcdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuXHRcdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcblx0XHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRcdHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG5cdFx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXHJcblxyXG5cdFx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkZWdUb1JhZDogZnVuY3Rpb24gKCBkZWdyZWVzICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGRlZ3JlZXMgKiBfTWF0aC5ERUcyUkFEO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cmFkVG9EZWc6IGZ1bmN0aW9uICggcmFkaWFucyApIHtcclxuXHJcblx0XHRcdHJldHVybiByYWRpYW5zICogX01hdGguUkFEMkRFRztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2VpbFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguY2VpbCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmbG9vclBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG5cdCAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBWZWN0b3IyKCB4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHggfHwgMDtcclxuXHRcdHRoaXMueSA9IHkgfHwgMDtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVmVjdG9yMi5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRcIndpZHRoXCI6IHtcclxuXHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy54O1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRcImhlaWdodFwiOiB7XHJcblxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMueTtcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBWZWN0b3IyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGlzVmVjdG9yMjogdHJ1ZSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHg7XHJcblx0XHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHRcdHRoaXMueSArPSB2Lnk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICs9IHM7XHJcblx0XHRcdHRoaXMueSArPSBzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy54IC09IHYueDtcclxuXHRcdFx0dGhpcy55IC09IHYueTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggLT0gcztcclxuXHRcdFx0dGhpcy55IC09IHM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IGEueCAtIGIueDtcclxuXHRcdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHYueDtcclxuXHRcdFx0dGhpcy55ICo9IHYueTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggLz0gdi54O1xyXG5cdFx0XHR0aGlzLnkgLz0gdi55O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XHJcblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdO1xyXG5cdFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgbWluID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdFx0dmFyIG1heCA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xyXG5cdFx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAtIHRoaXMueDtcclxuXHRcdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFuZ2xlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xyXG5cclxuXHRcdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy55LCB0aGlzLnggKTtcclxuXHJcblx0XHRcdGlmICggYW5nbGUgPCAwICkgYW5nbGUgKz0gMiAqIE1hdGguUEk7XHJcblxyXG5cdFx0XHRyZXR1cm4gYW5nbGU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xyXG5cdFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtYW5oYXR0YW5EaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHJcblx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xyXG5cdFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoIGNlbnRlciwgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xyXG5cdFx0XHR2YXIgeSA9IHRoaXMueSAtIGNlbnRlci55O1xyXG5cclxuXHRcdFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xyXG5cdFx0XHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG5cdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcblx0ICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxyXG5cdCAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcblx0ICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xyXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTWF0cml4NCgpIHtcclxuXHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW1xyXG5cclxuXHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0MCwgMCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdF07XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggTWF0cml4NC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc01hdHJpeDQ6IHRydWUsXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcclxuXHRcdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XHJcblx0XHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcclxuXHRcdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRcdDEsIDAsIDAsIDAsXHJcblx0XHRcdFx0MCwgMSwgMCwgMCxcclxuXHRcdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdOyB0ZVsgMyBdID0gbWVbIDMgXTtcclxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XHJcblx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcclxuXHRcdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTsgdGVbIDEzIF0gPSBtZVsgMTMgXTsgdGVbIDE0IF0gPSBtZVsgMTQgXTsgdGVbIDE1IF0gPSBtZVsgMTUgXTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLCBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xyXG5cdFx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xyXG5cdFx0XHR0ZVsgMTQgXSA9IG1lWyAxNCBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRleHRyYWN0QmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcclxuXHJcblx0XHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcclxuXHRcdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xyXG5cdFx0XHR6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAyICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1ha2VCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoXHJcblx0XHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcclxuXHRcdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxyXG5cdFx0XHRcdHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXHJcblx0XHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZXh0cmFjdFJvdGF0aW9uKCBtICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0XHRcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xyXG5cdFx0XHRcdHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0XHRcdHZhciBzY2FsZVogPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xyXG5cclxuXHRcdFx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcclxuXHRcdFx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcclxuXHRcdFx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcclxuXHJcblx0XHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XHJcblx0XHRcdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XHJcblx0XHRcdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XHJcblxyXG5cdFx0XHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xyXG5cdFx0XHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xyXG5cdFx0XHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XHJcblx0XHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XHJcblx0XHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XHJcblxyXG5cdFx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XHJcblxyXG5cdFx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcclxuXHRcdFx0XHR0ZVsgOCBdID0gZDtcclxuXHJcblx0XHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xyXG5cdFx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcclxuXHRcdFx0XHR0ZVsgOSBdID0gLSBiICogYztcclxuXHJcblx0XHRcdFx0dGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xyXG5cdFx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcclxuXHRcdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xyXG5cdFx0XHRcdHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcclxuXHRcdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XHJcblxyXG5cdFx0XHRcdHRlWyAxIF0gPSBhICogZjtcclxuXHRcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XHJcblx0XHRcdFx0dGVbIDkgXSA9IC0gYjtcclxuXHJcblx0XHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xyXG5cdFx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcclxuXHRcdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcclxuXHJcblx0XHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xyXG5cdFx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xyXG5cdFx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcclxuXHJcblx0XHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xyXG5cdFx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XHJcblxyXG5cdFx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xyXG5cdFx0XHRcdHRlWyA2IF0gPSBiO1xyXG5cdFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xyXG5cdFx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcclxuXHJcblx0XHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xyXG5cdFx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcclxuXHRcdFx0XHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XHJcblxyXG5cdFx0XHRcdHRlWyAyIF0gPSAtIGQ7XHJcblx0XHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xyXG5cdFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XHJcblx0XHRcdFx0dGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xyXG5cdFx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcclxuXHJcblx0XHRcdFx0dGVbIDEgXSA9IGY7XHJcblx0XHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xyXG5cdFx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xyXG5cclxuXHRcdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcclxuXHRcdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XHJcblx0XHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHRcdHRlWyAwIF0gPSBjICogZTtcclxuXHRcdFx0XHR0ZVsgNCBdID0gLSBmO1xyXG5cdFx0XHRcdHRlWyA4IF0gPSBkICogZTtcclxuXHJcblx0XHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xyXG5cdFx0XHRcdHRlWyA1IF0gPSBhICogZTtcclxuXHRcdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XHJcblxyXG5cdFx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcclxuXHRcdFx0XHR0ZVsgNiBdID0gYiAqIGU7XHJcblx0XHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxhc3QgY29sdW1uXHJcblx0XHRcdHRlWyAzIF0gPSAwO1xyXG5cdFx0XHR0ZVsgNyBdID0gMDtcclxuXHRcdFx0dGVbIDExIF0gPSAwO1xyXG5cclxuXHRcdFx0Ly8gYm90dG9tIHJvd1xyXG5cdFx0XHR0ZVsgMTIgXSA9IDA7XHJcblx0XHRcdHRlWyAxMyBdID0gMDtcclxuXHRcdFx0dGVbIDE0IF0gPSAwO1xyXG5cdFx0XHR0ZVsgMTUgXSA9IDE7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHggPSBxLl94LCB5ID0gcS5feSwgeiA9IHEuX3osIHcgPSBxLl93O1xyXG5cdFx0XHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcclxuXHRcdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcblx0XHRcdHZhciB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xyXG5cdFx0XHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSAxIC0gKCB5eSArIHp6ICk7XHJcblx0XHRcdHRlWyA0IF0gPSB4eSAtIHd6O1xyXG5cdFx0XHR0ZVsgOCBdID0geHogKyB3eTtcclxuXHJcblx0XHRcdHRlWyAxIF0gPSB4eSArIHd6O1xyXG5cdFx0XHR0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xyXG5cdFx0XHR0ZVsgOSBdID0geXogLSB3eDtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSB4eiAtIHd5O1xyXG5cdFx0XHR0ZVsgNiBdID0geXogKyB3eDtcclxuXHRcdFx0dGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XHJcblxyXG5cdFx0XHQvLyBsYXN0IGNvbHVtblxyXG5cdFx0XHR0ZVsgMyBdID0gMDtcclxuXHRcdFx0dGVbIDcgXSA9IDA7XHJcblx0XHRcdHRlWyAxMSBdID0gMDtcclxuXHJcblx0XHRcdC8vIGJvdHRvbSByb3dcclxuXHRcdFx0dGVbIDEyIF0gPSAwO1xyXG5cdFx0XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHRcdHRlWyAxNCBdID0gMDtcclxuXHRcdFx0dGVbIDE1IF0gPSAxO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIHkgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgeiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHRcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXHJcblxyXG5cdFx0XHRcdFx0ei56ID0gMTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR6Lm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHgubGVuZ3RoU3EoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcclxuXHJcblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR6LnogKz0gMC4wMDAxO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR6Lm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0eC5ub3JtYWxpemUoKTtcclxuXHRcdFx0XHR5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xyXG5cclxuXHRcdFx0XHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xyXG5cdFx0XHRcdHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XHJcblx0XHRcdFx0dGVbIDIgXSA9IHguejsgdGVbIDYgXSA9IHkuejsgdGVbIDEwIF0gPSB6Lno7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEuZWxlbWVudHM7XHJcblx0XHRcdHZhciBiZSA9IGIuZWxlbWVudHM7XHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XHJcblx0XHRcdHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcclxuXHRcdFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcclxuXHRcdFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcclxuXHJcblx0XHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcclxuXHRcdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xyXG5cdFx0XHR2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xyXG5cdFx0XHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcclxuXHRcdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcclxuXHRcdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xyXG5cdFx0XHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xyXG5cdFx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XHJcblx0XHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHRcdHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xyXG5cdFx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcclxuXHJcblx0XHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHRcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XHJcblx0XHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xyXG5cdFx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xyXG5cdFx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xyXG5cdFx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcclxuXHRcdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHYxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xyXG5cdFx0XHRcdFx0djEueSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XHJcblx0XHRcdFx0XHR2MS56ID0gYXR0cmlidXRlLmdldFooIGkgKTtcclxuXHJcblx0XHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuc2V0WFlaKCBpLCB2MS54LCB2MS55LCB2MS56ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xyXG5cdFx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XHJcblx0XHRcdHZhciBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XHJcblx0XHRcdHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XHJcblxyXG5cdFx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG5cdFx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcclxuXHJcblx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0bjQxICogKFxyXG5cdFx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcclxuXHRcdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxyXG5cdFx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXHJcblx0XHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XHJcblx0XHRcdFx0KSArXHJcblx0XHRcdFx0bjQyICogKFxyXG5cdFx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcclxuXHRcdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xyXG5cdFx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXHJcblx0XHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxyXG5cdFx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXHJcblx0XHRcdFx0KSArXHJcblx0XHRcdFx0bjQzICogKFxyXG5cdFx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcclxuXHRcdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxyXG5cdFx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXHJcblx0XHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxyXG5cdFx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXHJcblx0XHRcdFx0KSArXHJcblx0XHRcdFx0bjQ0ICogKFxyXG5cdFx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcclxuXHRcdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxyXG5cdFx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXHJcblx0XHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXHJcblx0XHRcdFx0KVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdFx0dmFyIHRtcDtcclxuXHJcblx0XHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xyXG5cdFx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcclxuXHRcdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XHJcblxyXG5cdFx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xyXG5cdFx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xyXG5cdFx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dGVbIDEyIF0gPSB2Lng7XHJcblx0XHRcdHRlWyAxMyBdID0gdi55O1xyXG5cdFx0XHR0ZVsgMTQgXSA9IHYuejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcclxuXHJcblx0XHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxyXG5cdFx0XHRcdG1lID0gbS5lbGVtZW50cyxcclxuXHJcblx0XHRcdFx0bjExID0gbWVbIDAgXSwgbjIxID0gbWVbIDEgXSwgbjMxID0gbWVbIDIgXSwgbjQxID0gbWVbIDMgXSxcclxuXHRcdFx0XHRuMTIgPSBtZVsgNCBdLCBuMjIgPSBtZVsgNSBdLCBuMzIgPSBtZVsgNiBdLCBuNDIgPSBtZVsgNyBdLFxyXG5cdFx0XHRcdG4xMyA9IG1lWyA4IF0sIG4yMyA9IG1lWyA5IF0sIG4zMyA9IG1lWyAxMCBdLCBuNDMgPSBtZVsgMTEgXSxcclxuXHRcdFx0XHRuMTQgPSBtZVsgMTIgXSwgbjI0ID0gbWVbIDEzIF0sIG4zNCA9IG1lWyAxNCBdLCBuNDQgPSBtZVsgMTUgXSxcclxuXHJcblx0XHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxyXG5cdFx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcclxuXHRcdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXHJcblx0XHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xyXG5cclxuXHRcdFx0dmFyIGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcclxuXHJcblx0XHRcdGlmICggZGV0ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXg0OiAuZ2V0SW52ZXJzZSgpIGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcclxuXHJcblx0XHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBkZXRJbnYgPSAxIC8gZGV0O1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcclxuXHRcdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XHJcblx0XHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcclxuXHJcblx0XHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XHJcblx0XHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0XHR0ZVsgOCBdID0gdDEzICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgOSBdID0gKCBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQgKSAqIGRldEludjtcclxuXHRcdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgMTEgXSA9ICggbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcclxuXHRcdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XHJcblx0XHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xyXG5cclxuXHRcdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcclxuXHRcdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcclxuXHRcdFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XHJcblx0XHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcclxuXHRcdFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xyXG5cdFx0XHR2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRcdDEsIDAsIDAsIHgsXHJcblx0XHRcdFx0MCwgMSwgMCwgeSxcclxuXHRcdFx0XHQwLCAwLCAxLCB6LFxyXG5cdFx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdFx0MSwgMCwgMCwgMCxcclxuXHRcdFx0XHQwLCBjLCAtIHMsIDAsXHJcblx0XHRcdFx0MCwgcywgYywgMCxcclxuXHRcdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHRcdCAwLCAxLCAwLCAwLFxyXG5cdFx0XHRcdC0gcywgMCwgYywgMCxcclxuXHRcdFx0XHQgMCwgMCwgMCwgMVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0XHRjLCAtIHMsIDAsIDAsXHJcblx0XHRcdFx0cywgYywgMCwgMCxcclxuXHRcdFx0XHQwLCAwLCAxLCAwLFxyXG5cdFx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcclxuXHJcblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblx0XHRcdHZhciB0ID0gMSAtIGM7XHJcblx0XHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xyXG5cdFx0XHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcclxuXHJcblx0XHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0XHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXHJcblx0XHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxyXG5cdFx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcclxuXHRcdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0IHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdFx0eCwgMCwgMCwgMCxcclxuXHRcdFx0XHQwLCB5LCAwLCAwLFxyXG5cdFx0XHRcdDAsIDAsIHosIDAsXHJcblx0XHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWFrZVNoZWFyOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdFx0MSwgeSwgeiwgMCxcclxuXHRcdFx0XHR4LCAxLCB6LCAwLFxyXG5cdFx0XHRcdHgsIHksIDEsIDAsXHJcblx0XHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XHJcblx0XHRcdHRoaXMuc2NhbGUoIHNjYWxlICk7XHJcblx0XHRcdHRoaXMuc2V0UG9zaXRpb24oIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XHJcblx0XHRcdFx0dmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xyXG5cdFx0XHRcdHZhciBzeiA9IHZlY3Rvci5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXHJcblx0XHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcclxuXHRcdFx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uLnggPSB0ZVsgMTIgXTtcclxuXHRcdFx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XHJcblx0XHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xyXG5cclxuXHRcdFx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxyXG5cdFx0XHRcdG1hdHJpeC5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdHZhciBpbnZTWCA9IDEgLyBzeDtcclxuXHRcdFx0XHR2YXIgaW52U1kgPSAxIC8gc3k7XHJcblx0XHRcdFx0dmFyIGludlNaID0gMSAvIHN6O1xyXG5cclxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcclxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcclxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcclxuXHJcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XHJcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XHJcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XHJcblxyXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xyXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xyXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcclxuXHJcblx0XHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRzY2FsZS54ID0gc3g7XHJcblx0XHRcdFx0c2NhbGUueSA9IHN5O1xyXG5cdFx0XHRcdHNjYWxlLnogPSBzejtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGZhciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XHJcblx0XHRcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cclxuXHRcdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdFx0dmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcclxuXHRcdFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XHJcblx0XHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhO1x0dGVbIDEyIF0gPSAwO1xyXG5cdFx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XHJcblx0XHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XHJcblx0XHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRcdHZhciB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdFx0dmFyIGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xyXG5cdFx0XHR2YXIgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApICogdztcclxuXHRcdFx0dmFyIHkgPSAoIHRvcCArIGJvdHRvbSApICogaDtcclxuXHRcdFx0dmFyIHogPSAoIGZhciArIG5lYXIgKSAqIHA7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gMiAqIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XHJcblx0XHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7XHR0ZVsgMTMgXSA9IC0geTtcclxuXHRcdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xyXG5cdFx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDkgXSA9IHRlWyA5IF07XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBRdWF0ZXJuaW9uKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0XHR0aGlzLl95ID0geSB8fCAwO1xyXG5cdFx0dGhpcy5feiA9IHogfHwgMDtcclxuXHRcdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbiwge1xyXG5cclxuXHRcdHNsZXJwOiBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcW0uY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNsZXJwRmxhdDogZnVuY3Rpb24gKCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcclxuXHJcblx0XHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cclxuXHJcblx0XHRcdHZhciB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXHJcblx0XHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxyXG5cdFx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcclxuXHRcdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF0sXHJcblxyXG5cdFx0XHRcdHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcclxuXHRcdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXHJcblx0XHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxyXG5cdFx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcclxuXHJcblx0XHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcyA9IDEgLSB0LFxyXG5cclxuXHRcdFx0XHRcdGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXHJcblxyXG5cdFx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcclxuXHRcdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XHJcblxyXG5cdFx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XHJcblx0XHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcclxuXHRcdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcclxuXHJcblx0XHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcclxuXHRcdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB0RGlyID0gdCAqIGRpcjtcclxuXHJcblx0XHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XHJcblx0XHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XHJcblx0XHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XHJcblx0XHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XHJcblxyXG5cdFx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcclxuXHRcdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xyXG5cclxuXHRcdFx0XHRcdHgwICo9IGY7XHJcblx0XHRcdFx0XHR5MCAqPSBmO1xyXG5cdFx0XHRcdFx0ejAgKj0gZjtcclxuXHRcdFx0XHRcdHcwICo9IGY7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcclxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFF1YXRlcm5pb24ucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0eDoge1xyXG5cclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl94O1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0eToge1xyXG5cclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl95O1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IHZhbHVlO1xyXG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ejoge1xyXG5cclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feiA9IHZhbHVlO1xyXG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dzoge1xyXG5cclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl93O1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fdyA9IHZhbHVlO1xyXG5cdFx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHg7XHJcblx0XHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0XHR0aGlzLl96ID0gejtcclxuXHRcdFx0dGhpcy5fdyA9IHc7XHJcblxyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcclxuXHRcdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcclxuXHRcdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcclxuXHRcdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcclxuXHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHggPSBldWxlci5feCwgeSA9IGV1bGVyLl95LCB6ID0gZXVsZXIuX3osIG9yZGVyID0gZXVsZXIub3JkZXI7XHJcblxyXG5cdFx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXHJcblx0XHRcdC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXHJcblx0XHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cclxuXHJcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcztcclxuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luO1xyXG5cclxuXHRcdFx0dmFyIGMxID0gY29zKCB4IC8gMiApO1xyXG5cdFx0XHR2YXIgYzIgPSBjb3MoIHkgLyAyICk7XHJcblx0XHRcdHZhciBjMyA9IGNvcyggeiAvIDIgKTtcclxuXHJcblx0XHRcdHZhciBzMSA9IHNpbiggeCAvIDIgKTtcclxuXHRcdFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xyXG5cdFx0XHR2YXIgczMgPSBzaW4oIHogLyAyICk7XHJcblxyXG5cdFx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cclxuXHRcdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcclxuXHRcdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XHJcblx0XHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xyXG5cdFx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxyXG5cclxuXHRcdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxyXG5cdFx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXHJcblx0XHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXHJcblxyXG5cdFx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxyXG5cdFx0XHRcdHM7XHJcblxyXG5cdFx0XHRpZiAoIHRyYWNlID4gMCApIHtcclxuXHJcblx0XHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xyXG5cdFx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcclxuXHRcdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XHJcblx0XHRcdFx0dGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcclxuXHRcdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XHJcblx0XHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcclxuXHJcblx0XHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcclxuXHRcdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xyXG5cclxuXHRcdFx0XHR0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XHJcblx0XHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcclxuXHRcdFx0XHR0aGlzLl96ID0gMC4yNSAqIHM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciByO1xyXG5cclxuXHRcdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XHJcblxyXG5cdFx0XHRcdGlmICggciA8IEVQUyApIHtcclxuXHJcblx0XHRcdFx0XHRyID0gMDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0djEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHYxLng7XHJcblx0XHRcdFx0dGhpcy5feSA9IHYxLnk7XHJcblx0XHRcdFx0dGhpcy5feiA9IHYxLno7XHJcblx0XHRcdFx0dGhpcy5fdyA9IHI7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggKj0gLSAxO1xyXG5cdFx0XHR0aGlzLl95ICo9IC0gMTtcclxuXHRcdFx0dGhpcy5feiAqPSAtIDE7XHJcblxyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRpZiAoIGwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3cgPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bCA9IDEgLyBsO1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XHJcblx0XHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcclxuXHRcdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcclxuXHJcblx0XHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxyXG5cclxuXHRcdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XHJcblx0XHRcdHZhciBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcclxuXHRcdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcclxuXHRcdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcclxuXHRcdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcclxuXHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcclxuXHJcblx0XHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xyXG5cdFx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xyXG5cclxuXHRcdFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHRcdHZhciBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XHJcblxyXG5cdFx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xyXG5cdFx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xyXG5cdFx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xyXG5cdFx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xyXG5cclxuXHRcdFx0XHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fdyA9IHc7XHJcblx0XHRcdFx0dGhpcy5feCA9IHg7XHJcblx0XHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHRcdFx0dGhpcy5feiA9IHo7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xyXG5cdFx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcclxuXHRcdFx0XHR0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xyXG5cdFx0XHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxyXG5cdFx0XHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xyXG5cdFx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xyXG5cdFx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHRcdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xyXG5cclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cclxuXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcblx0ICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gVmVjdG9yMyggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4IHx8IDA7XHJcblx0XHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0XHR0aGlzLnogPSB6IHx8IDA7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc1ZlY3RvcjM6IHRydWUsXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB4O1xyXG5cdFx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLnkgPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueiA9IHNjYWxhcjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdFx0dGhpcy56ICs9IHYuejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggKz0gcztcclxuXHRcdFx0dGhpcy55ICs9IHM7XHJcblx0XHRcdHRoaXMueiArPSBzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdFx0dGhpcy56ID0gYS56ICsgYi56O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcclxuXHJcblx0XHRcdHRoaXMueCArPSB2LnggKiBzO1xyXG5cdFx0XHR0aGlzLnkgKz0gdi55ICogcztcclxuXHRcdFx0dGhpcy56ICs9IHYueiAqIHM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy54IC09IHYueDtcclxuXHRcdFx0dGhpcy55IC09IHYueTtcclxuXHRcdFx0dGhpcy56IC09IHYuejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggLT0gcztcclxuXHRcdFx0dGhpcy55IC09IHM7XHJcblx0XHRcdHRoaXMueiAtPSBzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdFx0dGhpcy56ID0gYS56IC0gYi56O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtdWx0aXBseTogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy54ICo9IHYueDtcclxuXHRcdFx0dGhpcy55ICo9IHYueTtcclxuXHRcdFx0dGhpcy56ICo9IHYuejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy56ICo9IHNjYWxhcjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBhLnggKiBiLng7XHJcblx0XHRcdHRoaXMueSA9IGEueSAqIGIueTtcclxuXHRcdFx0dGhpcy56ID0gYS56ICogYi56O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcclxuXHRcdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xyXG5cdFx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XHJcblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRcdHZhciB3ID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTtcclxuXHJcblx0XHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogdztcclxuXHRcdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xyXG5cdFx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0XHR2YXIgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XHJcblxyXG5cdFx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxyXG5cclxuXHRcdFx0dmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xyXG5cdFx0XHR2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XHJcblx0XHRcdHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcclxuXHRcdFx0dmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG5cdFx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XHJcblxyXG5cdFx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtIHF4ICsgaXkgKiAtIHF6IC0gaXogKiAtIHF5O1xyXG5cdFx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xyXG5cdFx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBwcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgbWF0cml4LmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHVucHJvamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxyXG5cdFx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cdFx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XHJcblx0XHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcclxuXHRcdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggLz0gdi54O1xyXG5cdFx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0XHR0aGlzLnogLz0gdi56O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xyXG5cdFx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIG1pbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBtYXggPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmbG9vcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0XHR0aGlzLnkgPSAtIHRoaXMueTtcclxuXHRcdFx0dGhpcy56ID0gLSB0aGlzLno7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cclxuXHJcblx0XHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB0aGlzLCB2ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0XHR2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcclxuXHJcblx0XHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xyXG5cdFx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuXHRcdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2NhbGFyID0gdmVjdG9yLmRvdCggdGhpcyApIC8gdmVjdG9yLmxlbmd0aFNxKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ZWN0b3IgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxyXG5cdFx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXHJcblxyXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApICk7XHJcblxyXG5cdFx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguYWNvcyggX01hdGguY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueSwgZHogPSB0aGlzLnogLSB2Lno7XHJcblxyXG5cdFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWFuaGF0dGFuRGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKSArIE1hdGguYWJzKCB0aGlzLnogLSB2LnogKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21TcGhlcmljYWw6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHRcdHZhciBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcy5waGkgKSAqIHMucmFkaXVzO1xyXG5cclxuXHRcdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHMudGhldGEgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5jb3MoIHMucGhpICkgKiBzLnJhZGl1cztcclxuXHRcdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHMudGhldGEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBjLnJhZGl1cyAqIE1hdGguc2luKCBjLnRoZXRhICk7XHJcblx0XHRcdHRoaXMueSA9IGMueTtcclxuXHRcdFx0dGhpcy56ID0gYy5yYWRpdXMgKiBNYXRoLmNvcyggYy50aGV0YSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRcdHRoaXMueCA9IGVbIDEyIF07XHJcblx0XHRcdHRoaXMueSA9IGVbIDEzIF07XHJcblx0XHRcdHRoaXMueiA9IGVbIDE0IF07XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0dmFyIHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XHJcblx0XHRcdHZhciBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdHRoaXMueCA9IHN4O1xyXG5cdFx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdFx0dGhpcy56ID0gc3o7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggbSwgaW5kZXggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcclxuXHRcdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XHJcblx0XHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTWF0cml4MygpIHtcclxuXHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW1xyXG5cclxuXHRcdFx0MSwgMCwgMCxcclxuXHRcdFx0MCwgMSwgMCxcclxuXHRcdFx0MCwgMCwgMVxyXG5cclxuXHRcdF07XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggTWF0cml4My5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc01hdHJpeDM6IHRydWUsXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDEgXSA9IG4yMTsgdGVbIDIgXSA9IG4zMTtcclxuXHRcdFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcclxuXHRcdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0XHQxLCAwLCAwLFxyXG5cdFx0XHRcdDAsIDEsIDAsXHJcblx0XHRcdFx0MCwgMCwgMVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07XHJcblx0XHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XHJcblx0XHRcdHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTsgdGVbIDggXSA9IG1lWyA4IF07XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21NYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRcdG1lWyAwIF0sIG1lWyA0IF0sIG1lWyA4IF0sXHJcblx0XHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcclxuXHRcdFx0XHRtZVsgMiBdLCBtZVsgNiBdLCBtZVsgMTAgXVxyXG5cclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0djEueCA9IGF0dHJpYnV0ZS5nZXRYKCBpICk7XHJcblx0XHRcdFx0XHR2MS55ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcclxuXHRcdFx0XHRcdHYxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xyXG5cclxuXHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYXR0cmlidXRlO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgYmUgPSBiLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyAzIF0sIGExMyA9IGFlWyA2IF07XHJcblx0XHRcdHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xyXG5cdFx0XHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDUgXSwgYTMzID0gYWVbIDggXTtcclxuXHJcblx0XHRcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xyXG5cdFx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcclxuXHRcdFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA1IF0sIGIzMyA9IGJlWyA4IF07XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxO1xyXG5cdFx0XHR0ZVsgMyBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyO1xyXG5cdFx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xyXG5cclxuXHRcdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcclxuXHRcdFx0dGVbIDQgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjtcclxuXHRcdFx0dGVbIDcgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMztcclxuXHJcblx0XHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XHJcblx0XHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XHJcblx0XHRcdHRlWyA4IF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdFx0dGVbIDAgXSAqPSBzOyB0ZVsgMyBdICo9IHM7IHRlWyA2IF0gKj0gcztcclxuXHRcdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcclxuXHRcdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcclxuXHRcdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxyXG5cdFx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XHJcblxyXG5cdFx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25EZWdlbmVyYXRlICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggJiYgbWF0cml4LmlzTWF0cml4NCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIG5vIGxvbmdlciB0YWtlcyBhIE1hdHJpeDQgYXJndW1lbnQuXCIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cyxcclxuXHRcdFx0XHR0ZSA9IHRoaXMuZWxlbWVudHMsXHJcblxyXG5cdFx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXHJcblx0XHRcdFx0bjEyID0gbWVbIDMgXSwgbjIyID0gbWVbIDQgXSwgbjMyID0gbWVbIDUgXSxcclxuXHRcdFx0XHRuMTMgPSBtZVsgNiBdLCBuMjMgPSBtZVsgNyBdLCBuMzMgPSBtZVsgOCBdLFxyXG5cclxuXHRcdFx0XHR0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXHJcblx0XHRcdFx0dDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxyXG5cdFx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcclxuXHJcblx0XHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xyXG5cclxuXHRcdFx0aWYgKCBkZXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtc2cgPSBcIlRIUkVFLk1hdHJpeDM6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XHJcblxyXG5cdFx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgMSBdID0gKCBuMzEgKiBuMjMgLSBuMzMgKiBuMjEgKSAqIGRldEludjtcclxuXHRcdFx0dGVbIDIgXSA9ICggbjMyICogbjIxIC0gbjMxICogbjIyICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0XHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcclxuXHRcdFx0dGVbIDUgXSA9ICggbjMxICogbjEyIC0gbjMyICogbjExICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0XHR0ZVsgNiBdID0gdDEzICogZGV0SW52O1xyXG5cdFx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcclxuXHRcdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xyXG5cdFx0XHR0bXAgPSBtWyAyIF07IG1bIDIgXSA9IG1bIDYgXTsgbVsgNiBdID0gdG1wO1xyXG5cdFx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XHJcblxyXG5cdFx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHRyWyAwIF0gPSBtWyAwIF07XHJcblx0XHRcdHJbIDEgXSA9IG1bIDMgXTtcclxuXHRcdFx0clsgMiBdID0gbVsgNiBdO1xyXG5cdFx0XHRyWyAzIF0gPSBtWyAxIF07XHJcblx0XHRcdHJbIDQgXSA9IG1bIDQgXTtcclxuXHRcdFx0clsgNSBdID0gbVsgNyBdO1xyXG5cdFx0XHRyWyA2IF0gPSBtWyAyIF07XHJcblx0XHRcdHJbIDcgXSA9IG1bIDUgXTtcclxuXHRcdFx0clsgOCBdID0gbVsgOCBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRVdlRyYW5zZm9ybTogZnVuY3Rpb24gKCB0eCwgdHksIHN4LCBzeSwgcm90YXRpb24sIGN4LCBjeSApIHtcclxuXHJcblx0XHRcdHZhciBjID0gTWF0aC5jb3MoIHJvdGF0aW9uICk7XHJcblx0XHRcdHZhciBzID0gTWF0aC5zaW4oIHJvdGF0aW9uICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldChcclxuXHRcdFx0XHRzeCAqIGMsIHN4ICogcywgLSBzeCAqICggYyAqIGN4ICsgcyAqIGN5ICkgKyBjeCArIHR4LFxyXG5cdFx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxyXG5cdFx0XHRcdDAsIDAsIDFcclxuXHRcdFx0KTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNjYWxlOiBmdW5jdGlvbiAoIHN4LCBzeSApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHR0ZVsgMCBdICo9IHN4OyB0ZVsgMyBdICo9IHN4OyB0ZVsgNiBdICo9IHN4O1xyXG5cdFx0XHR0ZVsgMSBdICo9IHN5OyB0ZVsgNCBdICo9IHN5OyB0ZVsgNyBdICo9IHN5O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyb3RhdGU6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApO1xyXG5cdFx0XHR2YXIgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdHZhciBhMTEgPSB0ZVsgMCBdLCBhMTIgPSB0ZVsgMyBdLCBhMTMgPSB0ZVsgNiBdO1xyXG5cdFx0XHR2YXIgYTIxID0gdGVbIDEgXSwgYTIyID0gdGVbIDQgXSwgYTIzID0gdGVbIDcgXTtcclxuXHJcblx0XHRcdHRlWyAwIF0gPSBjICogYTExICsgcyAqIGEyMTtcclxuXHRcdFx0dGVbIDMgXSA9IGMgKiBhMTIgKyBzICogYTIyO1xyXG5cdFx0XHR0ZVsgNiBdID0gYyAqIGExMyArIHMgKiBhMjM7XHJcblxyXG5cdFx0XHR0ZVsgMSBdID0gLSBzICogYTExICsgYyAqIGEyMTtcclxuXHRcdFx0dGVbIDQgXSA9IC0gcyAqIGExMiArIGMgKiBhMjI7XHJcblx0XHRcdHRlWyA3IF0gPSAtIHMgKiBhMTMgKyBjICogYTIzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdHgsIHR5ICkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdHRlWyAwIF0gKz0gdHggKiB0ZVsgMiBdOyB0ZVsgMyBdICs9IHR4ICogdGVbIDUgXTsgdGVbIDYgXSArPSB0eCAqIHRlWyA4IF07XHJcblx0XHRcdHRlWyAxIF0gKz0gdHkgKiB0ZVsgMiBdOyB0ZVsgNCBdICs9IHR5ICogdGVbIDUgXTsgdGVbIDcgXSArPSB0eSAqIHRlWyA4IF07XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcclxuXHJcblx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuXHQgKi9cclxuXHJcblx0dmFyIHRleHR1cmVJZCA9IDA7XHJcblxyXG5cdGZ1bmN0aW9uIFRleHR1cmUoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogdGV4dHVyZUlkICsrIH0gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0XHR0aGlzLmltYWdlID0gaW1hZ2UgIT09IHVuZGVmaW5lZCA/IGltYWdlIDogVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xyXG5cdFx0dGhpcy5taXBtYXBzID0gW107XHJcblxyXG5cdFx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xyXG5cclxuXHRcdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cdFx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcclxuXHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XHJcblxyXG5cdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IFJHQkFGb3JtYXQ7XHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVW5zaWduZWRCeXRlVHlwZTtcclxuXHJcblx0XHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcblx0XHR0aGlzLnJlcGVhdCA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblx0XHR0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XHJcblx0XHR0aGlzLnJvdGF0aW9uID0gMDtcclxuXHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcclxuXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5mbGlwWSA9IHRydWU7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7XHQvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcclxuXHJcblx0XHQvLyBWYWx1ZXMgb2YgZW5jb2RpbmcgIT09IFRIUkVFLkxpbmVhckVuY29kaW5nIG9ubHkgc3VwcG9ydGVkIG9uIG1hcCwgZW52TWFwIGFuZCBlbWlzc2l2ZU1hcC5cclxuXHRcdC8vXHJcblx0XHQvLyBBbHNvIGNoYW5naW5nIHRoZSBlbmNvZGluZyBhZnRlciBhbHJlYWR5IHVzZWQgYnkgYSBNYXRlcmlhbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIE1hdGVyaWFsXHJcblx0XHQvLyB1cGRhdGUuICBZb3UgbmVlZCB0byBleHBsaWNpdGx5IGNhbGwgTWF0ZXJpYWwubmVlZHNVcGRhdGUgdG8gdHJpZ2dlciBpdCB0byByZWNvbXBpbGUuXHJcblx0XHR0aGlzLmVuY29kaW5nID0gZW5jb2RpbmcgIT09IHVuZGVmaW5lZCA/IGVuY29kaW5nIDogTGluZWFyRW5jb2Rpbmc7XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHRcdHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdFRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcclxuXHRUZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcclxuXHJcblx0VGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogVGV4dHVyZSxcclxuXHJcblx0XHRpc1RleHR1cmU6IHRydWUsXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0XHR0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xyXG5cdFx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XHJcblxyXG5cdFx0XHR0aGlzLndyYXBTID0gc291cmNlLndyYXBTO1xyXG5cdFx0XHR0aGlzLndyYXBUID0gc291cmNlLndyYXBUO1xyXG5cclxuXHRcdFx0dGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xyXG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XHJcblxyXG5cdFx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcclxuXHJcblx0XHRcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcclxuXHRcdFx0dGhpcy50eXBlID0gc291cmNlLnR5cGU7XHJcblxyXG5cdFx0XHR0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XHJcblx0XHRcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcclxuXHRcdFx0dGhpcy5jZW50ZXIuY29weSggc291cmNlLmNlbnRlciApO1xyXG5cdFx0XHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcclxuXHJcblx0XHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcclxuXHRcdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XHJcblx0XHRcdHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XHJcblx0XHRcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcclxuXHRcdFx0dGhpcy5lbmNvZGluZyA9IHNvdXJjZS5lbmNvZGluZztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0XHR2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XHJcblxyXG5cdFx0XHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldERhdGFVUkwoIGltYWdlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2FudmFzO1xyXG5cclxuXHRcdFx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FudmFzID0gaW1hZ2U7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XHJcblx0XHRcdFx0XHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcclxuXHRcdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggY2FudmFzLndpZHRoID4gMjA0OCB8fCBjYW52YXMuaGVpZ2h0ID4gMjA0OCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG91dHB1dCA9IHtcclxuXHRcdFx0XHRtZXRhZGF0YToge1xyXG5cdFx0XHRcdFx0dmVyc2lvbjogNC41LFxyXG5cdFx0XHRcdFx0dHlwZTogJ1RleHR1cmUnLFxyXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0dXVpZDogdGhpcy51dWlkLFxyXG5cdFx0XHRcdG5hbWU6IHRoaXMubmFtZSxcclxuXHJcblx0XHRcdFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxyXG5cclxuXHRcdFx0XHRyZXBlYXQ6IFsgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSBdLFxyXG5cdFx0XHRcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXHJcblx0XHRcdFx0Y2VudGVyOiBbIHRoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnkgXSxcclxuXHRcdFx0XHRyb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuXHJcblx0XHRcdFx0d3JhcDogWyB0aGlzLndyYXBTLCB0aGlzLndyYXBUIF0sXHJcblxyXG5cdFx0XHRcdG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXHJcblx0XHRcdFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcclxuXHRcdFx0XHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHksXHJcblxyXG5cdFx0XHRcdGZsaXBZOiB0aGlzLmZsaXBZXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gVE9ETzogTW92ZSB0byBUSFJFRS5JbWFnZVxyXG5cclxuXHRcdFx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpbWFnZS51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSB7XHJcblx0XHRcdFx0XHRcdHV1aWQ6IGltYWdlLnV1aWQsXHJcblx0XHRcdFx0XHRcdHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAhIGlzUm9vdE9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5tYXBwaW5nICE9PSBVVk1hcHBpbmcgKSByZXR1cm47XHJcblxyXG5cdFx0XHR1di5hcHBseU1hdHJpeDMoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnggKSAlIDIgKSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB1di55IDwgMCB8fCB1di55ID4gMSApIHtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxyXG5cclxuXHRcdFx0XHRcdFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcclxuXHJcblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di55ICkgJSAyICkgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHV2LnkgPSBNYXRoLmNlaWwoIHV2LnkgKSAtIHV2Lnk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5mbGlwWSApIHtcclxuXHJcblx0XHRcdFx0dXYueSA9IDEgLSB1di55O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIFRleHR1cmUucHJvdG90eXBlLCBcIm5lZWRzVXBkYXRlXCIsIHtcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG5cdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuXHQgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBWZWN0b3I0KCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHggfHwgMDtcclxuXHRcdHRoaXMueSA9IHkgfHwgMDtcclxuXHRcdHRoaXMueiA9IHogfHwgMDtcclxuXHRcdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBWZWN0b3I0LnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGlzVmVjdG9yNDogdHJ1ZSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHg7XHJcblx0XHRcdHRoaXMueSA9IHk7XHJcblx0XHRcdHRoaXMueiA9IHo7XHJcblx0XHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueSA9IHNjYWxhcjtcclxuXHRcdFx0dGhpcy56ID0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLncgPSBzY2FsYXI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFc6IGZ1bmN0aW9uICggdyApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAzOiB0aGlzLncgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG5cdFx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcclxuXHRcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cdFx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMueCArPSB2Lng7XHJcblx0XHRcdHRoaXMueSArPSB2Lnk7XHJcblx0XHRcdHRoaXMueiArPSB2Lno7XHJcblx0XHRcdHRoaXMudyArPSB2Lnc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICs9IHM7XHJcblx0XHRcdHRoaXMueSArPSBzO1xyXG5cdFx0XHR0aGlzLnogKz0gcztcclxuXHRcdFx0dGhpcy53ICs9IHM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdFx0dGhpcy55ID0gYS55ICsgYi55O1xyXG5cdFx0XHR0aGlzLnogPSBhLnogKyBiLno7XHJcblx0XHRcdHRoaXMudyA9IGEudyArIGIudztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggKz0gdi54ICogcztcclxuXHRcdFx0dGhpcy55ICs9IHYueSAqIHM7XHJcblx0XHRcdHRoaXMueiArPSB2LnogKiBzO1xyXG5cdFx0XHR0aGlzLncgKz0gdi53ICogcztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0XHR0aGlzLnkgLT0gdi55O1xyXG5cdFx0XHR0aGlzLnogLT0gdi56O1xyXG5cdFx0XHR0aGlzLncgLT0gdi53O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHRcdHRoaXMueCAtPSBzO1xyXG5cdFx0XHR0aGlzLnkgLT0gcztcclxuXHRcdFx0dGhpcy56IC09IHM7XHJcblx0XHRcdHRoaXMudyAtPSBzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHRcdHRoaXMueSA9IGEueSAtIGIueTtcclxuXHRcdFx0dGhpcy56ID0gYS56IC0gYi56O1xyXG5cdFx0XHR0aGlzLncgPSBhLncgLSBiLnc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMudyAqPSBzY2FsYXI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XHJcblx0XHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xyXG5cdFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcclxuXHRcdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKiB3O1xyXG5cdFx0XHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0XHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcclxuXHJcblx0XHRcdHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XHJcblxyXG5cdFx0XHRpZiAoIHMgPCAwLjAwMDEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueCA9IDE7XHJcblx0XHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0XHR0aGlzLnogPSAwO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gcS54IC8gcztcclxuXHRcdFx0XHR0aGlzLnkgPSBxLnkgLyBzO1xyXG5cdFx0XHRcdHRoaXMueiA9IHEueiAvIHM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXHJcblxyXG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxyXG5cdFx0XHRcdGVwc2lsb24gPSAwLjAxLFx0XHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xyXG5cdFx0XHRcdGVwc2lsb24yID0gMC4xLFx0XHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xyXG5cclxuXHRcdFx0XHR0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXHJcblx0XHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcclxuXHRcdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcclxuXHJcblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyIC0gbTIxICkgPCBlcHNpbG9uICkgJiZcclxuXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKSAmJlxyXG5cdFx0XHQgICAgICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xyXG5cclxuXHRcdFx0XHQvLyBzaW5ndWxhcml0eSBmb3VuZFxyXG5cdFx0XHRcdC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcclxuXHRcdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXHJcblxyXG5cdFx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmXHJcblx0XHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiZcclxuXHRcdFx0XHQgICAgICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKSAmJlxyXG5cdFx0XHRcdCAgICAgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcclxuXHJcblx0XHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXHJcblxyXG5cdFx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcclxuXHJcblx0XHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xyXG5cdFx0XHRcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcclxuXHRcdFx0XHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XHJcblx0XHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XHJcblx0XHRcdFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XHJcblx0XHRcdFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XHJcblxyXG5cdFx0XHRcdGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHh4IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHggPSAwO1xyXG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcclxuXHRcdFx0XHRcdFx0eSA9IHh5IC8geDtcclxuXHRcdFx0XHRcdFx0eiA9IHh6IC8geDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcclxuXHRcdFx0XHRcdFx0eSA9IDA7XHJcblx0XHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0eSA9IE1hdGguc3FydCggeXkgKTtcclxuXHRcdFx0XHRcdFx0eCA9IHh5IC8geTtcclxuXHRcdFx0XHRcdFx0eiA9IHl6IC8geTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xyXG5cclxuXHRcdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHRcdHogPSAwO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xyXG5cdFx0XHRcdFx0XHR4ID0geHogLyB6O1xyXG5cdFx0XHRcdFx0XHR5ID0geXogLyB6O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XHJcblxyXG5cdFx0XHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxICkgK1xyXG5cdFx0XHQgICAgICAgICAgICAgICAgICAgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIHMgKSA8IDAuMDAxICkgcyA9IDE7XHJcblxyXG5cdFx0XHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXHJcblx0XHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxyXG5cclxuXHRcdFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xyXG5cdFx0XHR0aGlzLncgPSBNYXRoLm1pbiggdGhpcy53LCB2LncgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xyXG5cdFx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xyXG5cdFx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcclxuXHRcdFx0dGhpcy53ID0gTWF0aC5tYXgoIG1pbi53LCBNYXRoLm1pbiggbWF4LncsIHRoaXMudyApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG1pbiA9IG5ldyBWZWN0b3I0KCk7XHJcblx0XHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yNCgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cdFx0XHR0aGlzLncgPSBNYXRoLmZsb29yKCB0aGlzLncgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcclxuXHRcdFx0dGhpcy53ID0gTWF0aC5jZWlsKCB0aGlzLncgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XHJcblx0XHRcdHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcclxuXHRcdFx0dGhpcy53ID0gKCB0aGlzLncgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMudyApIDogTWF0aC5mbG9vciggdGhpcy53ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gLSB0aGlzLng7XHJcblx0XHRcdHRoaXMueSA9IC0gdGhpcy55O1xyXG5cdFx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHRcdFx0dGhpcy53ID0gLSB0aGlzLnc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHRcdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcclxuXHRcdFx0dGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0XHR0aGlzLncgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcclxuXHJcblx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xyXG5cdFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcclxuXHRcdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XHJcblx0XHRcdHRoaXMudyA9IGF0dHJpYnV0ZS5nZXRXKCBpbmRleCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgTWFyaXVzIEtpbnRlbCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9raW50ZWxcclxuXHQgKi9cclxuXHJcblx0LypcclxuXHQgSW4gb3B0aW9ucywgd2UgY2FuIHNwZWNpZnk6XHJcblx0ICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxyXG5cdCAqIGRlcHRoQnVmZmVyL3N0ZW5jaWxCdWZmZXI6IEJvb2xlYW5zIHRvIGluZGljYXRlIGlmIHdlIHNob3VsZCBnZW5lcmF0ZSB0aGVzZSBidWZmZXJzXHJcblx0Ki9cclxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR0aGlzLnNjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdGlmICggb3B0aW9ucy5taW5GaWx0ZXIgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcgKTtcclxuXHJcblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XHJcblx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XHJcblx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IG9wdGlvbnMuZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoVGV4dHVyZSA6IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0V2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFdlYkdMUmVuZGVyVGFyZ2V0LFxyXG5cclxuXHRcdGlzV2ViR0xSZW5kZXJUYXJnZXQ6IHRydWUsXHJcblxyXG5cdFx0c2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy52aWV3cG9ydC5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHRcdFx0dGhpcy5zY2lzc29yLnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcclxuXHRcdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcclxuXHJcblx0XHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xyXG5cdFx0XHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcclxuXHRcdFx0dGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldEN1YmUoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0V2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xyXG5cclxuXHRcdHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XHJcblx0XHR0aGlzLmFjdGl2ZU1pcE1hcExldmVsID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XHJcblx0V2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcclxuXHJcblx0V2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IHRydWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIERhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xyXG5cclxuXHRcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xyXG5cclxuXHRcdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcclxuXHJcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcclxuXHRcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHR0aGlzLmZsaXBZID0gZmFsc2U7XHJcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XHJcblxyXG5cdH1cclxuXHJcblx0RGF0YVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcclxuXHREYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYXRhVGV4dHVyZTtcclxuXHJcblx0RGF0YVRleHR1cmUucHJvdG90eXBlLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBDdWJlVGV4dHVyZSggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xyXG5cclxuXHRcdGltYWdlcyA9IGltYWdlcyAhPT0gdW5kZWZpbmVkID8gaW1hZ2VzIDogW107XHJcblx0XHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcclxuXHJcblx0XHRUZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xyXG5cclxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRDdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cdEN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmVUZXh0dXJlO1xyXG5cclxuXHRDdWJlVGV4dHVyZS5wcm90b3R5cGUuaXNDdWJlVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQ3ViZVRleHR1cmUucHJvdG90eXBlLCAnaW1hZ2VzJywge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuaW1hZ2U7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmltYWdlID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKlxyXG5cdCAqIFVuaWZvcm1zIG9mIGEgcHJvZ3JhbS5cclxuXHQgKiBUaG9zZSBmb3JtIGEgdHJlZSBzdHJ1Y3R1cmUgd2l0aCBhIHNwZWNpYWwgdG9wLWxldmVsIGNvbnRhaW5lciBmb3IgdGhlIHJvb3QsXHJcblx0ICogd2hpY2ggeW91IGdldCBieSBjYWxsaW5nICduZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICknLlxyXG5cdCAqXHJcblx0ICpcclxuXHQgKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcclxuXHQgKlxyXG5cdCAqIC5zZXEgLSBhcnJheSBvZiBuZXN0ZWQgdW5pZm9ybXNcclxuXHQgKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcclxuXHQgKlxyXG5cdCAqXHJcblx0ICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxyXG5cdCAqXHJcblx0ICogLnNldFZhbHVlKCBnbCwgdmFsdWUsIFtyZW5kZXJlcl0gKVxyXG5cdCAqXHJcblx0ICogXHRcdHVwbG9hZHMgYSB1bmlmb3JtIHZhbHVlKHMpXHJcblx0ICogIFx0dGhlICdyZW5kZXJlcicgcGFyYW1ldGVyIGlzIG5lZWRlZCBmb3Igc2FtcGxlciB1bmlmb3Jtc1xyXG5cdCAqXHJcblx0ICpcclxuXHQgKiBTdGF0aWMgbWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAocmVuZGVyZXIgZmFjdG9yaXphdGlvbnMpOlxyXG5cdCAqXHJcblx0ICogLnVwbG9hZCggZ2wsIHNlcSwgdmFsdWVzLCByZW5kZXJlciApXHJcblx0ICpcclxuXHQgKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcclxuXHQgKlxyXG5cdCAqIC5zZXFXaXRoVmFsdWUoIHNlcSwgdmFsdWVzICkgOiBmaWx0ZXJlZFNlcVxyXG5cdCAqXHJcblx0ICogXHRcdGZpbHRlcnMgJ3NlcScgZW50cmllcyB3aXRoIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdmFsdWVzXHJcblx0ICpcclxuXHQgKlxyXG5cdCAqIE1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHJlbmRlcmVyIGZhY3Rvcml6YXRpb25zKTpcclxuXHQgKlxyXG5cdCAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlIClcclxuXHQgKlxyXG5cdCAqIFx0XHRzZXRzIHVuaWZvcm0gd2l0aCAgbmFtZSAnbmFtZScgdG8gJ3ZhbHVlJ1xyXG5cdCAqXHJcblx0ICogLnNldCggZ2wsIG9iaiwgcHJvcCApXHJcblx0ICpcclxuXHQgKiBcdFx0c2V0cyB1bmlmb3JtIGZyb20gb2JqZWN0IGFuZCBwcm9wZXJ0eSB3aXRoIHNhbWUgbmFtZSB0aGFuIHVuaWZvcm1cclxuXHQgKlxyXG5cdCAqIC5zZXRPcHRpb25hbCggZ2wsIG9iaiwgcHJvcCApXHJcblx0ICpcclxuXHQgKiBcdFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XHJcblx0ICpcclxuXHQgKi9cclxuXHJcblx0dmFyIGVtcHR5VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XHJcblx0dmFyIGVtcHR5Q3ViZVRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcclxuXHJcblx0Ly8gLS0tIEJhc2UgZm9yIGlubmVyIG5vZGVzIChpbmNsdWRpbmcgdGhlIHJvb3QpIC0tLVxyXG5cclxuXHRmdW5jdGlvbiBVbmlmb3JtQ29udGFpbmVyKCkge1xyXG5cclxuXHRcdHRoaXMuc2VxID0gW107XHJcblx0XHR0aGlzLm1hcCA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIC0tLSBVdGlsaXRpZXMgLS0tXHJcblxyXG5cdC8vIEFycmF5IENhY2hlcyAocHJvdmlkZSB0eXBlZCBhcnJheXMgZm9yIHRlbXBvcmFyeSBieSBzaXplKVxyXG5cclxuXHR2YXIgYXJyYXlDYWNoZUYzMiA9IFtdO1xyXG5cdHZhciBhcnJheUNhY2hlSTMyID0gW107XHJcblxyXG5cdC8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xyXG5cclxuXHR2YXIgbWF0NGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcclxuXHR2YXIgbWF0M2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xyXG5cclxuXHQvLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcclxuXHJcblx0ZnVuY3Rpb24gZmxhdHRlbiggYXJyYXksIG5CbG9ja3MsIGJsb2NrU2l6ZSApIHtcclxuXHJcblx0XHR2YXIgZmlyc3RFbGVtID0gYXJyYXlbIDAgXTtcclxuXHJcblx0XHRpZiAoIGZpcnN0RWxlbSA8PSAwIHx8IGZpcnN0RWxlbSA+IDAgKSByZXR1cm4gYXJyYXk7XHJcblx0XHQvLyB1bm9wdGltaXplZDogISBpc05hTiggZmlyc3RFbGVtIClcclxuXHRcdC8vIHNlZSBodHRwOi8vamFja3NvbmR1bnN0YW4uY29tL2FydGljbGVzLzk4M1xyXG5cclxuXHRcdHZhciBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZSxcclxuXHRcdFx0ciA9IGFycmF5Q2FjaGVGMzJbIG4gXTtcclxuXHJcblx0XHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHIgPSBuZXcgRmxvYXQzMkFycmF5KCBuICk7XHJcblx0XHRcdGFycmF5Q2FjaGVGMzJbIG4gXSA9IHI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbkJsb2NrcyAhPT0gMCApIHtcclxuXHJcblx0XHRcdGZpcnN0RWxlbS50b0FycmF5KCByLCAwICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIG9mZnNldCA9IDA7IGkgIT09IG5CbG9ja3M7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdG9mZnNldCArPSBibG9ja1NpemU7XHJcblx0XHRcdFx0YXJyYXlbIGkgXS50b0FycmF5KCByLCBvZmZzZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHI7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cclxuXHJcblx0ZnVuY3Rpb24gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKSB7XHJcblxyXG5cdFx0dmFyIHIgPSBhcnJheUNhY2hlSTMyWyBuIF07XHJcblxyXG5cdFx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyID0gbmV3IEludDMyQXJyYXkoIG4gKTtcclxuXHRcdFx0YXJyYXlDYWNoZUkzMlsgbiBdID0gcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpIClcclxuXHRcdFx0clsgaSBdID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xyXG5cclxuXHRcdHJldHVybiByO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIC0tLSBTZXR0ZXJzIC0tLVxyXG5cclxuXHQvLyBOb3RlOiBEZWZpbmluZyB0aGVzZSBtZXRob2RzIGV4dGVybmFsbHksIGJlY2F1c2UgdGhleSBjb21lIGluIGEgYnVuY2hcclxuXHQvLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxyXG5cclxuXHQvLyBTaW5nbGUgc2NhbGFyXHJcblxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlMWYoIGdsLCB2ICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0xZiggdGhpcy5hZGRyLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWUxaSggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTaW5nbGUgZmxvYXQgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuVmVjdG9yTilcclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWUyZnYoIGdsLCB2ICkge1xyXG5cclxuXHRcdGlmICggdi54ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTJmKCB0aGlzLmFkZHIsIHYueCwgdi55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlM2Z2KCBnbCwgdiApIHtcclxuXHJcblx0XHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybTNmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB2LnIgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZTRmdiggZ2wsIHYgKSB7XHJcblxyXG5cdFx0aWYgKCB2LnggPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm00ZnYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQgZ2wudW5pZm9ybTRmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgTWF0cml4TilcclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWUyZm0oIGdsLCB2ICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYuZWxlbWVudHMgfHwgdiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlM2ZtKCBnbCwgdiApIHtcclxuXHJcblx0XHRpZiAoIHYuZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWF0M2FycmF5LnNldCggdi5lbGVtZW50cyApO1xyXG5cdFx0XHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCBtYXQzYXJyYXkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWU0Zm0oIGdsLCB2ICkge1xyXG5cclxuXHRcdGlmICggdi5lbGVtZW50cyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtYXQ0YXJyYXkuc2V0KCB2LmVsZW1lbnRzICk7XHJcblx0XHRcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDRhcnJheSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBTaW5nbGUgdGV4dHVyZSAoMkQgLyBDdWJlKVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZVQxKCBnbCwgdiwgcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0dmFyIHVuaXQgPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XHJcblx0XHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xyXG5cdFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2IHx8IGVtcHR5VGV4dHVyZSwgdW5pdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlVDYoIGdsLCB2LCByZW5kZXJlciApIHtcclxuXHJcblx0XHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcclxuXHRcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XHJcblx0XHRyZW5kZXJlci5zZXRUZXh0dXJlQ3ViZSggdiB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gSW50ZWdlciAvIEJvb2xlYW4gdmVjdG9ycyBvciBhcnJheXMgdGhlcmVvZiAoYWx3YXlzIGZsYXQgYXJyYXlzKVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZTJpdiggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTJpdiggdGhpcy5hZGRyLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWUzaXYoIGdsLCB2ICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0zaXYoIHRoaXMuYWRkciwgdiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlNGl2KCBnbCwgdiApIHtcclxuXHJcblx0XHRnbC51bmlmb3JtNGl2KCB0aGlzLmFkZHIsIHYgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciB0aGUgc2luZ3VsYXIgY2FzZVxyXG5cclxuXHRmdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlciggdHlwZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCB0eXBlICkge1xyXG5cclxuXHRcdFx0Y2FzZSAweDE0MDY6IHJldHVybiBzZXRWYWx1ZTFmOyAvLyBGTE9BVFxyXG5cdFx0XHRjYXNlIDB4OGI1MDogcmV0dXJuIHNldFZhbHVlMmZ2OyAvLyBfVkVDMlxyXG5cdFx0XHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlM2Z2OyAvLyBfVkVDM1xyXG5cdFx0XHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlNGZ2OyAvLyBfVkVDNFxyXG5cclxuXHRcdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZTJmbTsgLy8gX01BVDJcclxuXHRcdFx0Y2FzZSAweDhiNWI6IHJldHVybiBzZXRWYWx1ZTNmbTsgLy8gX01BVDNcclxuXHRcdFx0Y2FzZSAweDhiNWM6IHJldHVybiBzZXRWYWx1ZTRmbTsgLy8gX01BVDRcclxuXHJcblx0XHRcdGNhc2UgMHg4YjVlOiBjYXNlIDB4OGQ2NjogcmV0dXJuIHNldFZhbHVlVDE7IC8vIFNBTVBMRVJfMkQsIFNBTVBMRVJfRVhURVJOQUxfT0VTXHJcblx0XHRcdGNhc2UgMHg4YjYwOiByZXR1cm4gc2V0VmFsdWVUNjsgLy8gU0FNUExFUl9DVUJFXHJcblxyXG5cdFx0XHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZTFpOyAvLyBJTlQsIEJPT0xcclxuXHRcdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXHJcblx0XHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xyXG5cdFx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQXJyYXkgb2Ygc2NhbGFyc1xyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZTFmdiggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTFmdiggdGhpcy5hZGRyLCB2ICk7XHJcblxyXG5cdH1cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZTFpdiggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB2ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQXJyYXkgb2YgdmVjdG9ycyAoZmxhdCBvciBmcm9tIFRIUkVFIGNsYXNzZXMpXHJcblxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlVjJhKCBnbCwgdiApIHtcclxuXHJcblx0XHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWVWM2EoIGdsLCB2ICkge1xyXG5cclxuXHRcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAzICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZVY0YSggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEFycmF5IG9mIG1hdHJpY2VzIChmbGF0IG9yIGZyb20gVEhSRUUgY2xhc2VzKVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0yYSggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDJmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZU0zYSggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA5ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZU00YSggZ2wsIHYgKSB7XHJcblxyXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAxNiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gQ3ViZSlcclxuXHJcblx0ZnVuY3Rpb24gc2V0VmFsdWVUMWEoIGdsLCB2LCByZW5kZXJlciApIHtcclxuXHJcblx0XHR2YXIgbiA9IHYubGVuZ3RoLFxyXG5cdFx0XHR1bml0cyA9IGFsbG9jVGV4VW5pdHMoIHJlbmRlcmVyLCBuICk7XHJcblxyXG5cdFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB1bml0cyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdHJlbmRlcmVyLnNldFRleHR1cmUyRCggdlsgaSBdIHx8IGVtcHR5VGV4dHVyZSwgdW5pdHNbIGkgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRWYWx1ZVQ2YSggZ2wsIHYsIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHZhciBuID0gdi5sZW5ndGgsXHJcblx0XHRcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcclxuXHJcblx0XHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHZbIGkgXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIGEgcHVyZSAoYm90dG9tLWxldmVsKSBhcnJheVxyXG5cclxuXHRmdW5jdGlvbiBnZXRQdXJlQXJyYXlTZXR0ZXIoIHR5cGUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggdHlwZSApIHtcclxuXHJcblx0XHRcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZnY7IC8vIEZMT0FUXHJcblx0XHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWVWMmE7IC8vIF9WRUMyXHJcblx0XHRcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWVWM2E7IC8vIF9WRUMzXHJcblx0XHRcdGNhc2UgMHg4YjUyOiByZXR1cm4gc2V0VmFsdWVWNGE7IC8vIF9WRUM0XHJcblxyXG5cdFx0XHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlTTJhOyAvLyBfTUFUMlxyXG5cdFx0XHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlTTNhOyAvLyBfTUFUM1xyXG5cdFx0XHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTRhOyAvLyBfTUFUNFxyXG5cclxuXHRcdFx0Y2FzZSAweDhiNWU6IHJldHVybiBzZXRWYWx1ZVQxYTsgLy8gU0FNUExFUl8yRFxyXG5cdFx0XHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDZhOyAvLyBTQU1QTEVSX0NVQkVcclxuXHJcblx0XHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlMWl2OyAvLyBJTlQsIEJPT0xcclxuXHRcdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXHJcblx0XHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xyXG5cdFx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gLS0tIFVuaWZvcm0gQ2xhc3NlcyAtLS1cclxuXHJcblx0ZnVuY3Rpb24gU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XHJcblxyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0dGhpcy5hZGRyID0gYWRkcjtcclxuXHRcdHRoaXMuc2V0VmFsdWUgPSBnZXRTaW5ndWxhclNldHRlciggYWN0aXZlSW5mby50eXBlICk7XHJcblxyXG5cdFx0Ly8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBpZDtcclxuXHRcdHRoaXMuYWRkciA9IGFkZHI7XHJcblx0XHR0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XHJcblx0XHR0aGlzLnNldFZhbHVlID0gZ2V0UHVyZUFycmF5U2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcclxuXHJcblx0XHQvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gU3RydWN0dXJlZFVuaWZvcm0oIGlkICkge1xyXG5cclxuXHRcdHRoaXMuaWQgPSBpZDtcclxuXHJcblx0XHRVbmlmb3JtQ29udGFpbmVyLmNhbGwoIHRoaXMgKTsgLy8gbWl4LWluXHJcblxyXG5cdH1cclxuXHJcblx0U3RydWN0dXJlZFVuaWZvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCBnbCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gTm90ZTogRG9uJ3QgbmVlZCBhbiBleHRyYSAncmVuZGVyZXInIHBhcmFtZXRlciwgc2luY2Ugc2FtcGxlcnNcclxuXHRcdC8vIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJ1Y3R1cmVkIHVuaWZvcm1zLlxyXG5cclxuXHRcdHZhciBzZXEgPSB0aGlzLnNlcTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBzZXFbIGkgXTtcclxuXHRcdFx0dS5zZXRWYWx1ZSggZ2wsIHZhbHVlWyB1LmlkIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIC0tLSBUb3AtbGV2ZWwgLS0tXHJcblxyXG5cdC8vIFBhcnNlciAtIGJ1aWxkcyB1cCB0aGUgcHJvcGVydHkgdHJlZSBmcm9tIHRoZSBwYXRoIHN0cmluZ3NcclxuXHJcblx0dmFyIFJlUGF0aFBhcnQgPSAvKFtcXHdcXGRfXSspKFxcXSk/KFxcW3xcXC4pPy9nO1xyXG5cclxuXHQvLyBleHRyYWN0c1xyXG5cdC8vIFx0LSB0aGUgaWRlbnRpZmllciAobWVtYmVyIG5hbWUgb3IgYXJyYXkgaW5kZXgpXHJcblx0Ly8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcclxuXHQvLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCBsZWZ0IGJyYWNrZXQgb3IgZG90ICh0eXBlIG9mIHN1YnNjcmlwdClcclxuXHQvL1xyXG5cdC8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXHJcblx0Ly8gYWxsb3cgc3RyYWlnaHRmb3J3YXJkIHBhcnNpbmcgb2YgdGhlIGhpZXJhcmNoeSB0aGF0IFdlYkdMIGVuY29kZXNcclxuXHQvLyBpbiB0aGUgdW5pZm9ybSBuYW1lcy5cclxuXHJcblx0ZnVuY3Rpb24gYWRkVW5pZm9ybSggY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0ICkge1xyXG5cclxuXHRcdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xyXG5cdFx0Y29udGFpbmVyLm1hcFsgdW5pZm9ybU9iamVjdC5pZCBdID0gdW5pZm9ybU9iamVjdDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYXJzZVVuaWZvcm0oIGFjdGl2ZUluZm8sIGFkZHIsIGNvbnRhaW5lciApIHtcclxuXHJcblx0XHR2YXIgcGF0aCA9IGFjdGl2ZUluZm8ubmFtZSxcclxuXHRcdFx0cGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG5cclxuXHRcdC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cclxuXHRcdFJlUGF0aFBhcnQubGFzdEluZGV4ID0gMDtcclxuXHJcblx0XHRmb3IgKCA7IDsgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0Y2ggPSBSZVBhdGhQYXJ0LmV4ZWMoIHBhdGggKSxcclxuXHRcdFx0XHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4LFxyXG5cclxuXHRcdFx0XHRpZCA9IG1hdGNoWyAxIF0sXHJcblx0XHRcdFx0aWRJc0luZGV4ID0gbWF0Y2hbIDIgXSA9PT0gJ10nLFxyXG5cdFx0XHRcdHN1YnNjcmlwdCA9IG1hdGNoWyAzIF07XHJcblxyXG5cdFx0XHRpZiAoIGlkSXNJbmRleCApIGlkID0gaWQgfCAwOyAvLyBjb252ZXJ0IHRvIGludGVnZXJcclxuXHJcblx0XHRcdGlmICggc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgfHwgc3Vic2NyaXB0ID09PSAnWycgJiYgbWF0Y2hFbmQgKyAyID09PSBwYXRoTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHQvLyBiYXJlIG5hbWUgb3IgXCJwdXJlXCIgYm90dG9tLWxldmVsIGFycmF5IFwiWzBdXCIgc3VmZml4XHJcblxyXG5cdFx0XHRcdGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgc3Vic2NyaXB0ID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRcdFx0bmV3IFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgOlxyXG5cdFx0XHRcdFx0bmV3IFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcclxuXHJcblx0XHRcdFx0dmFyIG1hcCA9IGNvbnRhaW5lci5tYXAsIG5leHQgPSBtYXBbIGlkIF07XHJcblxyXG5cdFx0XHRcdGlmICggbmV4dCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oIGlkICk7XHJcblx0XHRcdFx0XHRhZGRVbmlmb3JtKCBjb250YWluZXIsIG5leHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb250YWluZXIgPSBuZXh0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBSb290IENvbnRhaW5lclxyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKSB7XHJcblxyXG5cdFx0VW5pZm9ybUNvbnRhaW5lci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG5cclxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybSggcHJvZ3JhbSwgaSApLFxyXG5cdFx0XHRcdHBhdGggPSBpbmZvLm5hbWUsXHJcblx0XHRcdFx0YWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgcGF0aCApO1xyXG5cclxuXHRcdFx0cGFyc2VVbmlmb3JtKCBpbmZvLCBhZGRyLCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCBnbCwgbmFtZSwgdmFsdWUgKSB7XHJcblxyXG5cdFx0dmFyIHUgPSB0aGlzLm1hcFsgbmFtZSBdO1xyXG5cclxuXHRcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0aGlzLnJlbmRlcmVyICk7XHJcblxyXG5cdH07XHJcblxyXG5cdFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldE9wdGlvbmFsID0gZnVuY3Rpb24gKCBnbCwgb2JqZWN0LCBuYW1lICkge1xyXG5cclxuXHRcdHZhciB2ID0gb2JqZWN0WyBuYW1lIF07XHJcblxyXG5cdFx0aWYgKCB2ICE9PSB1bmRlZmluZWQgKSB0aGlzLnNldFZhbHVlKCBnbCwgbmFtZSwgdiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly8gU3RhdGljIGludGVyZmFjZVxyXG5cclxuXHRXZWJHTFVuaWZvcm1zLnVwbG9hZCA9IGZ1bmN0aW9uICggZ2wsIHNlcSwgdmFsdWVzLCByZW5kZXJlciApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBzZXFbIGkgXSxcclxuXHRcdFx0XHR2ID0gdmFsdWVzWyB1LmlkIF07XHJcblxyXG5cdFx0XHRpZiAoIHYubmVlZHNVcGRhdGUgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHQvLyBub3RlOiBhbHdheXMgdXBkYXRpbmcgd2hlbiAubmVlZHNVcGRhdGUgaXMgdW5kZWZpbmVkXHJcblx0XHRcdFx0dS5zZXRWYWx1ZSggZ2wsIHYudmFsdWUsIHJlbmRlcmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSA9IGZ1bmN0aW9uICggc2VxLCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0dmFyIHIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSBzZXFbIGkgXTtcclxuXHRcdFx0aWYgKCB1LmlkIGluIHZhbHVlcyApIHIucHVzaCggdSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcjtcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0dmFyIENvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcclxuXHRcdCdiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcclxuXHRcdCdicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcclxuXHRcdCdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxyXG5cdFx0J2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXHJcblx0XHQnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxyXG5cdFx0J2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcclxuXHRcdCdkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxyXG5cdFx0J2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXHJcblx0XHQnZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXHJcblx0XHQnaW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxyXG5cdFx0J2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcclxuXHRcdCdsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxyXG5cdFx0J2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcclxuXHRcdCdsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcclxuXHRcdCdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcclxuXHRcdCdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxyXG5cdFx0J25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcclxuXHRcdCdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxyXG5cdFx0J3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4RixcclxuXHRcdCdyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxyXG5cdFx0J3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXHJcblx0XHQnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxyXG5cdFx0J3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcclxuXHJcblx0ZnVuY3Rpb24gQ29sb3IoIHIsIGcsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoIHIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0UkdCKCByLCBnLCBiICk7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggQ29sb3IucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0aXNDb2xvcjogdHJ1ZSxcclxuXHJcblx0XHRyOiAxLCBnOiAxLCBiOiAxLFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNDb2xvciApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5jb3B5KCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0dGhpcy5yID0gc2NhbGFyO1xyXG5cdFx0XHR0aGlzLmcgPSBzY2FsYXI7XHJcblx0XHRcdHRoaXMuYiA9IHNjYWxhcjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0SGV4OiBmdW5jdGlvbiAoIGhleCApIHtcclxuXHJcblx0XHRcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcclxuXHRcdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xyXG5cdFx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcclxuXHJcblx0XHRcdHRoaXMuciA9IHI7XHJcblx0XHRcdHRoaXMuZyA9IGc7XHJcblx0XHRcdHRoaXMuYiA9IGI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEhTTDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcclxuXHRcdFx0XHRpZiAoIHQgPiAxICkgdCAtPSAxO1xyXG5cdFx0XHRcdGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcclxuXHRcdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xyXG5cdFx0XHRcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcclxuXHRcdFx0XHRyZXR1cm4gcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBzZXRIU0woIGgsIHMsIGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXHJcblx0XHRcdFx0aCA9IF9NYXRoLmV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xyXG5cdFx0XHRcdHMgPSBfTWF0aC5jbGFtcCggcywgMCwgMSApO1xyXG5cdFx0XHRcdGwgPSBfTWF0aC5jbGFtcCggbCwgMCwgMSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcCA9IGwgPD0gMC41ID8gbCAqICggMSArIHMgKSA6IGwgKyBzIC0gKCBsICogcyApO1xyXG5cdFx0XHRcdFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xyXG5cdFx0XHRcdFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xyXG5cdFx0XHRcdFx0dGhpcy5iID0gaHVlMnJnYiggcSwgcCwgaCAtIDEgLyAzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZUFscGhhKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0dmFyIG07XHJcblxyXG5cdFx0XHRpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcKFxccyooW15cXCldKilcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHJnYiAvIGhzbFxyXG5cclxuXHRcdFx0XHR2YXIgY29sb3I7XHJcblx0XHRcdFx0dmFyIG5hbWUgPSBtWyAxIF07XHJcblx0XHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAncmdiJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3JnYmEnOlxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAyNTU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnaHNsJzpcclxuXHRcdFx0XHRcdGNhc2UgJ2hzbGEnOlxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFswLTldKlxcLj9bMC05XSspXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gaHNsKDEyMCw1MCUsNTAlKSBoc2xhKDEyMCw1MCUsNTAlLDAuNSlcclxuXHRcdFx0XHRcdFx0XHR2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcyA9IHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApIC8gMTAwO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBsID0gcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgLyAxMDA7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldEhTTCggaCwgcywgbCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG0gPSAvXlxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gaGV4IGNvbG9yXHJcblxyXG5cdFx0XHRcdHZhciBoZXggPSBtWyAxIF07XHJcblx0XHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gI2ZmMFxyXG5cdFx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDAgKSwgMTYgKSAvIDI1NTtcclxuXHRcdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAxICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMjU1O1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdC8vICNmZjAwMDBcclxuXHRcdFx0XHRcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XHJcblx0XHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMyApLCAxNiApIC8gMjU1O1xyXG5cdFx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb2xvciBrZXl3b3Jkc1xyXG5cdFx0XHRcdHZhciBoZXggPSBDb2xvcktleXdvcmRzWyBzdHlsZSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGhleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHJlZFxyXG5cdFx0XHRcdFx0dGhpcy5zZXRIZXgoIGhleCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIHVua25vd24gY29sb3JcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBjb2xvci5yO1xyXG5cdFx0XHR0aGlzLmcgPSBjb2xvci5nO1xyXG5cdFx0XHR0aGlzLmIgPSBjb2xvci5iO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCBjb2xvciwgZ2FtbWFGYWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcclxuXHJcblx0XHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xyXG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcclxuXHRcdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcclxuXHJcblx0XHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xyXG5cclxuXHRcdFx0dmFyIHNhZmVJbnZlcnNlID0gKCBnYW1tYUZhY3RvciA+IDAgKSA/ICggMS4wIC8gZ2FtbWFGYWN0b3IgKSA6IDEuMDtcclxuXHJcblx0XHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xyXG5cdFx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcclxuXHRcdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcclxuXHJcblx0XHRcdHRoaXMuciA9IHIgKiByO1xyXG5cdFx0XHR0aGlzLmcgPSBnICogZztcclxuXHRcdFx0dGhpcy5iID0gYiAqIGI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvbnZlcnRMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xyXG5cdFx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xyXG5cdFx0XHR0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRIZXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCAnMDAwMDAwJyArIHRoaXMuZ2V0SGV4KCkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLSA2ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xyXG5cclxuXHRcdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XHJcblxyXG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdFx0dmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XHJcblxyXG5cdFx0XHR2YXIgaHVlLCBzYXR1cmF0aW9uO1xyXG5cdFx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcblx0XHRcdGlmICggbWluID09PSBtYXggKSB7XHJcblxyXG5cdFx0XHRcdGh1ZSA9IDA7XHJcblx0XHRcdFx0c2F0dXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XHJcblxyXG5cdFx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggbWF4ICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRoc2wuaCA9IGh1ZTtcclxuXHRcdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0XHRoc2wubCA9IGxpZ2h0bmVzcztcclxuXHJcblx0XHRcdHJldHVybiBoc2w7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuICdyZ2IoJyArICggKCB0aGlzLnIgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmcgKiAyNTUgKSB8IDAgKSArICcsJyArICggKCB0aGlzLmIgKiAyNTUgKSB8IDAgKSArICcpJztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdFx0dmFyIGhzbCA9IHRoaXMuZ2V0SFNMKCk7XHJcblxyXG5cdFx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkOiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdFx0dGhpcy5yICs9IGNvbG9yLnI7XHJcblx0XHRcdHRoaXMuZyArPSBjb2xvci5nO1xyXG5cdFx0XHR0aGlzLmIgKz0gY29sb3IuYjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xyXG5cclxuXHRcdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcclxuXHRcdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcclxuXHRcdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgKz0gcztcclxuXHRcdFx0dGhpcy5nICs9IHM7XHJcblx0XHRcdHRoaXMuYiArPSBzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdWI6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBNYXRoLm1heCggMCwgdGhpcy5yIC0gY29sb3IuciApO1xyXG5cdFx0XHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xyXG5cdFx0XHR0aGlzLmIgPSBNYXRoLm1heCggMCwgdGhpcy5iIC0gY29sb3IuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHRcdHRoaXMuciAqPSBjb2xvci5yO1xyXG5cdFx0XHR0aGlzLmcgKj0gY29sb3IuZztcclxuXHRcdFx0dGhpcy5iICo9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnIgKj0gcztcclxuXHRcdFx0dGhpcy5nICo9IHM7XHJcblx0XHRcdHRoaXMuYiAqPSBzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xyXG5cdFx0XHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcclxuXHRcdFx0dGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcclxuXHRcdFx0dGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLnI7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdldEhleCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xyXG5cdCAqL1xyXG5cclxuXHR2YXIgVW5pZm9ybXNMaWIgPSB7XHJcblxyXG5cdFx0Y29tbW9uOiB7XHJcblxyXG5cdFx0XHRkaWZmdXNlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZWVlZWVlICkgfSxcclxuXHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0dXZUcmFuc2Zvcm06IHsgdmFsdWU6IG5ldyBNYXRyaXgzKCkgfSxcclxuXHJcblx0XHRcdGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzcGVjdWxhcm1hcDoge1xyXG5cclxuXHRcdFx0c3BlY3VsYXJNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVudm1hcDoge1xyXG5cclxuXHRcdFx0ZW52TWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdGZsaXBFbnZNYXA6IHsgdmFsdWU6IC0gMSB9LFxyXG5cdFx0XHRyZWZsZWN0aXZpdHk6IHsgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XHRyZWZyYWN0aW9uUmF0aW86IHsgdmFsdWU6IDAuOTggfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YW9tYXA6IHtcclxuXHJcblx0XHRcdGFvTWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdGFvTWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxpZ2h0bWFwOiB7XHJcblxyXG5cdFx0XHRsaWdodE1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRsaWdodE1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlbWlzc2l2ZW1hcDoge1xyXG5cclxuXHRcdFx0ZW1pc3NpdmVNYXA6IHsgdmFsdWU6IG51bGwgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YnVtcG1hcDoge1xyXG5cclxuXHRcdFx0YnVtcE1hcDogeyB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XHRidW1wU2NhbGU6IHsgdmFsdWU6IDEgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bm9ybWFsbWFwOiB7XHJcblxyXG5cdFx0XHRub3JtYWxNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCAxLCAxICkgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGlzcGxhY2VtZW50bWFwOiB7XHJcblxyXG5cdFx0XHRkaXNwbGFjZW1lbnRNYXA6IHsgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0ZGlzcGxhY2VtZW50U2NhbGU6IHsgdmFsdWU6IDEgfSxcclxuXHRcdFx0ZGlzcGxhY2VtZW50QmlhczogeyB2YWx1ZTogMCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyb3VnaG5lc3NtYXA6IHtcclxuXHJcblx0XHRcdHJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtZXRhbG5lc3NtYXA6IHtcclxuXHJcblx0XHRcdG1ldGFsbmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRncmFkaWVudG1hcDoge1xyXG5cclxuXHRcdFx0Z3JhZGllbnRNYXA6IHsgdmFsdWU6IG51bGwgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Zm9nOiB7XHJcblxyXG5cdFx0XHRmb2dEZW5zaXR5OiB7IHZhbHVlOiAwLjAwMDI1IH0sXHJcblx0XHRcdGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcclxuXHRcdFx0Zm9nRmFyOiB7IHZhbHVlOiAyMDAwIH0sXHJcblx0XHRcdGZvZ0NvbG9yOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZmZmZmZmICkgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGlnaHRzOiB7XHJcblxyXG5cdFx0XHRhbWJpZW50TGlnaHRDb2xvcjogeyB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcdGRpcmVjdGlvbmFsTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcdGRpcmVjdGlvbjoge30sXHJcblx0XHRcdFx0Y29sb3I6IHt9LFxyXG5cclxuXHRcdFx0XHRzaGFkb3c6IHt9LFxyXG5cdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxyXG5cdFx0XHRcdHNoYWRvd1JhZGl1czoge30sXHJcblx0XHRcdFx0c2hhZG93TWFwU2l6ZToge31cclxuXHRcdFx0fSB9LFxyXG5cclxuXHRcdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IHsgdmFsdWU6IFtdIH0sXHJcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFx0c3BvdExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcclxuXHRcdFx0XHRjb2xvcjoge30sXHJcblx0XHRcdFx0cG9zaXRpb246IHt9LFxyXG5cdFx0XHRcdGRpcmVjdGlvbjoge30sXHJcblx0XHRcdFx0ZGlzdGFuY2U6IHt9LFxyXG5cdFx0XHRcdGNvbmVDb3M6IHt9LFxyXG5cdFx0XHRcdHBlbnVtYnJhQ29zOiB7fSxcclxuXHRcdFx0XHRkZWNheToge30sXHJcblxyXG5cdFx0XHRcdHNoYWRvdzoge30sXHJcblx0XHRcdFx0c2hhZG93Qmlhczoge30sXHJcblx0XHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcclxuXHRcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxyXG5cdFx0XHR9IH0sXHJcblxyXG5cdFx0XHRzcG90U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxyXG5cdFx0XHRzcG90U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFx0cG9pbnRMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XHJcblx0XHRcdFx0Y29sb3I6IHt9LFxyXG5cdFx0XHRcdHBvc2l0aW9uOiB7fSxcclxuXHRcdFx0XHRkZWNheToge30sXHJcblx0XHRcdFx0ZGlzdGFuY2U6IHt9LFxyXG5cclxuXHRcdFx0XHRzaGFkb3c6IHt9LFxyXG5cdFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxyXG5cdFx0XHRcdHNoYWRvd1JhZGl1czoge30sXHJcblx0XHRcdFx0c2hhZG93TWFwU2l6ZToge30sXHJcblx0XHRcdFx0c2hhZG93Q2FtZXJhTmVhcjoge30sXHJcblx0XHRcdFx0c2hhZG93Q2FtZXJhRmFyOiB7fVxyXG5cdFx0XHR9IH0sXHJcblxyXG5cdFx0XHRwb2ludFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcclxuXHRcdFx0cG9pbnRTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XHRoZW1pc3BoZXJlTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcdGRpcmVjdGlvbjoge30sXHJcblx0XHRcdFx0c2t5Q29sb3I6IHt9LFxyXG5cdFx0XHRcdGdyb3VuZENvbG9yOiB7fVxyXG5cdFx0XHR9IH0sXHJcblxyXG5cdFx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBCUkRGIGRhdGEgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBleGFtcGxlIHRvIG1haW4gc3JjXHJcblx0XHRcdHJlY3RBcmVhTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xyXG5cdFx0XHRcdGNvbG9yOiB7fSxcclxuXHRcdFx0XHRwb3NpdGlvbjoge30sXHJcblx0XHRcdFx0d2lkdGg6IHt9LFxyXG5cdFx0XHRcdGhlaWdodDoge31cclxuXHRcdFx0fSB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRwb2ludHM6IHtcclxuXHJcblx0XHRcdGRpZmZ1c2U6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfSxcclxuXHRcdFx0c2l6ZTogeyB2YWx1ZTogMS4wIH0sXHJcblx0XHRcdHNjYWxlOiB7IHZhbHVlOiAxLjAgfSxcclxuXHRcdFx0bWFwOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiBuZXcgTWF0cml4MygpIH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuaWZvcm0gVXRpbGl0aWVzXHJcblx0ICovXHJcblxyXG5cdHZhciBVbmlmb3Jtc1V0aWxzID0ge1xyXG5cclxuXHRcdG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xyXG5cclxuXHRcdFx0dmFyIG1lcmdlZCA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1lcmdlZDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcclxuXHJcblx0XHRcdHZhciB1bmlmb3Jtc19kc3QgPSB7fTtcclxuXHJcblx0XHRcdGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF0gPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggcGFyYW1ldGVyX3NyYyAmJiAoIHBhcmFtZXRlcl9zcmMuaXNDb2xvciB8fFxyXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJfc3JjLmlzTWF0cml4MyB8fCBwYXJhbWV0ZXJfc3JjLmlzTWF0cml4NCB8fFxyXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yMiB8fCBwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yMyB8fCBwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yNCB8fFxyXG5cdFx0XHRcdFx0XHRwYXJhbWV0ZXJfc3JjLmlzVGV4dHVyZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCBwYXJhbWV0ZXJfc3JjICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1bmlmb3Jtc19kc3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgYWxwaGFtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXCIjaWZkZWYgQUxQSEFURVNUXFxuXFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBhb21hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgYW9tYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XHJcblxyXG5cdHZhciBiZWdpbl92ZXJ0ZXggPSBcIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xyXG5cclxuXHR2YXIgYmVnaW5ub3JtYWxfdmVydGV4ID0gXCJcXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xcblwiO1xyXG5cclxuXHR2YXIgYnNkZnMgPSBcImZsb2F0IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcdGlmKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcbiNpZiBkZWZpbmVkICggUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUyApXFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApO1xcblxcdFxcdGZsb2F0IG1heERpc3RhbmNlQ3V0b2ZmRmFjdG9yID0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTtcXG5cXHRcXHRyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmICogbWF4RGlzdGFuY2VDdXRvZmZGYWN0b3I7XFxuI2Vsc2VcXG5cXHRcXHRyZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuI2VuZGlmXFxuXFx0fVxcblxcdHJldHVybiAxLjA7XFxufVxcbnZlYzMgQlJERl9EaWZmdXNlX0xhbWJlcnQoIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yICkge1xcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yO1xcbn1cXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBkb3RMSCApIHtcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQ3MyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXG5cXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG59XFxuZmxvYXQgR19HR1hfU21pdGgoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGdsID0gZG90TkwgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRmbG9hdCBndiA9IGRvdE5WICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxuXFx0cmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1xcbn1cXG5mbG9hdCBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGd2ID0gZG90TkwgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXG5cXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxuXFx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xcbn1cXG5mbG9hdCBEX0dHWCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXG5cXHRmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBhMiAvIHBvdzIoIGRlbm9tICk7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9HR1goIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFx0ZmxvYXQgRyA9IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggYWxwaGEsIGRvdE5MLCBkb3ROViApO1xcblxcdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbnZlYzIgTFRDX1V2KCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGNvbnN0IGZsb2F0IExVVF9TSVpFICA9IDY0LjA7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX0JJQVMgID0gMC41IC8gTFVUX1NJWkU7XFxuXFx0ZmxvYXQgdGhldGEgPSBhY29zKCBkb3QoIE4sIFYgKSApO1xcblxcdHZlYzIgdXYgPSB2ZWMyKFxcblxcdFxcdHNxcnQoIHNhdHVyYXRlKCByb3VnaG5lc3MgKSApLFxcblxcdFxcdHNhdHVyYXRlKCB0aGV0YSAvICggMC41ICogUEkgKSApICk7XFxuXFx0dXYgPSB1diAqIExVVF9TQ0FMRSArIExVVF9CSUFTO1xcblxcdHJldHVybiB1djtcXG59XFxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XFxuXFx0ZmxvYXQgbCA9IGxlbmd0aCggZiApO1xcblxcdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcXG59XFxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XFxuXFx0ZmxvYXQgeCA9IGRvdCggdjEsIHYyICk7XFxuXFx0ZmxvYXQgeSA9IGFicyggeCApO1xcblxcdGZsb2F0IGEgPSAwLjg2MjY3ICsgKDAuNDk3ODggKyAwLjAxNDM2ICogeSApICogeTtcXG5cXHRmbG9hdCBiID0gMy40NTA2OCArICg0LjE4ODE0ICsgeSkgKiB5O1xcblxcdGZsb2F0IHYgPSBhIC8gYjtcXG5cXHRmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICh4ID4gMC4wKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggMS4wIC0geCAqIHggKSAtIHY7XFxuXFx0cmV0dXJuIGNyb3NzKCB2MSwgdjIgKSAqIHRoZXRhX3NpbnRoZXRhO1xcbn1cXG52ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHtcXG5cXHR2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07XFxuXFx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcXG5cXHRpZiggZG90KCBsaWdodE5vcm1hbCwgUCAtIHJlY3RDb29yZHNbIDAgXSApIDwgMC4wICkgcmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdHZlYzMgVDEsIFQyO1xcblxcdFQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7XFxuXFx0VDIgPSAtIGNyb3NzKCBOLCBUMSApO1xcblxcdG1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxuXFx0dmVjMyBjb29yZHNbIDQgXTtcXG5cXHRjb29yZHNbIDAgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMCBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMSBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAxIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDMgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMyBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMCBdID0gbm9ybWFsaXplKCBjb29yZHNbIDAgXSApO1xcblxcdGNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApO1xcblxcdGNvb3Jkc1sgMiBdID0gbm9ybWFsaXplKCBjb29yZHNbIDIgXSApO1xcblxcdGNvb3Jkc1sgMyBdID0gbm9ybWFsaXplKCBjb29yZHNbIDMgXSApO1xcblxcdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTtcXG5cXHR2ZWMzIHJlc3VsdCA9IHZlYzMoIExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggdmVjdG9yRm9ybUZhY3RvciApICk7XFxuXFx0cmV0dXJuIHJlc3VsdDtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcblxcdGNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApO1xcblxcdHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XFxuXFx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxuXFx0dmVjMiBBQiA9IHZlYzIoIC0xLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG5cXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIEFCLnggKyBBQi55O1xcbn1cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xcblxcdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyBnZW9tZXRyeS52aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApO1xcblxcdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG59XFxuZmxvYXQgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBjb25zdCBpbiBmbG9hdCBnZ3hSb3VnaG5lc3MgKSB7XFxuXFx0cmV0dXJuICggMi4wIC8gcG93MiggZ2d4Um91Z2huZXNzICsgMC4wMDAxICkgLSAyLjAgKTtcXG59XFxuZmxvYXQgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCBibGlubkV4cG9uZW50ICkge1xcblxcdHJldHVybiBzcXJ0KCAyLjAgLyAoIGJsaW5uRXhwb25lbnQgKyAyLjAgKSApO1xcbn1cXG5cIjtcclxuXHJcblx0dmFyIGJ1bXBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG5cXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXHRcXHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuXFx0XFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcdFxcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cXHRcXHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5cXHRcXHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXHRcXHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXHR9XFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG5cXHRcXHR2ZWMzIHZTaWdtYVggPSB2ZWMzKCBkRmR4KCBzdXJmX3Bvcy54ICksIGRGZHgoIHN1cmZfcG9zLnkgKSwgZEZkeCggc3VyZl9wb3MueiApICk7XFxuXFx0XFx0dmVjMyB2U2lnbWFZID0gdmVjMyggZEZkeSggc3VyZl9wb3MueCApLCBkRmR5KCBzdXJmX3Bvcy55ICksIGRGZHkoIHN1cmZfcG9zLnogKSApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQgPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgKysgaSApIHtcXG5cXHRcXHR2ZWM0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRpZiAoIGRvdCggdlZpZXdQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXG5cXHR9XFxuXFx0XFx0XFxuXFx0I2lmIFVOSU9OX0NMSVBQSU5HX1BMQU5FUyA8IE5VTV9DTElQUElOR19QTEFORVNcXG5cXHRcXHRib29sIGNsaXBwZWQgPSB0cnVlO1xcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgKysgaSApIHtcXG5cXHRcXHRcXHR2ZWM0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRcXHRjbGlwcGVkID0gKCBkb3QoIHZWaWV3UG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApICYmIGNsaXBwZWQ7XFxuXFx0XFx0fVxcblxcdFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxuXFx0XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwICYmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXggPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMCAmJiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBjb2xvcl9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgY29sb3JfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBjb2xvcl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuI2VuZGlmXCI7XHJcblxyXG5cdHZhciBjb2xvcl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgY29tbW9uID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE4XFxuI2RlZmluZSBQSV9IQUxGIDEuNTcwNzk2MzI2Nzk0OVxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxuZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9XFxuZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfVxcbmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7IHJldHVybiBkb3QoIGNvbG9yLCB2ZWMzKCAwLjMzMzMgKSApOyB9XFxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcXG5cXHRjb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7XFxuXFx0aGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XFxuXFx0cmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTtcXG59XFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxuXFx0dmVjMyBwb3NpdGlvbjtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxufTtcXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcbn1cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG59XFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcbn1cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG59XFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0cmV0dXJuIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKSArIHBvaW50T25MaW5lO1xcbn1cXG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcXG5cXHRtYXQzIHRtcDtcXG5cXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcXG5cXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcXG5cXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcXG5cXHRyZXR1cm4gdG1wO1xcbn1cXG5mbG9hdCBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkge1xcblxcdHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNiwgMC43MTUyLCAwLjA3MjIgKTtcXG5cXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCBjb2xvci5yZ2IgKTtcXG59XFxuXCI7XHJcblxyXG5cdHZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuI2RlZmluZSBjdWJlVVZfdGV4dHVyZVNpemUgKDEwMjQuMClcXG5pbnQgZ2V0RmFjZUZyb21EaXJlY3Rpb24odmVjMyBkaXJlY3Rpb24pIHtcXG5cXHR2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyhkaXJlY3Rpb24pO1xcblxcdGludCBmYWNlID0gLTE7XFxuXFx0aWYoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7XFxuXFx0XFx0aWYoYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMCA6IDM7XFxuXFx0XFx0ZWxzZVxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEgOiA0O1xcblxcdH1cXG5cXHRlbHNlIHtcXG5cXHRcXHRpZihhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55IClcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyIDogNTtcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxuXFx0fVxcblxcdHJldHVybiBmYWNlO1xcbn1cXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMSAgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMS4wKVxcbiNkZWZpbmUgY3ViZVVWX3JhbmdlQ2xhbXAgKGV4cDIoKDYuMCAtIDEuMCkgKiAyLjApKVxcbnZlYzIgTWlwTGV2ZWxJbmZvKCB2ZWMzIHZlYywgZmxvYXQgcm91Z2huZXNzTGV2ZWwsIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBzY2FsZSA9IGV4cDIoY3ViZVVWX21heExvZHMxIC0gcm91Z2huZXNzTGV2ZWwpO1xcblxcdGZsb2F0IGR4Um91Z2huZXNzID0gZEZkeChyb3VnaG5lc3MpO1xcblxcdGZsb2F0IGR5Um91Z2huZXNzID0gZEZkeShyb3VnaG5lc3MpO1xcblxcdHZlYzMgZHggPSBkRmR4KCB2ZWMgKiBzY2FsZSAqIGR4Um91Z2huZXNzICk7XFxuXFx0dmVjMyBkeSA9IGRGZHkoIHZlYyAqIHNjYWxlICogZHlSb3VnaG5lc3MgKTtcXG5cXHRmbG9hdCBkID0gbWF4KCBkb3QoIGR4LCBkeCApLCBkb3QoIGR5LCBkeSApICk7XFxuXFx0ZCA9IGNsYW1wKGQsIDEuMCwgY3ViZVVWX3JhbmdlQ2xhbXApO1xcblxcdGZsb2F0IG1pcExldmVsID0gMC41ICogbG9nMihkKTtcXG5cXHRyZXR1cm4gdmVjMihmbG9vcihtaXBMZXZlbCksIGZyYWN0KG1pcExldmVsKSk7XFxufVxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMyIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDIuMClcXG4jZGVmaW5lIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZSAoMS4wIC8gY3ViZVVWX3RleHR1cmVTaXplKVxcbnZlYzIgZ2V0Q3ViZVVWKHZlYzMgZGlyZWN0aW9uLCBmbG9hdCByb3VnaG5lc3NMZXZlbCwgZmxvYXQgbWlwTGV2ZWwpIHtcXG5cXHRtaXBMZXZlbCA9IHJvdWdobmVzc0xldmVsID4gY3ViZVVWX21heExvZHMyIC0gMy4wID8gMC4wIDogbWlwTGV2ZWw7XFxuXFx0ZmxvYXQgYSA9IDE2LjAgKiBjdWJlVVZfcmNwVGV4dHVyZVNpemU7XFxuXFx0dmVjMiBleHAyX3BhY2tlZCA9IGV4cDIoIHZlYzIoIHJvdWdobmVzc0xldmVsLCBtaXBMZXZlbCApICk7XFxuXFx0dmVjMiByY3BfZXhwMl9wYWNrZWQgPSB2ZWMyKCAxLjAgKSAvIGV4cDJfcGFja2VkO1xcblxcdGZsb2F0IHBvd1NjYWxlID0gZXhwMl9wYWNrZWQueCAqIGV4cDJfcGFja2VkLnk7XFxuXFx0ZmxvYXQgc2NhbGUgPSByY3BfZXhwMl9wYWNrZWQueCAqIHJjcF9leHAyX3BhY2tlZC55ICogMC4yNTtcXG5cXHRmbG9hdCBtaXBPZmZzZXQgPSAwLjc1KigxLjAgLSByY3BfZXhwMl9wYWNrZWQueSkgKiByY3BfZXhwMl9wYWNrZWQueDtcXG5cXHRib29sIGJSZXMgPSBtaXBMZXZlbCA9PSAwLjA7XFxuXFx0c2NhbGUgPSAgYlJlcyAmJiAoc2NhbGUgPCBhKSA/IGEgOiBzY2FsZTtcXG5cXHR2ZWMzIHI7XFxuXFx0dmVjMiBvZmZzZXQ7XFxuXFx0aW50IGZhY2UgPSBnZXRGYWNlRnJvbURpcmVjdGlvbihkaXJlY3Rpb24pO1xcblxcdGZsb2F0IHJjcFBvd1NjYWxlID0gMS4wIC8gcG93U2NhbGU7XFxuXFx0aWYoIGZhY2UgPT0gMCkge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi54LCAtZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDAuMCttaXBPZmZzZXQsMC43NSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gYSA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDEpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKHNjYWxlK21pcE9mZnNldCwgMC43NSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gYSA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDIpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDIuMCpzY2FsZSttaXBPZmZzZXQsIDAuNzUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAzKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigwLjArbWlwT2Zmc2V0LDAuNSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2UgaWYoIGZhY2UgPT0gNCkge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi55LCBkaXJlY3Rpb24ueCwgLWRpcmVjdGlvbi56KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKHNjYWxlK21pcE9mZnNldCwgMC41ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAwLjAgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnosIC1kaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkpO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoMi4wKnNjYWxlK21pcE9mZnNldCwgMC41ICogcmNwUG93U2NhbGUpO1xcblxcdFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAwLjAgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ciA9IG5vcm1hbGl6ZShyKTtcXG5cXHRmbG9hdCB0ZXhlbE9mZnNldCA9IDAuNSAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXG5cXHR2ZWMyIHMgPSAoIHIueXogLyBhYnMoIHIueCApICsgdmVjMiggMS4wICkgKSAqIDAuNTtcXG5cXHR2ZWMyIGJhc2UgPSBvZmZzZXQgKyB2ZWMyKCB0ZXhlbE9mZnNldCApO1xcblxcdHJldHVybiBiYXNlICsgcyAqICggc2NhbGUgLSAyLjAgKiB0ZXhlbE9mZnNldCApO1xcbn1cXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMyAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAzLjApXFxudmVjNCB0ZXh0dXJlQ3ViZVVWKHZlYzMgcmVmbGVjdGVkRGlyZWN0aW9uLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgcm91Z2huZXNzVmFsID0gcm91Z2huZXNzKiBjdWJlVVZfbWF4TG9kczM7XFxuXFx0ZmxvYXQgcjEgPSBmbG9vcihyb3VnaG5lc3NWYWwpO1xcblxcdGZsb2F0IHIyID0gcjEgKyAxLjA7XFxuXFx0ZmxvYXQgdCA9IGZyYWN0KHJvdWdobmVzc1ZhbCk7XFxuXFx0dmVjMiBtaXBJbmZvID0gTWlwTGV2ZWxJbmZvKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIHJvdWdobmVzcyk7XFxuXFx0ZmxvYXQgcyA9IG1pcEluZm8ueTtcXG5cXHRmbG9hdCBsZXZlbDAgPSBtaXBJbmZvLng7XFxuXFx0ZmxvYXQgbGV2ZWwxID0gbGV2ZWwwICsgMS4wO1xcblxcdGxldmVsMSA9IGxldmVsMSA+IDUuMCA/IDUuMCA6IGxldmVsMTtcXG5cXHRsZXZlbDAgKz0gbWluKCBmbG9vciggcyArIDAuNSApLCA1LjAgKTtcXG5cXHR2ZWMyIHV2XzEwID0gZ2V0Q3ViZVVWKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIGxldmVsMCk7XFxuXFx0dmVjNCBjb2xvcjEwID0gZW52TWFwVGV4ZWxUb0xpbmVhcih0ZXh0dXJlMkQoZW52TWFwLCB1dl8xMCkpO1xcblxcdHZlYzIgdXZfMjAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMiwgbGV2ZWwwKTtcXG5cXHR2ZWM0IGNvbG9yMjAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzIwKSk7XFxuXFx0dmVjNCByZXN1bHQgPSBtaXgoY29sb3IxMCwgY29sb3IyMCwgdCk7XFxuXFx0cmV0dXJuIHZlYzQocmVzdWx0LnJnYiwgMS4wKTtcXG59XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBkZWZhdWx0bm9ybWFsX3ZlcnRleCA9IFwidmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG4jaWZkZWYgRkxJUF9TSURFRFxcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gLSB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBkaXNwbGFjZW1lbnRtYXBfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbGl6ZSggb2JqZWN0Tm9ybWFsICkgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB1diApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGVtaXNzaXZlbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxuXFx0ZW1pc3NpdmVDb2xvci5yZ2IgPSBlbWlzc2l2ZU1hcFRleGVsVG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IgKS5yZ2I7XFxuXFx0dG90YWxFbWlzc2l2ZVJhZGlhbmNlICo9IGVtaXNzaXZlQ29sb3IucmdiO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgZW5jb2RpbmdzX2ZyYWdtZW50ID0gXCIgIGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xcblwiO1xyXG5cclxuXHR2YXIgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQgPSBcIlxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IEdhbW1hVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcblxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XFxufVxcbnZlYzQgTGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCAxLjAgLyBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBzUkdCVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS53ICk7XFxufVxcbnZlYzQgUkdCRVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiBleHAyKCB2YWx1ZS5hICogMjU1LjAgLSAxMjguMCApLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQkUoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4KCBtYXgoIHZhbHVlLnIsIHZhbHVlLmcgKSwgdmFsdWUuYiApO1xcblxcdGZsb2F0IGZFeHAgPSBjbGFtcCggY2VpbCggbG9nMiggbWF4Q29tcG9uZW50ICkgKSwgLTEyOC4wLCAxMjcuMCApO1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyBleHAyKCBmRXhwICksICggZkV4cCArIDEyOC4wICkgLyAyNTUuMCApO1xcbn1cXG52ZWM0IFJHQk1Ub0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnh5eiAqIHZhbHVlLncgKiBtYXhSYW5nZSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JNKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG5cXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLngsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxuXFx0ZmxvYXQgTSAgICAgID0gY2xhbXAoIG1heFJHQiAvIG1heFJhbmdlLCAwLjAsIDEuMCApO1xcblxcdE0gICAgICAgICAgICA9IGNlaWwoIE0gKiAyNTUuMCApIC8gMjU1LjA7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAvICggTSAqIG1heFJhbmdlICksIE0gKTtcXG59XFxudmVjNCBSR0JEVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcblxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoICggbWF4UmFuZ2UgLyAyNTUuMCApIC8gdmFsdWUuYSApLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQkQoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcblxcdGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXG5cXHRmbG9hdCBEICAgICAgPSBtYXgoIG1heFJhbmdlIC8gbWF4UkdCLCAxLjAgKTtcXG5cXHREICAgICAgICAgICAgPSBtaW4oIGZsb29yKCBEICkgLyAyNTUuMCwgMS4wICk7XFxuXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggRCAqICggMjU1LjAgLyBtYXhSYW5nZSApICksIEQgKTtcXG59XFxuY29uc3QgbWF0MyBjTG9nTHV2TSA9IG1hdDMoIDAuMjIwOSwgMC4zMzkwLCAwLjQxODQsIDAuMTEzOCwgMC42NzgwLCAwLjczMTksIDAuMDEwMiwgMC4xMTMwLCAwLjI5NjkgKTtcXG52ZWM0IExpbmVhclRvTG9nTHV2KCBpbiB2ZWM0IHZhbHVlICkgIHtcXG5cXHR2ZWMzIFhwX1lfWFlacCA9IHZhbHVlLnJnYiAqIGNMb2dMdXZNO1xcblxcdFhwX1lfWFlacCA9IG1heChYcF9ZX1hZWnAsIHZlYzMoMWUtNiwgMWUtNiwgMWUtNikpO1xcblxcdHZlYzQgdlJlc3VsdDtcXG5cXHR2UmVzdWx0Lnh5ID0gWHBfWV9YWVpwLnh5IC8gWHBfWV9YWVpwLno7XFxuXFx0ZmxvYXQgTGUgPSAyLjAgKiBsb2cyKFhwX1lfWFlacC55KSArIDEyNy4wO1xcblxcdHZSZXN1bHQudyA9IGZyYWN0KExlKTtcXG5cXHR2UmVzdWx0LnogPSAoTGUgLSAoZmxvb3IodlJlc3VsdC53KjI1NS4wKSkvMjU1LjApLzI1NS4wO1xcblxcdHJldHVybiB2UmVzdWx0O1xcbn1cXG5jb25zdCBtYXQzIGNMb2dMdXZJbnZlcnNlTSA9IG1hdDMoIDYuMDAxNCwgLTIuNzAwOCwgLTEuNzk5NiwgLTEuMzMyMCwgMy4xMDI5LCAtNS43NzIxLCAwLjMwMDgsIC0xLjA4ODIsIDUuNjI2OCApO1xcbnZlYzQgTG9nTHV2VG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuXFx0ZmxvYXQgTGUgPSB2YWx1ZS56ICogMjU1LjAgKyB2YWx1ZS53O1xcblxcdHZlYzMgWHBfWV9YWVpwO1xcblxcdFhwX1lfWFlacC55ID0gZXhwMigoTGUgLSAxMjcuMCkgLyAyLjApO1xcblxcdFhwX1lfWFlacC56ID0gWHBfWV9YWVpwLnkgLyB2YWx1ZS55O1xcblxcdFhwX1lfWFlacC54ID0gdmFsdWUueCAqIFhwX1lfWFlacC56O1xcblxcdHZlYzMgdlJHQiA9IFhwX1lfWFlacC5yZ2IgKiBjTG9nTHV2SW52ZXJzZU07XFxuXFx0cmV0dXJuIHZlYzQoIG1heCh2UkdCLCAwLjApLCAxLjAgKTtcXG59XFxuXCI7XHJcblxyXG5cdHZhciBlbnZtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCByZWZsZWN0VmVjICk7XFxuXFx0XFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCByZWZsZWN0VmVjLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXG5cXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggcmVmbGVjdFZlYy56LCByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcblxcdFxcdHJlZmxlY3RWZWMgPSBub3JtYWxpemUoIHJlZmxlY3RWZWMgKTtcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSApLnh5eiArIHZlYzMoIDAuMCwgMC4wLCAxLjAgKSApO1xcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHRlbnZDb2xvciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudkNvbG9yICk7XFxuXFx0I2lmZGVmIEVOVk1BUF9CTEVORElOR19NVUxUSVBMWVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIG91dGdvaW5nTGlnaHQgKiBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXG5cXHRcXHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBlbnZtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSFlTSUNBTCApXFxuXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICggZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSApXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGVudm1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGVudm1hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGZvZ192ZXJ0ZXggPSBcIlxcbiNpZmRlZiBVU0VfRk9HXFxuZm9nRGVwdGggPSAtbXZQb3NpdGlvbi56O1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgZm9nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0ZPR1xcbiAgdmFyeWluZyBmbG9hdCBmb2dEZXB0aDtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGZvZ19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBmb2dEZXB0aCAqIGZvZ0RlcHRoICogTE9HMiApICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGZvZ0RlcHRoICk7XFxuXFx0I2VuZGlmXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgZm9nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcdHZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7XFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFRPT05cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDtcXG5cXHR2ZWMzIGdldEdyYWRpZW50SXJyYWRpYW5jZSggdmVjMyBub3JtYWwsIHZlYzMgbGlnaHREaXJlY3Rpb24gKSB7XFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXJlY3Rpb24gKTtcXG5cXHRcXHR2ZWMyIGNvb3JkID0gdmVjMiggZG90TkwgKiAwLjUgKyAwLjUsIDAuMCApO1xcblxcdFxcdCNpZmRlZiBVU0VfR1JBRElFTlRNQVBcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yZ2I7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gKCBjb29yZC54IDwgMC43ICkgPyB2ZWMzKCAwLjcgKSA6IHZlYzMoIDEuMCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGxpZ2h0bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XHJcblxyXG5cdHZhciBsaWdodHNfbGFtYmVydF92ZXJ0ZXggPSBcInZlYzMgZGlmZnVzZSA9IHZlYzMoIDEuMCApO1xcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XFxuZ2VvbWV0cnkucG9zaXRpb24gPSBtdlBvc2l0aW9uLnh5ejtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggLW12UG9zaXRpb24ueHl6ICk7XFxuR2VvbWV0cmljQ29udGV4dCBiYWNrR2VvbWV0cnk7XFxuYmFja0dlb21ldHJ5LnBvc2l0aW9uID0gZ2VvbWV0cnkucG9zaXRpb247XFxuYmFja0dlb21ldHJ5Lm5vcm1hbCA9IC1nZW9tZXRyeS5ub3JtYWw7XFxuYmFja0dlb21ldHJ5LnZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcbnZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG4jZW5kaWZcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbmZsb2F0IGRvdE5MO1xcbnZlYzMgZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBzcG90TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBsaWdodHNfcGFycyA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcbnZlYzMgZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBhbWJpZW50TGlnaHRDb2xvciApIHtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdCNlbmRpZlxcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0aW50IHNoYWRvdztcXG5cXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0dm9pZCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0XFx0aW50IHNoYWRvdztcXG5cXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjtcXG5cXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gKCBkaXJlY3RMaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdHN0cnVjdCBTcG90TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHRcXHRmbG9hdCBjb25lQ29zO1xcblxcdFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcblxcdFxcdGludCBzaGFkb3c7XFxuXFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdH07XFxuXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0dm9pZCBnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCAgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gc3BvdExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRpZiAoIGFuZ2xlQ29zID4gc3BvdExpZ2h0LmNvbmVDb3MgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc3BvdEVmZmVjdCA9IHNtb290aHN0ZXAoIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3I7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gc3BvdEVmZmVjdCAqIHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodDtcXG5cXHR9O1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y01hdDtcXHR1bmlmb3JtIHNhbXBsZXIyRCBsdGNNYWc7XFxuXFx0dW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBza3lDb2xvcjtcXG5cXHRcXHR2ZWMzIGdyb3VuZENvbG9yO1xcblxcdH07XFxuXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxuXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApXFxuXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGdlb21ldHJ5Lm5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBxdWVyeVZlYywgMS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdH1cXG5cXHRmbG9hdCBnZXRTcGVjdWxhck1JUExldmVsKCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXFx0XFx0ZmxvYXQgbWF4TUlQTGV2ZWxTY2FsYXIgPSBmbG9hdCggbWF4TUlQTGV2ZWwgKTtcXG5cXHRcXHRmbG9hdCBkZXNpcmVkTUlQTGV2ZWwgPSBtYXhNSVBMZXZlbFNjYWxhciArIDAuNzkyNDggLSAwLjUgKiBsb2cyKCBwb3cyKCBibGlublNoaW5pbmVzc0V4cG9uZW50ICkgKyAxLjAgKTtcXG5cXHRcXHRyZXR1cm4gY2xhbXAoIGRlc2lyZWRNSVBMZXZlbCwgMC4wLCBtYXhNSVBMZXZlbFNjYWxhciApO1xcblxcdH1cXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCAtZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCAtZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcblxcdFxcdGZsb2F0IHNwZWN1bGFyTUlQTGV2ZWwgPSBnZXRTcGVjdWxhck1JUExldmVsKCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBtYXhNSVBMZXZlbCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0XFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICk7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5UmVmbGVjdFZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVVihxdWVyeVJlZmxlY3RWZWMsIEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyhibGlublNoaW5pbmVzc0V4cG9uZW50KSk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRcXHRzYW1wbGVVVi55ID0gYXNpbiggY2xhbXAoIHJlZmxlY3RWZWMueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcblxcdFxcdFxcdHNhbXBsZVVWLnggPSBhdGFuKCByZWZsZWN0VmVjLnosIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgc2FtcGxlVVYsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZpZXcgPSBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApICkueHl6ICsgdmVjMyggMC4wLDAuMCwxLjAgKSApO1xcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJETG9kRVhUKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBsaWdodHNfcGhvbmdfZnJhZ21lbnQgPSBcIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcXG5cIjtcclxuXHJcblx0dmFyIGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXFx0dmVjM1xcdGRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdFxcdHNwZWN1bGFyU2hpbmluZXNzO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJTdHJlbmd0aDtcXG59O1xcbnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0I2lmZGVmIFRPT05cXG5cXHRcXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRHcmFkaWVudElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHQjZWxzZVxcblxcdFxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2VuZGlmXFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyApICogbWF0ZXJpYWwuc3BlY3VsYXJTdHJlbmd0aDtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9CbGlublBob25nXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcdCgwKVxcblwiO1xyXG5cclxuXHR2YXIgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50ID0gXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxuI2lmZGVmIFNUQU5EQVJEXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG4jZWxzZVxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKiBwb3cyKCByZWZsZWN0aXZpdHkgKSApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5jbGVhckNvYXQgPSBzYXR1cmF0ZSggY2xlYXJDb2F0ICk7XFx0bWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0gY2xhbXAoIGNsZWFyQ29hdFJvdWdobmVzcywgMC4wNCwgMS4wICk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzNcXHRkaWZmdXNlQ29sb3I7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclJvdWdobmVzcztcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0O1xcblxcdFxcdGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXG5cXHQjZW5kaWZcXG59O1xcbiNkZWZpbmUgTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjE2XFxuI2RlZmluZSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMDRcXG5mbG9hdCBjbGVhckNvYXRESFJBcHByb3goIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7XFxuXFx0cmV0dXJuIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKyAoIDEuMCAtIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSAqICggcG93KCAxLjAgLSBkb3ROTCwgNS4wICkgKiBwb3coIDEuMCAtIHJvdWdobmVzcywgMi4wICkgKTtcXG59XFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsKCBjb25zdCBpbiBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbm9ybWFsID0gZ2VvbWV0cnkubm9ybWFsO1xcblxcdFxcdHZlYzMgdmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdHZlYzMgbGlnaHRQb3MgPSByZWN0QXJlYUxpZ2h0LnBvc2l0aW9uO1xcblxcdFxcdHZlYzMgaGFsZldpZHRoID0gcmVjdEFyZWFMaWdodC5oYWxmV2lkdGg7XFxuXFx0XFx0dmVjMyBoYWxmSGVpZ2h0ID0gcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0O1xcblxcdFxcdHZlYzMgbGlnaHRDb2xvciA9IHJlY3RBcmVhTGlnaHQuY29sb3I7XFxuXFx0XFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3M7XFxuXFx0XFx0dmVjMyByZWN0Q29vcmRzWyA0IF07XFxuXFx0XFx0cmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcdFxcdHJlY3RDb29yZHNbIDEgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAyIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0cmVjdENvb3Jkc1sgMyBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcblxcdFxcdHZlYzIgdXYgPSBMVENfVXYoIG5vcm1hbCwgdmlld0Rpciwgcm91Z2huZXNzICk7XFxuXFx0XFx0ZmxvYXQgbm9ybSA9IHRleHR1cmUyRCggbHRjTWFnLCB1diApLmE7XFxuXFx0XFx0dmVjNCB0ID0gdGV4dHVyZTJEKCBsdGNNYXQsIHV2ICk7XFxuXFx0XFx0bWF0MyBtSW52ID0gbWF0MyhcXG5cXHRcXHRcXHR2ZWMzKCAgIDEsICAgMCwgdC55ICksXFxuXFx0XFx0XFx0dmVjMyggICAwLCB0LnosICAgMCApLFxcblxcdFxcdFxcdHZlYzMoIHQudywgICAwLCB0LnggKVxcblxcdFxcdCk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiBub3JtICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtSW52LCByZWN0Q29vcmRzICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBsaWdodENvbG9yICogbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICogTFRDX0V2YWx1YXRlKCBub3JtYWwsIHZpZXdEaXIsIHBvc2l0aW9uLCBtYXQzKCAxICksIHJlY3RDb29yZHMgKTtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90TlY7XFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogcmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gY2xlYXJDb2F0UmFkaWFuY2UgKiBtYXRlcmlhbC5jbGVhckNvYXQgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X1BoeXNpY2FsXFxuI2RlZmluZSBSRV9EaXJlY3RfUmVjdEFyZWFcXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhclxcdFxcdFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWxcXG4jZGVmaW5lIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzIClcXG4jZGVmaW5lIE1hdGVyaWFsX0NsZWFyQ29hdF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKVxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcbn1cXG5cIjtcclxuXHJcblx0dmFyIGxpZ2h0c190ZW1wbGF0ZSA9IFwiXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIHBvaW50TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggc3BvdExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgKCBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3RfUmVjdEFyZWEgKVxcblxcdFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcXG5cXHRcXHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXG5cXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0XFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0bGlnaHRNYXBJcnJhZGlhbmNlICo9IFBJO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcblxcdCNlbmRpZlxcblxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApICYmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0SXJyYWRpYW5jZSggZ2VvbWV0cnksIDggKTtcXG5cXHQjZW5kaWZcXG5cXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHZlYzMgcmFkaWFuY2UgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggZ2VvbWV0cnksIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgY2xlYXJDb2F0UmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIGxvZ2RlcHRoYnVmX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkgJiYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGX0VYVCApXFxuXFx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMiggdkZyYWdEZXB0aCApICogbG9nRGVwdGhCdWZGQyAqIDAuNTtcXG4jZW5kaWZcIjtcclxuXHJcblx0dmFyIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG4jZW5kaWZcIjtcclxuXHJcblx0dmFyIGxvZ2RlcHRoYnVmX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9Qb3NpdGlvbi56ID0gbG9nMiggbWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7XFxuXFx0XFx0Z2xfUG9zaXRpb24ueiAqPSBnbF9Qb3NpdGlvbi53O1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG5cXHR0ZXhlbENvbG9yID0gbWFwVGV4ZWxUb0xpbmVhciggdGV4ZWxDb2xvciApO1xcblxcdGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xcblxcdHZlYzQgbWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKTtcXG5cXHRkaWZmdXNlQ29sb3IgKj0gbWFwVGV4ZWxUb0xpbmVhciggbWFwVGV4ZWwgKTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX01BUFxcblxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBtZXRhbG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICk7XFxuXFx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxuI2VuZGlmXCI7XHJcblxyXG5cdHZhciBtb3JwaG5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFx0I2Vsc2VcXG5cXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQyIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ0IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcblxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ3IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgbm9ybWFsX2ZyYWdtZW50ID0gXCIjaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqICggZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKiAyLjAgLSAxLjAgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcblxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxuXFx0XFx0dmVjMyBxMCA9IHZlYzMoIGRGZHgoIGV5ZV9wb3MueCApLCBkRmR4KCBleWVfcG9zLnkgKSwgZEZkeCggZXllX3Bvcy56ICkgKTtcXG5cXHRcXHR2ZWMzIHExID0gdmVjMyggZEZkeSggZXllX3Bvcy54ICksIGRGZHkoIGV5ZV9wb3MueSApLCBkRmR5KCBleWVfcG9zLnogKSApO1xcblxcdFxcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXFx0XFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxuXFx0XFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cXHRcXHR2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcblxcdFxcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0XFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cXHRcXHRtYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxuXFx0fVxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgcGFja2luZyA9IFwidmVjMyBwYWNrTm9ybWFsVG9SR0IoIGNvbnN0IGluIHZlYzMgbm9ybWFsICkge1xcblxcdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcbn1cXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG5cXHRyZXR1cm4gMi4wICogcmdiLnh5eiAtIDEuMDtcXG59XFxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjtcXG5jb25zdCB2ZWMzIFBhY2tGYWN0b3JzID0gdmVjMyggMjU2LiAqIDI1Ni4gKiAyNTYuLCAyNTYuICogMjU2LiwgIDI1Ni4gKTtcXG5jb25zdCB2ZWM0IFVucGFja0ZhY3RvcnMgPSBVbnBhY2tEb3duc2NhbGUgLyB2ZWM0KCBQYWNrRmFjdG9ycywgMS4gKTtcXG5jb25zdCBmbG9hdCBTaGlmdFJpZ2h0OCA9IDEuIC8gMjU2LjtcXG52ZWM0IHBhY2tEZXB0aFRvUkdCQSggY29uc3QgaW4gZmxvYXQgdiApIHtcXG5cXHR2ZWM0IHIgPSB2ZWM0KCBmcmFjdCggdiAqIFBhY2tGYWN0b3JzICksIHYgKTtcXG5cXHRyLnl6dyAtPSByLnh5eiAqIFNoaWZ0UmlnaHQ4O1xcdHJldHVybiByICogUGFja1Vwc2NhbGU7XFxufVxcbmZsb2F0IHVucGFja1JHQkFUb0RlcHRoKCBjb25zdCBpbiB2ZWM0IHYgKSB7XFxuXFx0cmV0dXJuIGRvdCggdiwgVW5wYWNrRmFjdG9ycyApO1xcbn1cXG5mbG9hdCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggdmlld1ogKyBuZWFyICkgLyAoIG5lYXIgLSBmYXIgKTtcXG59XFxuZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBsaW5lYXJDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiBsaW5lYXJDbGlwWiAqICggbmVhciAtIGZhciApIC0gbmVhcjtcXG59XFxuZmxvYXQgdmlld1pUb1BlcnNwZWN0aXZlRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICgoIG5lYXIgKyB2aWV3WiApICogZmFyICkgLyAoKCBmYXIgLSBuZWFyICkgKiB2aWV3WiApO1xcbn1cXG5mbG9hdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgaW52Q2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG5cXHRyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcXG59XFxuXCI7XHJcblxyXG5cdHZhciBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50ID0gXCIjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciBwcm9qZWN0X3ZlcnRleCA9IFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXCI7XHJcblxyXG5cdHZhciBkaXRoZXJpbmdfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBESVRIRVJJTkcgKVxcbiAgZ2xfRnJhZ0NvbG9yLnJnYiA9IGRpdGhlcmluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBESVRIRVJJTkcgKVxcblxcdHZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdFxcdGZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTtcXG5cXHRcXHR2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApO1xcblxcdFxcdGRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7XFxuXFx0XFx0cmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxuI2VuZGlmXFxuXCI7XHJcblxyXG5cdHZhciByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByb3VnaG5lc3NNYXA7XFxuI2VuZGlmXCI7XHJcblxyXG5cdHZhciBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0ZmxvYXQgdGV4dHVyZTJEQ29tcGFyZSggc2FtcGxlcjJEIGRlcHRocywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXG5cXHRcXHRyZXR1cm4gc3RlcCggY29tcGFyZSwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggZGVwdGhzLCB1diApICkgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgdGV4dHVyZTJEU2hhZG93TGVycCggc2FtcGxlcjJEIGRlcHRocywgdmVjMiBzaXplLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblxcdFxcdGNvbnN0IHZlYzIgb2Zmc2V0ID0gdmVjMiggMC4wLCAxLjAgKTtcXG5cXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2l6ZTtcXG5cXHRcXHR2ZWMyIGNlbnRyb2lkVVYgPSBmbG9vciggdXYgKiBzaXplICsgMC41ICkgLyBzaXplO1xcblxcdFxcdGZsb2F0IGxiID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh4LCBjb21wYXJlICk7XFxuXFx0XFx0ZmxvYXQgbHQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHksIGNvbXBhcmUgKTtcXG5cXHRcXHRmbG9hdCByYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eCwgY29tcGFyZSApO1xcblxcdFxcdGZsb2F0IHJ0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnl5LCBjb21wYXJlICk7XFxuXFx0XFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2l6ZSArIDAuNSApO1xcblxcdFxcdGZsb2F0IGEgPSBtaXgoIGxiLCBsdCwgZi55ICk7XFxuXFx0XFx0ZmxvYXQgYiA9IG1peCggcmIsIHJ0LCBmLnkgKTtcXG5cXHRcXHRmbG9hdCBjID0gbWl4KCBhLCBiLCBmLnggKTtcXG5cXHRcXHRyZXR1cm4gYztcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcXG5cXHRcXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0XFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XFxuXFx0XFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcblxcdFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHNoYWRvdyA9IChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRzaGFkb3cgPSAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRzaGFkb3cgPSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBzaGFkb3c7XFxuXFx0fVxcblxcdHZlYzIgY3ViZVRvVVYoIHZlYzMgdiwgZmxvYXQgdGV4ZWxTaXplWSApIHtcXG5cXHRcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXHRcXHRmbG9hdCBzY2FsZVRvQ3ViZSA9IDEuMCAvIG1heCggYWJzVi54LCBtYXgoIGFic1YueSwgYWJzVi56ICkgKTtcXG5cXHRcXHRhYnNWICo9IHNjYWxlVG9DdWJlO1xcblxcdFxcdHYgKj0gc2NhbGVUb0N1YmUgKiAoIDEuMCAtIDIuMCAqIHRleGVsU2l6ZVkgKTtcXG5cXHRcXHR2ZWMyIHBsYW5hciA9IHYueHk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0QVRleGVsID0gMS41ICogdGV4ZWxTaXplWTtcXG5cXHRcXHRmbG9hdCBhbG1vc3RPbmUgPSAxLjAgLSBhbG1vc3RBVGV4ZWw7XFxuXFx0XFx0aWYgKCBhYnNWLnogPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGlmICggdi56ID4gMC4wIClcXG5cXHRcXHRcXHRcXHRwbGFuYXIueCA9IDQuMCAtIHYueDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnggPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcblxcdFxcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc2lnblkgPSBzaWduKCB2LnkgKTtcXG5cXHRcXHRcXHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcblxcdFxcdFxcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXG5cXHR9XFxuXFx0ZmxvYXQgZ2V0UG9pbnRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkLCBmbG9hdCBzaGFkb3dDYW1lcmFOZWFyLCBmbG9hdCBzaGFkb3dDYW1lcmFGYXIgKSB7XFxuXFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvICggc2hhZG93TWFwU2l6ZSAqIHZlYzIoIDQuMCwgMi4wICkgKTtcXG5cXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHNoYWRvd0Nvb3JkLnh5ejtcXG5cXHRcXHRmbG9hdCBkcCA9ICggbGVuZ3RoKCBsaWdodFRvUG9zaXRpb24gKSAtIHNoYWRvd0NhbWVyYU5lYXIgKSAvICggc2hhZG93Q2FtZXJhRmFyIC0gc2hhZG93Q2FtZXJhTmVhciApO1xcdFxcdGRwICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXG5cXHRcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgb2Zmc2V0ID0gdmVjMiggLSAxLCAxICkgKiBzaGFkb3dSYWRpdXMgKiB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgc2hhZG93bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IHNwb3RTaGFkb3dNYXRyaXhbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIHNoYWRvd21hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dlNwb3RTaGFkb3dDb29yZFsgaSBdID0gc3BvdFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50ID0gXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcblxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IGJvb2woIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93ICkgPyBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cywgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0fVxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSBib29sKCBwb2ludExpZ2h0LnNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXHRyZXR1cm4gc2hhZG93O1xcbn1cXG5cIjtcclxuXHJcblx0dmFyIHNraW5iYXNlX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgc2tpbm5pbmdfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblxcdFxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlU2l6ZTtcXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXFx0XFx0XFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxuXFx0XFx0XFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxuXFx0XFx0XFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFx0XFx0XFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGJvbmVNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFx0XFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IGJvbmVNYXRyaWNlc1sgaW50KGkpIF07XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgc2tpbm5pbmdfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHR2ZWM0IHNraW5uZWQgPSB2ZWM0KCAwLjAgKTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRaICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQuejtcXG5cXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG5cXHR0cmFuc2Zvcm1lZCA9ICggYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkICkueHl6O1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgc2tpbm5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblxcdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG4jZW5kaWZcXG5cIjtcclxuXHJcblx0dmFyIHNwZWN1bGFybWFwX2ZyYWdtZW50ID0gXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXG5cXHRzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcbiNlbHNlXFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcXG4jZW5kaWZcIjtcclxuXHJcblx0dmFyIHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIjtcclxuXHJcblx0dmFyIHRvbmVtYXBwaW5nX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCA9IFwiI2lmbmRlZiBzYXR1cmF0ZVxcblxcdCNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZW5kaWZcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ1doaXRlUG9pbnQ7XFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRyZXR1cm4gdG9uZU1hcHBpbmdFeHBvc3VyZSAqIGNvbG9yO1xcbn1cXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXG59XFxuI2RlZmluZSBVbmNoYXJ0ZWQySGVscGVyKCB4ICkgbWF4KCAoICggeCAqICggMC4xNSAqIHggKyAwLjEwICogMC41MCApICsgMC4yMCAqIDAuMDIgKSAvICggeCAqICggMC4xNSAqIHggKyAwLjUwICkgKyAwLjIwICogMC4zMCApICkgLSAwLjAyIC8gMC4zMCwgdmVjMyggMC4wICkgKVxcbnZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBVbmNoYXJ0ZWQySGVscGVyKCBjb2xvciApIC8gVW5jaGFydGVkMkhlbHBlciggdmVjMyggdG9uZU1hcHBpbmdXaGl0ZVBvaW50ICkgKSApO1xcbn1cXG52ZWMzIE9wdGltaXplZENpbmVvblRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxuXFx0cmV0dXJuIHBvdyggKCBjb2xvciAqICggNi4yICogY29sb3IgKyAwLjUgKSApIC8gKCBjb2xvciAqICggNi4yICogY29sb3IgKyAxLjcgKSArIDAuMDYgKSwgdmVjMyggMi4yICkgKTtcXG59XFxuXCI7XHJcblxyXG5cdHZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgdXZfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFx0dW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgdXZfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgdXYyX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgdXYyX3BhcnNfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHRhdHRyaWJ1dGUgdmVjMiB1djI7XFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XHJcblxyXG5cdHZhciB1djJfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHR2VXYyID0gdXYyO1xcbiNlbmRpZlwiO1xyXG5cclxuXHR2YXIgd29ybGRwb3NfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcblxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcbiNlbmRpZlxcblwiO1xyXG5cclxuXHR2YXIgY3ViZV9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1xcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG52b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcXG5cXHRnbF9GcmFnQ29sb3IuYSAqPSBvcGFjaXR5O1xcbn1cXG5cIjtcclxuXHJcblx0dmFyIGN1YmVfdmVydCA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udztcXG59XFxuXCI7XHJcblxyXG5cdHZhciBkZXB0aF9mcmFnID0gXCIjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcblxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHRcXHRkaWZmdXNlQ29sb3IuYSA9IG9wYWNpdHk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGdsX0ZyYWdDb29yZC56ICksIG9wYWNpdHkgKTtcXG5cXHQjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGdsX0ZyYWdDb29yZC56ICk7XFxuXFx0I2VuZGlmXFxufVxcblwiO1xyXG5cclxuXHR2YXIgZGVwdGhfdmVydCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4Plxcbn1cXG5cIjtcclxuXHJcblx0dmFyIGRpc3RhbmNlUkdCQV9mcmFnID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uO1xcbnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgZmFyRGlzdGFuY2U7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4gKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdGZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTtcXG5cXHRkaXN0ID0gKCBkaXN0IC0gbmVhckRpc3RhbmNlICkgLyAoIGZhckRpc3RhbmNlIC0gbmVhckRpc3RhbmNlICk7XFxuXFx0ZGlzdCA9IHNhdHVyYXRlKCBkaXN0ICk7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBkaXN0ICk7XFxufVxcblwiO1xyXG5cclxuXHR2YXIgZGlzdGFuY2VSR0JBX3ZlcnQgPSBcIiNkZWZpbmUgRElTVEFOQ0VcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcdFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG59XFxuXCI7XHJcblxyXG5cdHZhciBlcXVpcmVjdF9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xcblxcdHZlYzIgc2FtcGxlVVY7XFxuXFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCBkaXJlY3Rpb24ueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcblxcdHNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcbn1cXG5cIjtcclxuXHJcblx0dmFyIGVxdWlyZWN0X3ZlcnQgPSBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxufVxcblwiO1xyXG5cclxuXHR2YXIgbGluZWRhc2hlZF9mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcXG51bmlmb3JtIGZsb2F0IHRvdGFsU2l6ZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIjtcclxuXHJcblx0dmFyIGxpbmVkYXNoZWRfdmVydCA9IFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcclxuXHJcblx0dmFyIG1lc2hiYXNpY19mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XHJcblxyXG5cdHZhciBtZXNoYmFzaWNfdmVydCA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XFxuXCI7XHJcblxyXG5cdHZhciBtZXNobGFtYmVydF9mcmFnID0gXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdCNpbmNsdWRlIDxsaWdodG1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICkgKiBnZXRTaGFkb3dNYXNrKCk7XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XFxuXCI7XHJcblxyXG5cdHZhciBtZXNobGFtYmVydF92ZXJ0ID0gXCIjZGVmaW5lIExBTUJFUlRcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2xhbWJlcnRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcclxuXHJcblx0dmFyIG1lc2hwaG9uZ19mcmFnID0gXCIjZGVmaW5lIFBIT05HXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waG9uZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVxcblwiO1xyXG5cclxuXHR2YXIgbWVzaHBob25nX3ZlcnQgPSBcIiNkZWZpbmUgUEhPTkdcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG4jZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcclxuXHJcblx0dmFyIG1lc2hwaHlzaWNhbF9mcmFnID0gXCIjZGVmaW5lIFBIWVNJQ0FMXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcbnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZuZGVmIFNUQU5EQVJEXFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVxcblwiO1xyXG5cclxuXHR2YXIgbWVzaHBoeXNpY2FsX3ZlcnQgPSBcIiNkZWZpbmUgUEhZU0lDQUxcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuI2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XFxuXCI7XHJcblxyXG5cdHZhciBub3JtYWxfZnJhZyA9IFwiI2RlZmluZSBOT1JNQUxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIG9wYWNpdHkgKTtcXG59XFxuXCI7XHJcblxyXG5cdHZhciBub3JtYWxfdmVydCA9IFwiI2RlZmluZSBOT1JNQUxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXFxufVxcblwiO1xyXG5cclxuXHR2YXIgcG9pbnRzX2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xyXG5cclxuXHR2YXIgcG9pbnRzX3ZlcnQgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTtcXG5cXHQjZWxzZVxcblxcdFxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cXG5cIjtcclxuXHJcblx0dmFyIHNoYWRvd19mcmFnID0gXCJ1bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xyXG5cclxuXHR2YXIgc2hhZG93X3ZlcnQgPSBcIiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XFxuXCI7XHJcblxyXG5cdHZhciBTaGFkZXJDaHVuayA9IHtcclxuXHRcdGFscGhhbWFwX2ZyYWdtZW50OiBhbHBoYW1hcF9mcmFnbWVudCxcclxuXHRcdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRhbHBoYXRlc3RfZnJhZ21lbnQ6IGFscGhhdGVzdF9mcmFnbWVudCxcclxuXHRcdGFvbWFwX2ZyYWdtZW50OiBhb21hcF9mcmFnbWVudCxcclxuXHRcdGFvbWFwX3BhcnNfZnJhZ21lbnQ6IGFvbWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcclxuXHRcdGJlZ2lubm9ybWFsX3ZlcnRleDogYmVnaW5ub3JtYWxfdmVydGV4LFxyXG5cdFx0YnNkZnM6IGJzZGZzLFxyXG5cdFx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ6IGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCxcclxuXHRcdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcclxuXHRcdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxyXG5cdFx0Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCxcclxuXHRcdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcclxuXHRcdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRjb2xvcl9wYXJzX3ZlcnRleDogY29sb3JfcGFyc192ZXJ0ZXgsXHJcblx0XHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcclxuXHRcdGNvbW1vbjogY29tbW9uLFxyXG5cdFx0Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50OiBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQsXHJcblx0XHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXHJcblx0XHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcclxuXHRcdGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXgsXHJcblx0XHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXHJcblx0XHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdFx0ZW5jb2RpbmdzX2ZyYWdtZW50OiBlbmNvZGluZ3NfZnJhZ21lbnQsXHJcblx0XHRlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRlbnZtYXBfZnJhZ21lbnQ6IGVudm1hcF9mcmFnbWVudCxcclxuXHRcdGVudm1hcF9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfcGFyc19mcmFnbWVudCxcclxuXHRcdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxyXG5cdFx0ZW52bWFwX3ZlcnRleDogZW52bWFwX3ZlcnRleCxcclxuXHRcdGZvZ192ZXJ0ZXg6IGZvZ192ZXJ0ZXgsXHJcblx0XHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcclxuXHRcdGZvZ19mcmFnbWVudDogZm9nX2ZyYWdtZW50LFxyXG5cdFx0Zm9nX3BhcnNfZnJhZ21lbnQ6IGZvZ19wYXJzX2ZyYWdtZW50LFxyXG5cdFx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcclxuXHRcdGxpZ2h0bWFwX2ZyYWdtZW50OiBsaWdodG1hcF9mcmFnbWVudCxcclxuXHRcdGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcclxuXHRcdGxpZ2h0c19wYXJzOiBsaWdodHNfcGFycyxcclxuXHRcdGxpZ2h0c19waG9uZ19mcmFnbWVudDogbGlnaHRzX3Bob25nX2ZyYWdtZW50LFxyXG5cdFx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxyXG5cdFx0bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQsXHJcblx0XHRsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRsaWdodHNfdGVtcGxhdGU6IGxpZ2h0c190ZW1wbGF0ZSxcclxuXHRcdGxvZ2RlcHRoYnVmX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9mcmFnbWVudCxcclxuXHRcdGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXHJcblx0XHRsb2dkZXB0aGJ1Zl92ZXJ0ZXg6IGxvZ2RlcHRoYnVmX3ZlcnRleCxcclxuXHRcdG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxyXG5cdFx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxyXG5cdFx0bWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfZnJhZ21lbnQsXHJcblx0XHRtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcclxuXHRcdG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50OiBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCxcclxuXHRcdG1vcnBobm9ybWFsX3ZlcnRleDogbW9ycGhub3JtYWxfdmVydGV4LFxyXG5cdFx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxyXG5cdFx0bW9ycGh0YXJnZXRfdmVydGV4OiBtb3JwaHRhcmdldF92ZXJ0ZXgsXHJcblx0XHRub3JtYWxfZnJhZ21lbnQ6IG5vcm1hbF9mcmFnbWVudCxcclxuXHRcdG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBub3JtYWxtYXBfcGFyc19mcmFnbWVudCxcclxuXHRcdHBhY2tpbmc6IHBhY2tpbmcsXHJcblx0XHRwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50LFxyXG5cdFx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxyXG5cdFx0ZGl0aGVyaW5nX2ZyYWdtZW50OiBkaXRoZXJpbmdfZnJhZ21lbnQsXHJcblx0XHRkaXRoZXJpbmdfcGFyc19mcmFnbWVudDogZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQsXHJcblx0XHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcclxuXHRcdHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCxcclxuXHRcdHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXBfcGFyc19mcmFnbWVudCxcclxuXHRcdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxyXG5cdFx0c2hhZG93bWFwX3ZlcnRleDogc2hhZG93bWFwX3ZlcnRleCxcclxuXHRcdHNoYWRvd21hc2tfcGFyc19mcmFnbWVudDogc2hhZG93bWFza19wYXJzX2ZyYWdtZW50LFxyXG5cdFx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXHJcblx0XHRza2lubmluZ19wYXJzX3ZlcnRleDogc2tpbm5pbmdfcGFyc192ZXJ0ZXgsXHJcblx0XHRza2lubmluZ192ZXJ0ZXg6IHNraW5uaW5nX3ZlcnRleCxcclxuXHRcdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcclxuXHRcdHNwZWN1bGFybWFwX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9mcmFnbWVudCxcclxuXHRcdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXHJcblx0XHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXHJcblx0XHR0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OiB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50LFxyXG5cdFx0dXZfcGFyc19mcmFnbWVudDogdXZfcGFyc19mcmFnbWVudCxcclxuXHRcdHV2X3BhcnNfdmVydGV4OiB1dl9wYXJzX3ZlcnRleCxcclxuXHRcdHV2X3ZlcnRleDogdXZfdmVydGV4LFxyXG5cdFx0dXYyX3BhcnNfZnJhZ21lbnQ6IHV2Ml9wYXJzX2ZyYWdtZW50LFxyXG5cdFx0dXYyX3BhcnNfdmVydGV4OiB1djJfcGFyc192ZXJ0ZXgsXHJcblx0XHR1djJfdmVydGV4OiB1djJfdmVydGV4LFxyXG5cdFx0d29ybGRwb3NfdmVydGV4OiB3b3JsZHBvc192ZXJ0ZXgsXHJcblxyXG5cdFx0Y3ViZV9mcmFnOiBjdWJlX2ZyYWcsXHJcblx0XHRjdWJlX3ZlcnQ6IGN1YmVfdmVydCxcclxuXHRcdGRlcHRoX2ZyYWc6IGRlcHRoX2ZyYWcsXHJcblx0XHRkZXB0aF92ZXJ0OiBkZXB0aF92ZXJ0LFxyXG5cdFx0ZGlzdGFuY2VSR0JBX2ZyYWc6IGRpc3RhbmNlUkdCQV9mcmFnLFxyXG5cdFx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IGRpc3RhbmNlUkdCQV92ZXJ0LFxyXG5cdFx0ZXF1aXJlY3RfZnJhZzogZXF1aXJlY3RfZnJhZyxcclxuXHRcdGVxdWlyZWN0X3ZlcnQ6IGVxdWlyZWN0X3ZlcnQsXHJcblx0XHRsaW5lZGFzaGVkX2ZyYWc6IGxpbmVkYXNoZWRfZnJhZyxcclxuXHRcdGxpbmVkYXNoZWRfdmVydDogbGluZWRhc2hlZF92ZXJ0LFxyXG5cdFx0bWVzaGJhc2ljX2ZyYWc6IG1lc2hiYXNpY19mcmFnLFxyXG5cdFx0bWVzaGJhc2ljX3ZlcnQ6IG1lc2hiYXNpY192ZXJ0LFxyXG5cdFx0bWVzaGxhbWJlcnRfZnJhZzogbWVzaGxhbWJlcnRfZnJhZyxcclxuXHRcdG1lc2hsYW1iZXJ0X3ZlcnQ6IG1lc2hsYW1iZXJ0X3ZlcnQsXHJcblx0XHRtZXNocGhvbmdfZnJhZzogbWVzaHBob25nX2ZyYWcsXHJcblx0XHRtZXNocGhvbmdfdmVydDogbWVzaHBob25nX3ZlcnQsXHJcblx0XHRtZXNocGh5c2ljYWxfZnJhZzogbWVzaHBoeXNpY2FsX2ZyYWcsXHJcblx0XHRtZXNocGh5c2ljYWxfdmVydDogbWVzaHBoeXNpY2FsX3ZlcnQsXHJcblx0XHRub3JtYWxfZnJhZzogbm9ybWFsX2ZyYWcsXHJcblx0XHRub3JtYWxfdmVydDogbm9ybWFsX3ZlcnQsXHJcblx0XHRwb2ludHNfZnJhZzogcG9pbnRzX2ZyYWcsXHJcblx0XHRwb2ludHNfdmVydDogcG9pbnRzX3ZlcnQsXHJcblx0XHRzaGFkb3dfZnJhZzogc2hhZG93X2ZyYWcsXHJcblx0XHRzaGFkb3dfdmVydDogc2hhZG93X3ZlcnRcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuXHQgKi9cclxuXHJcblx0dmFyIFNoYWRlckxpYiA9IHtcclxuXHJcblx0XHRiYXNpYzoge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuZW52bWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmZvZ1xyXG5cdFx0XHRdICksXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY192ZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX2ZyYWdcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxhbWJlcnQ6IHtcclxuXHJcblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5mb2csXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XSApLFxyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF92ZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfZnJhZ1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGhvbmc6IHtcclxuXHJcblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuZ3JhZGllbnRtYXAsXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0cyxcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRlbWlzc2l2ZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXHJcblx0XHRcdFx0XHRzcGVjdWxhcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweDExMTExMSApIH0sXHJcblx0XHRcdFx0XHRzaGluaW5lc3M6IHsgdmFsdWU6IDMwIH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdF0gKSxcclxuXHJcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfZnJhZ1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3RhbmRhcmQ6IHtcclxuXHJcblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmVudm1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIucm91Z2huZXNzbWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5mb2csXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcdHJvdWdobmVzczogeyB2YWx1ZTogMC41IH0sXHJcblx0XHRcdFx0XHRtZXRhbG5lc3M6IHsgdmFsdWU6IDAuNSB9LFxyXG5cdFx0XHRcdFx0ZW52TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH0gLy8gdGVtcG9yYXJ5XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdICksXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHBvaW50czoge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5wb2ludHMsXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuZm9nXHJcblx0XHRcdF0gKSxcclxuXHJcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX3ZlcnQsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfZnJhZ1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGFzaGVkOiB7XHJcblxyXG5cdFx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5mb2csXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0c2NhbGU6IHsgdmFsdWU6IDEgfSxcclxuXHRcdFx0XHRcdGRhc2hTaXplOiB7IHZhbHVlOiAxIH0sXHJcblx0XHRcdFx0XHR0b3RhbFNpemU6IHsgdmFsdWU6IDIgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XSApLFxyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX2ZyYWdcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRlcHRoOiB7XHJcblxyXG5cdFx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXBcclxuXHRcdFx0XSApLFxyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5kZXB0aF92ZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfZnJhZ1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bm9ybWFsOiB7XHJcblxyXG5cdFx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdF0gKSxcclxuXHJcblx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX3ZlcnQsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5ub3JtYWxfZnJhZ1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0Ly9cdEN1YmUgbWFwIHNoYWRlclxyXG5cdFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcblx0XHRjdWJlOiB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cdFx0XHRcdHRDdWJlOiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFx0dEZsaXA6IHsgdmFsdWU6IC0gMSB9LFxyXG5cdFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfZnJhZ1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZXF1aXJlY3Q6IHtcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblx0XHRcdFx0dEVxdWlyZWN0OiB7IHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5lcXVpcmVjdF9mcmFnXHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVJHQkE6IHtcclxuXHJcblx0XHRcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxyXG5cdFx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRyZWZlcmVuY2VQb3NpdGlvbjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKSB9LFxyXG5cdFx0XHRcdFx0bmVhckRpc3RhbmNlOiB7IHZhbHVlOiAxIH0sXHJcblx0XHRcdFx0XHRmYXJEaXN0YW5jZTogeyB2YWx1ZTogMTAwMCB9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdICksXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV92ZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX2ZyYWdcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNoYWRvdzoge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHRcdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXHJcblx0XHRcdFx0VW5pZm9ybXNMaWIuZm9nLFxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGNvbG9yOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAgKSB9LFxyXG5cdFx0XHRcdFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRdICksXHJcblxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd192ZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc2hhZG93X2ZyYWdcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdFNoYWRlckxpYi5waHlzaWNhbCA9IHtcclxuXHJcblx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cdFx0XHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXHJcblx0XHRcdHtcclxuXHRcdFx0XHRjbGVhckNvYXQ6IHsgdmFsdWU6IDAgfSxcclxuXHRcdFx0XHRjbGVhckNvYXRSb3VnaG5lc3M6IHsgdmFsdWU6IDAgfVxyXG5cdFx0XHR9XHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcclxuXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEJveDIoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjIoICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcclxuXHRcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBCb3gyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcclxuXHRcdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSArIEluZmluaXR5O1xyXG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXHJcblxyXG5cdFx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldENlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xyXG5cdFx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XHJcblx0XHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcclxuXHRcdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55ID8gZmFsc2UgOiB0cnVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmXHJcblx0XHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4Lnk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcclxuXHRcdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoXHJcblx0XHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxyXG5cdFx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0XHQvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xyXG5cclxuXHRcdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cdFx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG5cdFx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuXHRcdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTEZsYXJlUmVuZGVyZXIoIHJlbmRlcmVyLCBnbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuXHRcdHZhciBzaGFkZXIsIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xyXG5cclxuXHRcdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcclxuXHJcblx0XHRmdW5jdGlvbiBpbml0KCkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xyXG5cdFx0XHRcdC0gMSwgLSAxLCAwLCAwLFxyXG5cdFx0XHRcdCAgMSwgLSAxLCAxLCAwLFxyXG5cdFx0XHRcdCAgMSwgMSwgMSwgMSxcclxuXHRcdFx0XHQtIDEsIDEsIDAsIDFcclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXHJcblx0XHRcdFx0MCwgMSwgMixcclxuXHRcdFx0XHQwLCAyLCAzXHJcblx0XHRcdF0gKTtcclxuXHJcblx0XHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHRcdHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcclxuXHRcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHRcdHRlbXBUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0XHRvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XHJcblx0XHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcclxuXHRcdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XHJcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xyXG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRcdHNoYWRlciA9IHtcclxuXHJcblx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcdFx0J3VuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTsnLFxyXG5cclxuXHRcdFx0XHRcdCd1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247JyxcclxuXHRcdFx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcclxuXHRcdFx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXHJcblxyXG5cdFx0XHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDsnLFxyXG5cclxuXHRcdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxyXG5cdFx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXHJcblxyXG5cdFx0XHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHRcdFx0XHRcdCd2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5OycsXHJcblxyXG5cdFx0XHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuXHRcdFx0XHRcdCdcdHZVViA9IHV2OycsXHJcblxyXG5cdFx0XHRcdFx0J1x0dmVjMiBwb3MgPSBwb3NpdGlvbjsnLFxyXG5cclxuXHRcdFx0XHRcdCdcdGlmICggcmVuZGVyVHlwZSA9PSAyICkgeycsXHJcblxyXG5cdFx0XHRcdFx0J1x0XHR2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApOycsXHJcblx0XHRcdFx0XHQnXHRcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTsnLFxyXG5cdFx0XHRcdFx0J1x0XHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7JyxcclxuXHRcdFx0XHRcdCdcdFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApOycsXHJcblx0XHRcdFx0XHQnXHRcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTsnLFxyXG5cdFx0XHRcdFx0J1x0XHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7JyxcclxuXHRcdFx0XHRcdCdcdFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApOycsXHJcblx0XHRcdFx0XHQnXHRcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTsnLFxyXG5cdFx0XHRcdFx0J1x0XHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7JyxcclxuXHJcblx0XHRcdFx0XHQnXHRcdHZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDsnLFxyXG5cdFx0XHRcdFx0J1x0XHR2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7JyxcclxuXHRcdFx0XHRcdCdcdFx0dlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wOycsXHJcblx0XHRcdFx0XHQnXHRcdHZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDsnLFxyXG5cclxuXHRcdFx0XHRcdCdcdFx0cG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTsnLFxyXG5cdFx0XHRcdFx0J1x0XHRwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55OycsXHJcblxyXG5cdFx0XHRcdFx0J1x0fScsXHJcblxyXG5cdFx0XHRcdFx0J1x0Z2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7JyxcclxuXHJcblx0XHRcdFx0XHQnfSdcclxuXHJcblx0XHRcdFx0XS5qb2luKCAnXFxuJyApLFxyXG5cclxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XHRcdCd1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7JyxcclxuXHJcblx0XHRcdFx0XHQndW5pZm9ybSBzYW1wbGVyMkQgbWFwOycsXHJcblx0XHRcdFx0XHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblx0XHRcdFx0XHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXHJcblxyXG5cdFx0XHRcdFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcclxuXHRcdFx0XHRcdCd2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5OycsXHJcblxyXG5cdFx0XHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuXHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXHJcblxyXG5cdFx0XHRcdFx0J1x0aWYgKCByZW5kZXJUeXBlID09IDAgKSB7JyxcclxuXHJcblx0XHRcdFx0XHQnXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApOycsXHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0XHRcdCdcdH0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHsnLFxyXG5cclxuXHRcdFx0XHRcdCdcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXHJcblxyXG5cdFx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XHQnXHR9IGVsc2UgeycsXHJcblxyXG5cdFx0XHRcdFx0J1x0XHR2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcclxuXHRcdFx0XHRcdCdcdFx0dGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTsnLFxyXG5cdFx0XHRcdFx0J1x0XHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlOycsXHJcblx0XHRcdFx0XHQnXHRcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7JyxcclxuXHJcblx0XHRcdFx0XHQnXHR9JyxcclxuXHJcblx0XHRcdFx0XHQnfSdcclxuXHJcblx0XHRcdFx0XS5qb2luKCAnXFxuJyApXHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIHNoYWRlciApO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcyA9IHtcclxuXHRcdFx0XHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAncG9zaXRpb24nICksXHJcblx0XHRcdFx0dXY6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAndXYnIClcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdHJlbmRlclR5cGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JlbmRlclR5cGUnICksXHJcblx0XHRcdFx0bWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXHJcblx0XHRcdFx0b2NjbHVzaW9uTWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvY2NsdXNpb25NYXAnICksXHJcblx0XHRcdFx0b3BhY2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcclxuXHRcdFx0XHRjb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXHJcblx0XHRcdFx0c2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxyXG5cdFx0XHRcdHJvdGF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NyZWVuUG9zaXRpb24nIClcclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LypcclxuXHRcdCAqIFJlbmRlciBsZW5zIGZsYXJlc1xyXG5cdFx0ICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcclxuXHRcdCAqICAgICAgICAgcmVhZHMgdGhlc2UgYmFjayBhbmQgY2FsY3VsYXRlcyBvY2NsdXNpb24uXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggZmxhcmVzLCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydCApIHtcclxuXHJcblx0XHRcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcclxuXHJcblx0XHRcdHZhciB0ZW1wUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0LncgLyB2aWV3cG9ydC56LFxyXG5cdFx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnQueiAqIDAuNSxcclxuXHRcdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydC53ICogMC41O1xyXG5cclxuXHRcdFx0dmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0LncsXHJcblx0XHRcdFx0c2NhbGUgPSBuZXcgVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuXHRcdFx0dmFyIHNjcmVlblBvc2l0aW9uID0gbmV3IFZlY3RvcjMoIDEsIDEsIDAgKSxcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0XHR2YXIgdmFsaWRBcmVhID0gbmV3IEJveDIoKTtcclxuXHJcblx0XHRcdHZhbGlkQXJlYS5taW4uc2V0KCB2aWV3cG9ydC54LCB2aWV3cG9ydC55ICk7XHJcblx0XHRcdHZhbGlkQXJlYS5tYXguc2V0KCB2aWV3cG9ydC54ICsgKCB2aWV3cG9ydC56IC0gMTYgKSwgdmlld3BvcnQueSArICggdmlld3BvcnQudyAtIDE2ICkgKTtcclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRpbml0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XHJcblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcclxuXHRcdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcclxuXHJcblx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XHJcblx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnZlcnRleCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cclxuXHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggZmFsc2UgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydC53O1xyXG5cdFx0XHRcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xyXG5cclxuXHRcdFx0XHQvLyBjYWxjIG9iamVjdCBzY3JlZW4gcG9zaXRpb25cclxuXHJcblx0XHRcdFx0dmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XHJcblxyXG5cdFx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcclxuXHJcblx0XHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcclxuXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdC8vIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIGxvd2VyIGxlZnQgY29ybmVyIG9mIHRoZSBwaXhlbHMgdG8gY29weVxyXG5cclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gdmlld3BvcnQueCArICggc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICkgKyBoYWxmVmlld3BvcnRXaWR0aCAtIDg7XHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHZpZXdwb3J0LnkgKyAoIHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKSArIGhhbGZWaWV3cG9ydEhlaWdodCAtIDg7XHJcblxyXG5cdFx0XHRcdC8vIHNjcmVlbiBjdWxsXHJcblxyXG5cdFx0XHRcdGlmICggdmFsaWRBcmVhLmNvbnRhaW5zUG9pbnQoIHNjcmVlblBvc2l0aW9uUGl4ZWxzICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xyXG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHRcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuXHRcdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLngsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnksIDE2LCAxNiwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0XHQvLyByZW5kZXIgcGluayBxdWFkXHJcblxyXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XHJcblx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0XHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xyXG5cdFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcclxuXHRcdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55LCAxNiwgMTYsIDAgKTtcclxuXHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVzdG9yZSBncmFwaGljc1xyXG5cclxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xyXG5cdFx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcclxuXHRcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0XHQvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xyXG5cclxuXHRcdFx0XHRcdGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIHJlbmRlciBmbGFyZXNcclxuXHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcclxuXHRcdFx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBzcHJpdGUgPSBmbGFyZS5sZW5zRmxhcmVzWyBqIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcclxuXHRcdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XHJcblx0XHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydC53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzY2FsZS54ID0gc2l6ZSAqIGludkFzcGVjdDtcclxuXHRcdFx0XHRcdFx0XHRzY2FsZS55ID0gc2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cdFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcclxuXHRcdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xyXG5cdFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggc3ByaXRlLnRleHR1cmUsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCB0cnVlICk7XHJcblxyXG5cdFx0XHRzdGF0ZS5yZXNldCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICkge1xyXG5cclxuXHRcdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG5cdFx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xyXG5cdFx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0XHR2YXIgcHJlZml4ID0gJ3ByZWNpc2lvbiAnICsgY2FwYWJpbGl0aWVzLnByZWNpc2lvbiArICcgZmxvYXQ7XFxuJztcclxuXHJcblx0XHRcdGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIHByZWZpeCArIHNoYWRlci5mcmFnbWVudFNoYWRlciApO1xyXG5cdFx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIENhbnZhc1RleHR1cmUoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRDYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XHJcblx0Q2FudmFzVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNUZXh0dXJlO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFdlYkdMU3ByaXRlUmVuZGVyZXIoIHJlbmRlcmVyLCBnbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcclxuXHRcdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcclxuXHJcblx0XHR2YXIgdGV4dHVyZTtcclxuXHJcblx0XHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcclxuXHJcblx0XHR2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHNwcml0ZVJvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHRcdHZhciBzcHJpdGVTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcclxuXHRcdFx0XHQtIDAuNSwgLSAwLjUsIDAsIDAsXHJcblx0XHRcdFx0ICAwLjUsIC0gMC41LCAxLCAwLFxyXG5cdFx0XHRcdCAgMC41LCAwLjUsIDEsIDEsXHJcblx0XHRcdFx0LSAwLjUsIDAuNSwgMCwgMVxyXG5cdFx0XHRdICk7XHJcblxyXG5cdFx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcclxuXHRcdFx0XHQwLCAxLCAyLFxyXG5cdFx0XHRcdDAsIDIsIDNcclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdFx0dmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XHJcblx0XHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xyXG5cdFx0XHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlcyA9IHtcclxuXHRcdFx0XHRwb3NpdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICdwb3NpdGlvbicgKSxcclxuXHRcdFx0XHR1djogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICd1dicgKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0dXZPZmZzZXQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxyXG5cdFx0XHRcdHV2U2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXHJcblxyXG5cdFx0XHRcdHJvdGF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcclxuXHRcdFx0XHRzY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXHJcblxyXG5cdFx0XHRcdGNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcclxuXHRcdFx0XHRtYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcclxuXHRcdFx0XHRvcGFjaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxyXG5cclxuXHRcdFx0XHRtb2RlbFZpZXdNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcclxuXHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxyXG5cclxuXHRcdFx0XHRmb2dUeXBlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxyXG5cdFx0XHRcdGZvZ0RlbnNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXHJcblx0XHRcdFx0Zm9nTmVhcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcclxuXHRcdFx0XHRmb2dGYXI6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcclxuXHRcdFx0XHRmb2dDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXHJcblx0XHRcdFx0Zm9nRGVwdGg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlcHRoJyApLFxyXG5cclxuXHRcdFx0XHRhbHBoYVRlc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2FscGhhVGVzdCcgKVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xyXG5cdFx0XHRjYW52YXMud2lkdGggPSA4O1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gODtcclxuXHJcblx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xyXG5cdFx0XHRjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCA4LCA4ICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlID0gbmV3IENhbnZhc1RleHR1cmUoIGNhbnZhcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc3ByaXRlcywgc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0XHQvLyBzZXR1cCBnbFxyXG5cclxuXHRcdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGluaXQoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XHJcblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcclxuXHRcdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XHJcblx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcclxuXHJcblx0XHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XHJcblx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XHJcblx0XHRcdHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xyXG5cdFx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xyXG5cclxuXHRcdFx0aWYgKCBmb2cgKSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuZm9nQ29sb3IsIGZvZy5jb2xvci5yLCBmb2cuY29sb3IuZywgZm9nLmNvbG9yLmIgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBmb2cuaXNGb2cgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xyXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcclxuXHRcdFx0XHRcdG9sZEZvZ1R5cGUgPSAxO1xyXG5cdFx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XHJcblx0XHRcdFx0XHRvbGRGb2dUeXBlID0gMjtcclxuXHRcdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAwO1xyXG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHBvc2l0aW9ucyBhbmQgc29ydFxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRzcHJpdGUubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xyXG5cclxuXHRcdFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXHJcblxyXG5cdFx0XHR2YXIgc2NhbGUgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0c3ByaXRlLm9uQmVmb3JlUmVuZGVyKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgdW5kZWZpbmVkLCBtYXRlcmlhbCwgdW5kZWZpbmVkICk7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcclxuXHRcdFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcclxuXHJcblx0XHRcdFx0c2NhbGVbIDAgXSA9IHNwcml0ZVNjYWxlLng7XHJcblx0XHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XHJcblxyXG5cdFx0XHRcdHZhciBmb2dUeXBlID0gMDtcclxuXHJcblx0XHRcdFx0aWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xyXG5cclxuXHRcdFx0XHRcdGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xyXG5cdFx0XHRcdFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcclxuXHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgbWF0ZXJpYWwubWFwLnJlcGVhdC54LCBtYXRlcmlhbC5tYXAucmVwZWF0LnkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCAwLCAwICk7XHJcblx0XHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcclxuXHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XHJcblx0XHRcdFx0Z2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XHJcblxyXG5cdFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApO1xyXG5cdFx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcblx0XHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblx0XHRcdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggbWF0ZXJpYWwubWFwIHx8IHRleHR1cmUsIDAgKTtcclxuXHJcblx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cdFx0XHRcdHNwcml0ZS5vbkFmdGVyUmVuZGVyKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgdW5kZWZpbmVkLCBtYXRlcmlhbCwgdW5kZWZpbmVkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdFx0c3RhdGUucmVzZXQoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oKSB7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcclxuXHRcdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcclxuXHJcblx0XHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXHJcblxyXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIGNhcGFiaWxpdGllcy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyAnU3ByaXRlTWF0ZXJpYWwnLFxyXG5cclxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7JyxcclxuXHRcdFx0XHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcclxuXHJcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXHJcblx0XHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXHJcblxyXG5cdFx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXHJcblx0XHRcdFx0J3ZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7JyxcclxuXHJcblx0XHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuXHRcdFx0XHQnXHR2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxyXG5cclxuXHRcdFx0XHQnXHR2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcclxuXHJcblx0XHRcdFx0J1x0dmVjMiByb3RhdGVkUG9zaXRpb247JyxcclxuXHRcdFx0XHQnXHRyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHRcdFx0XHQnXHRyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcclxuXHJcblx0XHRcdFx0J1x0dmVjNCBtdlBvc2l0aW9uOycsXHJcblxyXG5cdFx0XHRcdCdcdG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxyXG5cdFx0XHRcdCdcdG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXHJcblxyXG5cdFx0XHRcdCdcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0J1x0Zm9nRGVwdGggPSAtIG12UG9zaXRpb24uejsnLFxyXG5cclxuXHRcdFx0XHQnfSdcclxuXHJcblx0XHRcdF0uam9pbiggJ1xcbicgKSApO1xyXG5cclxuXHRcdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xyXG5cclxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBjYXBhYmlsaXRpZXMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxyXG5cclxuXHRcdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgJ1Nwcml0ZU1hdGVyaWFsJyxcclxuXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcclxuXHRcdFx0XHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIGludCBmb2dUeXBlOycsXHJcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcclxuXHRcdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dOZWFyOycsXHJcblx0XHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXHJcblx0XHRcdFx0J3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXHJcblxyXG5cdFx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXHJcblx0XHRcdFx0J3ZhcnlpbmcgZmxvYXQgZm9nRGVwdGg7JyxcclxuXHJcblx0XHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxyXG5cclxuXHRcdFx0XHQnXHR2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcclxuXHJcblx0XHRcdFx0J1x0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApOycsXHJcblxyXG5cdFx0XHRcdCdcdGlmICggZ2xfRnJhZ0NvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXHJcblxyXG5cdFx0XHRcdCdcdGlmICggZm9nVHlwZSA+IDAgKSB7JyxcclxuXHJcblx0XHRcdFx0J1x0XHRmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcclxuXHJcblx0XHRcdFx0J1x0XHRpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxyXG5cclxuXHRcdFx0XHQnXHRcdFx0Zm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBmb2dEZXB0aCApOycsXHJcblxyXG5cdFx0XHRcdCdcdFx0fSBlbHNlIHsnLFxyXG5cclxuXHRcdFx0XHQnXHRcdFx0Y29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXHJcblx0XHRcdFx0J1x0XHRcdGZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBmb2dEZXB0aCAqIGZvZ0RlcHRoICogTE9HMiApOycsXHJcblx0XHRcdFx0J1x0XHRcdGZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcclxuXHJcblx0XHRcdFx0J1x0XHR9JyxcclxuXHJcblx0XHRcdFx0J1x0XHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBmb2dDb2xvciwgZm9nRmFjdG9yICk7JyxcclxuXHJcblx0XHRcdFx0J1x0fScsXHJcblxyXG5cdFx0XHRcdCd9J1xyXG5cclxuXHRcdFx0XS5qb2luKCAnXFxuJyApICk7XHJcblxyXG5cdFx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblx0XHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdHZhciBtYXRlcmlhbElkID0gMDtcclxuXHJcblx0ZnVuY3Rpb24gTWF0ZXJpYWwoKSB7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBtYXRlcmlhbElkICsrIH0gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHRcdHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cdFx0dGhpcy5saWdodHMgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcclxuXHRcdHRoaXMuc2lkZSA9IEZyb250U2lkZTtcclxuXHRcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gTm9Db2xvcnM7IC8vIFRIUkVFLk5vQ29sb3JzLCBUSFJFRS5WZXJ0ZXhDb2xvcnMsIFRIUkVFLkZhY2VDb2xvcnNcclxuXHJcblx0XHR0aGlzLm9wYWNpdHkgPSAxO1xyXG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3RvcjtcclxuXHRcdHRoaXMuYmxlbmREc3QgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XHJcblx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xyXG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcclxuXHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xyXG5cdFx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG5cdFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gbnVsbDtcclxuXHRcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IGZhbHNlO1xyXG5cdFx0dGhpcy5jbGlwU2hhZG93cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxyXG5cclxuXHRcdHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcclxuXHJcblx0XHR0aGlzLmRpdGhlcmluZyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFUZXN0ID0gMDtcclxuXHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5vdmVyZHJhdyA9IDA7IC8vIE92ZXJkcmF3biBwaXhlbHMgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGZvciBmaXhpbmcgYW50aWFsaWFzaW5nIGdhcHMgaW4gQ2FudmFzUmVuZGVyZXJcclxuXHJcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcclxuXHJcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogTWF0ZXJpYWwsXHJcblxyXG5cdFx0aXNNYXRlcmlhbDogdHJ1ZSxcclxuXHJcblx0XHRvbkJlZm9yZUNvbXBpbGU6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHRcdHNldFZhbHVlczogZnVuY3Rpb24gKCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XHJcblxyXG5cdFx0XHRcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuTWF0ZXJpYWw6ICdcIiArIGtleSArIFwiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlwiICk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBmb3IgYmFja3dhcmQgY29tcGF0YWJpbGl0eSBpZiBzaGFkaW5nIGlzIHNldCBpbiB0aGUgY29uc3RydWN0b3JcclxuXHRcdFx0XHRpZiAoIGtleSA9PT0gJ3NoYWRpbmcnICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdFx0dGhpcy5mbGF0U2hhZGluZyA9ICggbmV3VmFsdWUgPT09IEZsYXRTaGFkaW5nICkgPyB0cnVlIDogZmFsc2U7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XHJcblxyXG5cdFx0XHRcdGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlwiICsgdGhpcy50eXBlICsgXCI6ICdcIiArIGtleSArIFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlwiICk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNWZWN0b3IzICkgJiYgKCBuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5pc1ZlY3RvcjMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0aWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcclxuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gTnVtYmVyKCBuZXdWYWx1ZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdFx0dmFyIGlzUm9vdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xyXG5cclxuXHRcdFx0aWYgKCBpc1Jvb3QgKSB7XHJcblxyXG5cdFx0XHRcdG1ldGEgPSB7XHJcblx0XHRcdFx0XHR0ZXh0dXJlczoge30sXHJcblx0XHRcdFx0XHRpbWFnZXM6IHt9XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXHJcblx0XHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxyXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIHN0YW5kYXJkIE1hdGVyaWFsIHNlcmlhbGl6YXRpb25cclxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgJiYgdGhpcy5jb2xvci5pc0NvbG9yICkgZGF0YS5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xyXG5cdFx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmVtaXNzaXZlICYmIHRoaXMuZW1pc3NpdmUuaXNDb2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xyXG5cdFx0XHRpZiAoIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEgKSBkYXRhLmVtaXNzaXZlSW50ZW5zaXR5ID0gdGhpcy5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5zcGVjdWxhciAmJiB0aGlzLnNwZWN1bGFyLmlzQ29sb3IgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcclxuXHRcdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcclxuXHRcdFx0aWYgKCB0aGlzLmNsZWFyQ29hdCAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhckNvYXQgPSB0aGlzLmNsZWFyQ29hdDtcclxuXHRcdFx0aWYgKCB0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhckNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyQ29hdFJvdWdobmVzcztcclxuXHJcblx0XHRcdGlmICggdGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRpZiAoIHRoaXMuYWxwaGFNYXAgJiYgdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRpZiAoIHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUgKSBkYXRhLmxpZ2h0TWFwID0gdGhpcy5saWdodE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRpZiAoIHRoaXMuYnVtcE1hcCAmJiB0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0XHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIHRoaXMubm9ybWFsTWFwICYmIHRoaXMubm9ybWFsTWFwLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRcdGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlLnRvQXJyYXkoKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCB0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHRcdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0XHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggdGhpcy5yb3VnaG5lc3NNYXAgJiYgdGhpcy5yb3VnaG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRpZiAoIHRoaXMubWV0YWxuZXNzTWFwICYmIHRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSApIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRcdGlmICggdGhpcy5lbWlzc2l2ZU1hcCAmJiB0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSApIGRhdGEuZW1pc3NpdmVNYXAgPSB0aGlzLmVtaXNzaXZlTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblx0XHRcdGlmICggdGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xyXG5cdFx0XHRcdGRhdGEucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7IC8vIFNjYWxlIGJlaGluZCBlbnZNYXBcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS5ncmFkaWVudE1hcCA9IHRoaXMuZ3JhZGllbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XHJcblx0XHRcdGlmICggdGhpcy5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IE5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XHJcblx0XHRcdGlmICggdGhpcy5mbGF0U2hhZGluZyA9PT0gdHJ1ZSApIGRhdGEuZmxhdFNoYWRpbmcgPSB0aGlzLmZsYXRTaGFkaW5nO1xyXG5cdFx0XHRpZiAoIHRoaXMuc2lkZSAhPT0gRnJvbnRTaWRlICkgZGF0YS5zaWRlID0gdGhpcy5zaWRlO1xyXG5cdFx0XHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSBOb0NvbG9ycyApIGRhdGEudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcblx0XHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdFx0ZGF0YS5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcclxuXHRcdFx0ZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcclxuXHRcdFx0ZGF0YS5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xyXG5cclxuXHRcdFx0Ly8gcm90YXRpb24gKFNwcml0ZU1hdGVyaWFsKVxyXG5cdFx0XHRpZiAoIHRoaXMucm90YXRpb24gIT09IDAgKSBkYXRhLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuXHJcblx0XHRcdGlmICggdGhpcy5saW5ld2lkdGggIT09IDEgKSBkYXRhLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xyXG5cdFx0XHRpZiAoIHRoaXMuZGFzaFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZGFzaFNpemUgPSB0aGlzLmRhc2hTaXplO1xyXG5cdFx0XHRpZiAoIHRoaXMuZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5nYXBTaXplID0gdGhpcy5nYXBTaXplO1xyXG5cdFx0XHRpZiAoIHRoaXMuc2NhbGUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSApIGRhdGEuZGl0aGVyaW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5hbHBoYVRlc3QgPiAwICkgZGF0YS5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcclxuXHRcdFx0aWYgKCB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIGRhdGEucHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRcdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZWNhcCAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcclxuXHRcdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZGF0YS5tb3JwaFRhcmdldHMgPSB0cnVlO1xyXG5cdFx0XHRpZiAoIHRoaXMuc2tpbm5pbmcgPT09IHRydWUgKSBkYXRhLnNraW5uaW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIGRhdGEudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuXHJcblx0XHRcdC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcclxuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpc1Jvb3QgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcclxuXHRcdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG5cdFx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XHJcblx0XHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcclxuXHJcblx0XHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XHJcblx0XHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xyXG5cdFx0XHR0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xyXG5cdFx0XHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHR0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcclxuXHRcdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcclxuXHJcblx0XHRcdHRoaXMuYmxlbmRTcmMgPSBzb3VyY2UuYmxlbmRTcmM7XHJcblx0XHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XHJcblx0XHRcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xyXG5cdFx0XHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBzb3VyY2UuYmxlbmRTcmNBbHBoYTtcclxuXHRcdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XHJcblx0XHRcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcclxuXHJcblx0XHRcdHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcclxuXHRcdFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xyXG5cdFx0XHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcclxuXHJcblx0XHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xyXG5cclxuXHRcdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xyXG5cclxuXHRcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XHJcblx0XHRcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xyXG5cdFx0XHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdFx0XHR0aGlzLmRpdGhlcmluZyA9IHNvdXJjZS5kaXRoZXJpbmc7XHJcblxyXG5cdFx0XHR0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XHJcblx0XHRcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcclxuXHJcblx0XHRcdHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XHJcblxyXG5cdFx0XHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcclxuXHRcdFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xyXG5cclxuXHRcdFx0dGhpcy5jbGlwU2hhZG93cyA9IHNvdXJjZS5jbGlwU2hhZG93cztcclxuXHRcdFx0dGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gc291cmNlLmNsaXBJbnRlcnNlY3Rpb247XHJcblxyXG5cdFx0XHR2YXIgc3JjUGxhbmVzID0gc291cmNlLmNsaXBwaW5nUGxhbmVzLFxyXG5cdFx0XHRcdGRzdFBsYW5lcyA9IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoIHNyY1BsYW5lcyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xyXG5cdFx0XHRcdGRzdFBsYW5lcyA9IG5ldyBBcnJheSggbiApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxyXG5cdFx0XHRcdFx0ZHN0UGxhbmVzWyBpIF0gPSBzcmNQbGFuZXNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IGRzdFBsYW5lcztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cHM6Ly9jbGFyYS5pb1xyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKlxyXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKlxyXG5cdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKlxyXG5cdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxyXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cclxuXHQgKiB9XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE1lc2hEZXB0aE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XHJcblxyXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBmYWxzZTtcclxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoRGVwdGhNYXRlcmlhbDtcclxuXHJcblx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuZGVwdGhQYWNraW5nID0gc291cmNlLmRlcHRoUGFja2luZztcclxuXHJcblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKlxyXG5cdCAqICByZWZlcmVuY2VQb3NpdGlvbjogPGZsb2F0PixcclxuXHQgKiAgbmVhckRpc3RhbmNlOiA8ZmxvYXQ+LFxyXG5cdCAqICBmYXJEaXN0YW5jZTogPGZsb2F0PixcclxuXHQgKlxyXG5cdCAqICBza2lubmluZzogPGJvb2w+LFxyXG5cdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuXHQgKlxyXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcclxuXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PlxyXG5cdCAqXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoRGlzdGFuY2VNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hEaXN0YW5jZU1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMubmVhckRpc3RhbmNlID0gMTtcclxuXHRcdHRoaXMuZmFyRGlzdGFuY2UgPSAxMDAwO1xyXG5cclxuXHRcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcclxuXHJcblx0XHR0aGlzLmZvZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hEaXN0YW5jZU1hdGVyaWFsO1xyXG5cclxuXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5yZWZlcmVuY2VQb3NpdGlvbi5jb3B5KCBzb3VyY2UucmVmZXJlbmNlUG9zaXRpb24gKTtcclxuXHRcdHRoaXMubmVhckRpc3RhbmNlID0gc291cmNlLm5lYXJEaXN0YW5jZTtcclxuXHRcdHRoaXMuZmFyRGlzdGFuY2UgPSBzb3VyY2UuZmFyRGlzdGFuY2U7XHJcblxyXG5cdFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHJcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQm94MyggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVmVjdG9yMyggKyBJbmZpbml0eSwgKyBJbmZpbml0eSwgKyBJbmZpbml0eSApO1xyXG5cdFx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVmVjdG9yMyggLSBJbmZpbml0eSwgLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEJveDMucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0aXNCb3gzOiB0cnVlLFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdFx0dmFyIG1pblggPSArIEluZmluaXR5O1xyXG5cdFx0XHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XHJcblx0XHRcdHZhciBtaW5aID0gKyBJbmZpbml0eTtcclxuXHJcblx0XHRcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcclxuXHRcdFx0dmFyIG1heFkgPSAtIEluZmluaXR5O1xyXG5cdFx0XHR2YXIgbWF4WiA9IC0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB4ID0gYXJyYXlbIGkgXTtcclxuXHRcdFx0XHR2YXIgeSA9IGFycmF5WyBpICsgMSBdO1xyXG5cdFx0XHRcdHZhciB6ID0gYXJyYXlbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcclxuXHRcdFx0XHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XHJcblx0XHRcdFx0aWYgKCB6IDwgbWluWiApIG1pblogPSB6O1xyXG5cclxuXHRcdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XHJcblx0XHRcdFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xyXG5cdFx0XHRcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWluLnNldCggbWluWCwgbWluWSwgbWluWiApO1xyXG5cdFx0XHR0aGlzLm1heC5zZXQoIG1heFgsIG1heFksIG1heFogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWluWCA9ICsgSW5maW5pdHk7XHJcblx0XHRcdHZhciBtaW5ZID0gKyBJbmZpbml0eTtcclxuXHRcdFx0dmFyIG1pblogPSArIEluZmluaXR5O1xyXG5cclxuXHRcdFx0dmFyIG1heFggPSAtIEluZmluaXR5O1xyXG5cdFx0XHR2YXIgbWF4WSA9IC0gSW5maW5pdHk7XHJcblx0XHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB4ID0gYXR0cmlidXRlLmdldFgoIGkgKTtcclxuXHRcdFx0XHR2YXIgeSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XHJcblx0XHRcdFx0dmFyIHogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XHJcblx0XHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRcdGlmICggeiA8IG1pblogKSBtaW5aID0gejtcclxuXHJcblx0XHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xyXG5cdFx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcclxuXHRcdFx0XHRpZiAoIHogPiBtYXhaICkgbWF4WiA9IHo7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcclxuXHRcdFx0dGhpcy5tYXguc2V0KCBtYXhYLCBtYXhZLCBtYXhaICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHBhbmRCeU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xyXG5cdFx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xyXG5cclxuXHRcdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRTaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcclxuXHRcdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xyXG5cdFx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRleHBhbmRCeU9iamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcclxuXHRcdFx0Ly8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXHJcblxyXG5cdFx0XHR2YXIgc2NvcGUsIGksIGw7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gdHJhdmVyc2UoIG5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEuY29weSggdmVydGljZXNbIGkgXSApO1xyXG5cdFx0XHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkgKS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZXhwYW5kQnlPYmplY3QoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0XHRvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnRyYXZlcnNlKCB0cmF2ZXJzZSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0XHRcdHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmXHJcblx0XHRcdFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcclxuXHRcdFx0XHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG5cdFx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldChcclxuXHRcdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxyXG5cdFx0XHRcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHRcdFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0XHRcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fFxyXG5cdFx0XHRcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdHNTcGhlcmU6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xyXG5cclxuXHRcdFx0XHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxyXG5cdFx0XHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7XHJcblxyXG5cdFx0XHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxyXG5cdFx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0gKSgpLFxyXG5cclxuXHRcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHRcdC8vIFdlIGNvbXB1dGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gZG90IHByb2R1Y3QgdmFsdWVzLiBJZiB0aG9zZSB2YWx1ZXNcclxuXHRcdFx0Ly8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXHJcblxyXG5cdFx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0XHRpZiAoIHBsYW5lLm5vcm1hbC54ID4gMCApIHtcclxuXHJcblx0XHRcdFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xyXG5cdFx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcclxuXHRcdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHBsYW5lLm5vcm1hbC55ID4gMCApIHtcclxuXHJcblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcclxuXHRcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcclxuXHRcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XHJcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XHJcblx0XHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiAoIG1pbiA8PSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gcGxhbmUuY29uc3RhbnQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cdFx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Z2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0Qm91bmRpbmdTcGhlcmUoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFNwaGVyZSgpO1xyXG5cclxuXHRcdFx0XHR0aGlzLmdldENlbnRlciggcmVzdWx0LmNlbnRlciApO1xyXG5cclxuXHRcdFx0XHRyZXN1bHQucmFkaXVzID0gdGhpcy5nZXRTaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xyXG5cdFx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHRcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cclxuXHRcdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnRzID0gW1xyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjMoKVxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0XHQvLyB0cmFuc2Zvcm0gb2YgZW1wdHkgYm94IGlzIGFuIGVtcHR5IGJveC5cclxuXHRcdFx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgcmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XHJcblx0XHRcdFx0cG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXHJcblx0XHRcdFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXHJcblx0XHRcdFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXHJcblx0XHRcdFx0cG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXHJcblx0XHRcdFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXHJcblx0XHRcdFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXHJcblx0XHRcdFx0cG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXHJcblx0XHRcdFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcdC8vIDExMVxyXG5cclxuXHRcdFx0XHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG5cdFx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gU3BoZXJlKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggU3BoZXJlLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0XHRcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVBvaW50cyggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmdldENlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCB0aGlzLnJhZGl1cyA8PSAwICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG8oIHRoaXMuY2VudGVyICkgLSB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgYm94ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IEJveDMoKTtcclxuXHJcblx0XHRcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xyXG5cdFx0XHRib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gYm94O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHRcdHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblx0XHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFBsYW5lKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggUGxhbmUucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcclxuXHRcdFx0dGhpcy5jb25zdGFudCA9IHc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdFx0dGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cclxuXHJcblx0XHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcclxuXHRcdFx0dGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxyXG5cclxuXHRcdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcclxuXHRcdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcclxuXHRcdFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuY29uc3RhbnQgKj0gLSAxO1xyXG5cdFx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSApLmFkZCggcG9pbnQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0TGluZSggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHR2YXIgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggdjEgKTtcclxuXHJcblx0XHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0XHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRpbnRlcnNlY3RzTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xyXG5cclxuXHRcdFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXHJcblxyXG5cdFx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcclxuXHRcdFx0dmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcclxuXHJcblx0XHRcdHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzUGxhbmUoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHNwaGVyZS5pbnRlcnNlY3RzUGxhbmUoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBtMSA9IG5ldyBNYXRyaXgzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlNYXRyaXg0KCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dmFyIHJlZmVyZW5jZVBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MSApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWwgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbnN0YW50ID0gLSByZWZlcmVuY2VQb2ludC5kb3QoIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QoIHRoaXMubm9ybWFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gRnJ1c3R1bSggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0XHR0aGlzLnBsYW5lcyA9IFtcclxuXHJcblx0XHRcdCggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgUGxhbmUoKSxcclxuXHRcdFx0KCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBQbGFuZSgpLFxyXG5cdFx0XHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFBsYW5lKCksXHJcblx0XHRcdCggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgUGxhbmUoKSxcclxuXHRcdFx0KCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBQbGFuZSgpLFxyXG5cdFx0XHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFBsYW5lKClcclxuXHJcblx0XHRdO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEZydXN0dW0ucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0XHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xyXG5cdFx0XHRwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xyXG5cdFx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xyXG5cdFx0XHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xyXG5cdFx0XHRwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xyXG5cdFx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xyXG5cclxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblx0XHRcdHZhciBtZTAgPSBtZVsgMCBdLCBtZTEgPSBtZVsgMSBdLCBtZTIgPSBtZVsgMiBdLCBtZTMgPSBtZVsgMyBdO1xyXG5cdFx0XHR2YXIgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcclxuXHRcdFx0dmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xyXG5cdFx0XHR2YXIgbWUxMiA9IG1lWyAxMiBdLCBtZTEzID0gbWVbIDEzIF0sIG1lMTQgPSBtZVsgMTQgXSwgbWUxNSA9IG1lWyAxNSBdO1xyXG5cclxuXHRcdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNPYmplY3QoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsIClcclxuXHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKVxyXG5cdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0aW50ZXJzZWN0c1Nwcml0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3ByaXRlKCBzcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRcdHNwaGVyZS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XHJcblx0XHRcdFx0c3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcclxuXHRcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdFx0dmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XHJcblx0XHRcdHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcDEgPSBuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdHAyID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xyXG5cdFx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcclxuXHRcdFx0XHRcdHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XHJcblx0XHRcdFx0XHRwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xyXG5cdFx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcclxuXHRcdFx0XHRcdHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xyXG5cdFx0XHRcdFx0dmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xyXG5cclxuXHRcdFx0XHRcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFNoYWRvd01hcCggX3JlbmRlcmVyLCBfb2JqZWN0cywgbWF4VGV4dHVyZVNpemUgKSB7XHJcblxyXG5cdFx0dmFyIF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKSxcclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpLFxyXG5cclxuXHRcdFx0X3NoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMigpLFxyXG5cdFx0XHRfbWF4U2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCBtYXhUZXh0dXJlU2l6ZSwgbWF4VGV4dHVyZVNpemUgKSxcclxuXHJcblx0XHRcdF9sb29rVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZCA9IG5ldyBWZWN0b3IzKCksXHJcblxyXG5cdFx0XHRfTW9ycGhpbmdGbGFnID0gMSxcclxuXHRcdFx0X1NraW5uaW5nRmxhZyA9IDIsXHJcblxyXG5cdFx0XHRfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcclxuXHJcblx0XHRcdF9kZXB0aE1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApLFxyXG5cdFx0XHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcclxuXHJcblx0XHRcdF9tYXRlcmlhbENhY2hlID0ge307XHJcblxyXG5cdFx0dmFyIGN1YmVEaXJlY3Rpb25zID0gW1xyXG5cdFx0XHRuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAwLCAwLCAxICksXHJcblx0XHRcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXHJcblx0XHRdO1xyXG5cclxuXHRcdHZhciBjdWJlVXBzID0gW1xyXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxyXG5cdFx0XHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApXHJcblx0XHRdO1xyXG5cclxuXHRcdHZhciBjdWJlMkRWaWV3UG9ydHMgPSBbXHJcblx0XHRcdG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksXHJcblx0XHRcdG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KClcclxuXHRcdF07XHJcblxyXG5cdFx0Ly8gaW5pdFxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gX051bWJlck9mTWF0ZXJpYWxWYXJpYW50czsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciB1c2VNb3JwaGluZyA9ICggaSAmIF9Nb3JwaGluZ0ZsYWcgKSAhPT0gMDtcclxuXHRcdFx0dmFyIHVzZVNraW5uaW5nID0gKCBpICYgX1NraW5uaW5nRmxhZyApICE9PSAwO1xyXG5cclxuXHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoIHtcclxuXHJcblx0XHRcdFx0ZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nLFxyXG5cclxuXHRcdFx0XHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxyXG5cdFx0XHRcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IE1lc2hEaXN0YW5jZU1hdGVyaWFsKCB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXHJcblx0XHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9IFBDRlNoYWRvd01hcDtcclxuXHJcblx0XHR0aGlzLnJlbmRlclJldmVyc2VTaWRlZCA9IHRydWU7XHJcblx0XHR0aGlzLnJlbmRlclNpbmdsZVNpZGVkID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggbGlnaHRzLCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHRcdFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0cy5sZW5ndGggPT09IDAgKSByZXR1cm47XHJcblxyXG5cdFx0XHQvLyBUT0RPIENsZWFuIHVwIChuZWVkZWQgaW4gY2FzZSBvZiBjb250ZXh0bG9zdClcclxuXHRcdFx0dmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0XHR2YXIgX3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlO1xyXG5cclxuXHRcdFx0Ly8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXHJcblx0XHRcdF9zdGF0ZS5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdFx0X3N0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIDEsIDEsIDEsIDEgKTtcclxuXHRcdFx0X3N0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCggdHJ1ZSApO1xyXG5cdFx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgZGVwdGggbWFwXHJcblxyXG5cdFx0XHR2YXIgZmFjZUNvdW50O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XHJcblx0XHRcdFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcclxuXHRcdFx0XHR2YXIgaXNQb2ludExpZ2h0ID0gbGlnaHQgJiYgbGlnaHQuaXNQb2ludExpZ2h0O1xyXG5cclxuXHRcdFx0XHRpZiAoIHNoYWRvdyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZG93TWFwOicsIGxpZ2h0LCAnaGFzIG5vIHNoYWRvdy4nICk7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgc2hhZG93Q2FtZXJhID0gc2hhZG93LmNhbWVyYTtcclxuXHJcblx0XHRcdFx0X3NoYWRvd01hcFNpemUuY29weSggc2hhZG93Lm1hcFNpemUgKTtcclxuXHRcdFx0XHRfc2hhZG93TWFwU2l6ZS5taW4oIF9tYXhTaGFkb3dNYXBTaXplICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2cFdpZHRoID0gX3NoYWRvd01hcFNpemUueDtcclxuXHRcdFx0XHRcdHZhciB2cEhlaWdodCA9IF9zaGFkb3dNYXBTaXplLnk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlc2Ugdmlld3BvcnRzIG1hcCBhIGN1YmUtbWFwIG9udG8gYSAyRCB0ZXh0dXJlIHdpdGggdGhlXHJcblx0XHRcdFx0XHQvLyBmb2xsb3dpbmcgb3JpZW50YXRpb246XHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0Ly8gIHh6WFpcclxuXHRcdFx0XHRcdC8vICAgeSBZXHJcblx0XHRcdFx0XHQvL1xyXG5cdFx0XHRcdFx0Ly8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXHJcblx0XHRcdFx0XHQvLyB4IC0gTmVnYXRpdmUgeCBkaXJlY3Rpb25cclxuXHRcdFx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxyXG5cdFx0XHRcdFx0Ly8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXHJcblx0XHRcdFx0XHQvLyBaIC0gUG9zaXRpdmUgeiBkaXJlY3Rpb25cclxuXHRcdFx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxyXG5cclxuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFhcclxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMCBdLnNldCggdnBXaWR0aCAqIDIsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdFx0Ly8gbmVnYXRpdmUgWFxyXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAxIF0uc2V0KCAwLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFpcclxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xyXG5cdFx0XHRcdFx0Ly8gbmVnYXRpdmUgWlxyXG5cdFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAzIF0uc2V0KCB2cFdpZHRoLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcclxuXHRcdFx0XHRcdC8vIHBvc2l0aXZlIFlcclxuXHRcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNCBdLnNldCggdnBXaWR0aCAqIDMsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblx0XHRcdFx0XHQvLyBuZWdhdGl2ZSBZXHJcblx0XHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0X3NoYWRvd01hcFNpemUueCAqPSA0LjA7XHJcblx0XHRcdFx0XHRfc2hhZG93TWFwU2l6ZS55ICo9IDIuMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlciwgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLCBmb3JtYXQ6IFJHQkFGb3JtYXQgfTtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3cubWFwID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KCBfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XHJcblx0XHRcdFx0XHRzaGFkb3cubWFwLnRleHR1cmUubmFtZSA9IGxpZ2h0Lm5hbWUgKyBcIi5zaGFkb3dNYXBcIjtcclxuXHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggc2hhZG93LmlzU3BvdExpZ2h0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdHNoYWRvdy51cGRhdGUoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHNoYWRvd01hcCA9IHNoYWRvdy5tYXA7XHJcblx0XHRcdFx0dmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XHJcblxyXG5cdFx0XHRcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VDb3VudCA9IDY7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZm9yIHBvaW50IGxpZ2h0cyB3ZSBzZXQgdGhlIHNoYWRvdyBtYXRyaXggdG8gYmUgYSB0cmFuc2xhdGlvbi1vbmx5IG1hdHJpeFxyXG5cdFx0XHRcdFx0Ly8gZXF1YWwgdG8gaW52ZXJzZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvblxyXG5cclxuXHRcdFx0XHRcdHNoYWRvd01hdHJpeC5tYWtlVHJhbnNsYXRpb24oIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC54LCAtIF9saWdodFBvc2l0aW9uV29ybGQueSwgLSBfbGlnaHRQb3NpdGlvbldvcmxkLnogKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlQ291bnQgPSAxO1xyXG5cclxuXHRcdFx0XHRcdF9sb29rVGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG5cdFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XHJcblxyXG5cdFx0XHRcdFx0c2hhZG93TWF0cml4LnNldChcclxuXHRcdFx0XHRcdFx0MC41LCAwLjAsIDAuMCwgMC41LFxyXG5cdFx0XHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHRcdDAuMCwgMC4wLCAwLjUsIDAuNSxcclxuXHRcdFx0XHRcdFx0MC4wLCAwLjAsIDAuMCwgMS4wXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xyXG5cdFx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcCBmb3IgZWFjaCBjdWJlIGZhY2UgKGlmIG9tbmktZGlyZWN0aW9uYWwpIG9yXHJcblx0XHRcdFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VDb3VudDsgZmFjZSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0XHRfbG9va1RhcmdldC5hZGQoIGN1YmVEaXJlY3Rpb25zWyBmYWNlIF0gKTtcclxuXHRcdFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwLmNvcHkoIGN1YmVVcHNbIGZhY2UgXSApO1xyXG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xyXG5cdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcclxuXHRcdFx0XHRcdFx0X3N0YXRlLnZpZXdwb3J0KCB2cERpbWVuc2lvbnMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuXHRcdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRcdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJPYmplY3QoIHNjZW5lLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCwgc2hhZG93Q2FtZXJhTmVhciwgc2hhZG93Q2FtZXJhRmFyICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG51bGw7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcclxuXHRcdFx0dmFyIGN1c3RvbU1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxWYXJpYW50cyA9IF9kaXN0YW5jZU1hdGVyaWFscztcclxuXHRcdFx0XHRjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdXNlTW9ycGhpbmcgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGggPiAwO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCAmJiBtYXRlcmlhbC5za2lubmluZyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkb3dNYXA6IFRIUkVFLlNraW5uZWRNZXNoIHdpdGggbWF0ZXJpYWwuc2tpbm5pbmcgc2V0IHRvIGZhbHNlOicsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xyXG5cclxuXHRcdFx0XHR2YXIgdmFyaWFudEluZGV4ID0gMDtcclxuXHJcblx0XHRcdFx0aWYgKCB1c2VNb3JwaGluZyApIHZhcmlhbnRJbmRleCB8PSBfTW9ycGhpbmdGbGFnO1xyXG5cdFx0XHRcdGlmICggdXNlU2tpbm5pbmcgKSB2YXJpYW50SW5kZXggfD0gX1NraW5uaW5nRmxhZztcclxuXHJcblx0XHRcdFx0cmVzdWx0ID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSBjdXN0b21NYXRlcmlhbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggX3JlbmRlcmVyLmxvY2FsQ2xpcHBpbmdFbmFibGVkICYmXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJlxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCBhIHVuaXF1ZSBtYXRlcmlhbCBpbnN0YW5jZSByZWZsZWN0aW5nIHRoZVxyXG5cdFx0XHRcdC8vIGFwcHJvcHJpYXRlIHN0YXRlXHJcblxyXG5cdFx0XHRcdHZhciBrZXlBID0gcmVzdWx0LnV1aWQsIGtleUIgPSBtYXRlcmlhbC51dWlkO1xyXG5cclxuXHRcdFx0XHR2YXIgbWF0ZXJpYWxzRm9yVmFyaWFudCA9IF9tYXRlcmlhbENhY2hlWyBrZXlBIF07XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWxzRm9yVmFyaWFudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsc0ZvclZhcmlhbnQgPSB7fTtcclxuXHRcdFx0XHRcdF9tYXRlcmlhbENhY2hlWyBrZXlBIF0gPSBtYXRlcmlhbHNGb3JWYXJpYW50O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBjYWNoZWRNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XHJcblx0XHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50WyBrZXlCIF0gPSBjYWNoZWRNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXN1bHQgPSBjYWNoZWRNYXRlcmlhbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJlc3VsdC52aXNpYmxlID0gbWF0ZXJpYWwudmlzaWJsZTtcclxuXHRcdFx0cmVzdWx0LndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcclxuXHJcblx0XHRcdHZhciBzaWRlID0gbWF0ZXJpYWwuc2lkZTtcclxuXHJcblx0XHRcdGlmICggc2NvcGUucmVuZGVyU2luZ2xlU2lkZWQgJiYgc2lkZSA9PSBEb3VibGVTaWRlICkge1xyXG5cclxuXHRcdFx0XHRzaWRlID0gRnJvbnRTaWRlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5yZW5kZXJSZXZlcnNlU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggc2lkZSA9PT0gRnJvbnRTaWRlICkgc2lkZSA9IEJhY2tTaWRlO1xyXG5cdFx0XHRcdGVsc2UgaWYgKCBzaWRlID09PSBCYWNrU2lkZSApIHNpZGUgPSBGcm9udFNpZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXN1bHQuc2lkZSA9IHNpZGU7XHJcblxyXG5cdFx0XHRyZXN1bHQuY2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcclxuXHRcdFx0cmVzdWx0LmNsaXBwaW5nUGxhbmVzID0gbWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXM7XHJcblx0XHRcdHJlc3VsdC5jbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbjtcclxuXHJcblx0XHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblx0XHRcdHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XHJcblxyXG5cdFx0XHRpZiAoIGlzUG9pbnRMaWdodCAmJiByZXN1bHQuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cmVzdWx0LnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoIGxpZ2h0UG9zaXRpb25Xb3JsZCApO1xyXG5cdFx0XHRcdHJlc3VsdC5uZWFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFOZWFyO1xyXG5cdFx0XHRcdHJlc3VsdC5mYXJEaXN0YW5jZSA9IHNoYWRvd0NhbWVyYUZhcjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdCggb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0XHR2YXIgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApO1xyXG5cclxuXHRcdFx0aWYgKCB2aXNpYmxlICYmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwLCBrbCA9IGdyb3Vwcy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBrIF07XHJcblx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyICk7XHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyT2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFdlYkdMQXR0cmlidXRlcyggZ2wgKSB7XHJcblxyXG5cdFx0dmFyIGJ1ZmZlcnMgPSB7fTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcclxuXHRcdFx0dmFyIHVzYWdlID0gYXR0cmlidXRlLmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBVztcclxuXHJcblx0XHRcdHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xyXG5cdFx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBhcnJheSwgdXNhZ2UgKTtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZS5vblVwbG9hZENhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHR2YXIgdHlwZSA9IGdsLkZMT0FUO1xyXG5cclxuXHRcdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IGdsLkZMT0FUO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMQXR0cmlidXRlczogVW5zdXBwb3J0ZWQgZGF0YSBidWZmZXIgZm9ybWF0OiBGbG9hdDY0QXJyYXkuJyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gZ2wuU0hPUlQ7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfSU5UO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gZ2wuSU5UO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB7XHJcblxyXG5cdFx0XHRcdHR5cGUgPSBnbC5CWVRFO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0YnVmZmVyOiBidWZmZXIsXHJcblx0XHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0XHRieXRlc1BlckVsZW1lbnQ6IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULFxyXG5cdFx0XHRcdHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlciggYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XHJcblx0XHRcdHZhciB1cGRhdGVSYW5nZSA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZTtcclxuXHJcblx0XHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuZHluYW1pYyA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGFycmF5LCBnbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdFx0Ly8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcclxuXHJcblx0XHRcdFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgYXJyYXkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcclxuXHRcdFx0XHRcdGFycmF5LnN1YmFycmF5KCB1cGRhdGVSYW5nZS5vZmZzZXQsIHVwZGF0ZVJhbmdlLm9mZnNldCArIHVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcclxuXHJcblx0XHRcdFx0dXBkYXRlUmFuZ2UuY291bnQgPSAtIDE7IC8vIHJlc2V0IHJhbmdlXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0KCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGRhdGEgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggZGF0YS5idWZmZXIgKTtcclxuXHJcblx0XHRcdFx0ZGVsZXRlIGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSBidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF0gPSBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZGF0YS52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdHVwZGF0ZUJ1ZmZlciggZGF0YS5idWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApO1xyXG5cclxuXHRcdFx0XHRkYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdGdldDogZ2V0LFxyXG5cdFx0XHRyZW1vdmU6IHJlbW92ZSxcclxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHggfHwgMDtcclxuXHRcdHRoaXMuX3kgPSB5IHx8IDA7XHJcblx0XHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBFdWxlci5EZWZhdWx0T3JkZXI7XHJcblxyXG5cdH1cclxuXHJcblx0RXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcclxuXHJcblx0RXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFdWxlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHR4OiB7XHJcblxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR5OiB7XHJcblxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3k7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR6OiB7XHJcblxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl96ID0gdmFsdWU7XHJcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRvcmRlcjoge1xyXG5cclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XHJcblx0XHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEV1bGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGlzRXVsZXI6IHRydWUsXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHg7XHJcblx0XHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0XHR0aGlzLl96ID0gejtcclxuXHRcdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBldWxlci5feDtcclxuXHRcdFx0dGhpcy5feSA9IGV1bGVyLl95O1xyXG5cdFx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XHJcblx0XHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xyXG5cclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdFx0dmFyIGNsYW1wID0gX01hdGguY2xhbXA7XHJcblxyXG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdFx0dmFyIHRlID0gbS5lbGVtZW50cztcclxuXHRcdFx0dmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XHJcblx0XHRcdHZhciBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xyXG5cdFx0XHR2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG5cdFx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xyXG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xyXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcclxuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21RdWF0ZXJuaW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxyXG5cclxuXHRcdFx0dmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJlb3JkZXIoIG5ld09yZGVyICkge1xyXG5cclxuXHRcdFx0XHRxLnNldEZyb21FdWxlciggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xyXG5cdFx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcclxuXHRcdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XHJcblx0XHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xyXG5cclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XHJcblx0XHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xyXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XHJcblxyXG5cdFx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTGF5ZXJzKCkge1xyXG5cclxuXHRcdHRoaXMubWFzayA9IDEgfCAwO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIExheWVycy5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcblx0XHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbCB8IDA7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcblx0XHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hc2sgXj0gMSA8PCBjaGFubmVsIHwgMDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc2FibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcclxuXHJcblx0XHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsIHwgMCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dGVzdDogZnVuY3Rpb24gKCBsYXllcnMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXHJcblx0ICovXHJcblxyXG5cdHZhciBvYmplY3QzRElkID0gMDtcclxuXHJcblx0ZnVuY3Rpb24gT2JqZWN0M0QoKSB7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBvYmplY3QzRElkICsrIH0gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHRcdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XHJcblxyXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuXHRcdHRoaXMudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XHJcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblx0XHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XHJcblxyXG5cdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcclxuXHJcblx0XHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJvdGF0aW9uLm9uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XHJcblx0XHRxdWF0ZXJuaW9uLm9uQ2hhbmdlKCBvblF1YXRlcm5pb25DaGFuZ2UgKTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cdFx0XHRwb3NpdGlvbjoge1xyXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdFx0dmFsdWU6IHBvc2l0aW9uXHJcblx0XHRcdH0sXHJcblx0XHRcdHJvdGF0aW9uOiB7XHJcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cclxuXHRcdFx0fSxcclxuXHRcdFx0cXVhdGVybmlvbjoge1xyXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cclxuXHRcdFx0fSxcclxuXHRcdFx0c2NhbGU6IHtcclxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRcdHZhbHVlOiBzY2FsZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtb2RlbFZpZXdNYXRyaXg6IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRub3JtYWxNYXRyaXg6IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcclxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XHJcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XHJcblxyXG5cdFx0dGhpcy51c2VyRGF0YSA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0T2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRPYmplY3QzRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogT2JqZWN0M0QsXHJcblxyXG5cdFx0aXNPYmplY3QzRDogdHJ1ZSxcclxuXHJcblx0XHRvbkJlZm9yZVJlbmRlcjogZnVuY3Rpb24gKCkge30sXHJcblx0XHRvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0XHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcclxuXHRcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25BeGlzKCBheGlzLCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBxMSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHJvdGF0ZU9uV29ybGRBeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2VcclxuXHRcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHRcdFx0Ly8gbWV0aG9kIGFzc3VtZXMgbm8gcm90YXRlZCBwYXJlbnRcclxuXHJcblx0XHRcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25Xb3JsZEF4aXMoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0XHRxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHExICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMCwgMSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXHJcblx0XHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXHJcblxyXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdHYxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHdvcmxkVG9Mb2NhbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIG0xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xyXG5cclxuXHRcdFx0XHRcdHZlY3Rvci5jb3B5KCB4ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dmVjdG9yLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5pc0NhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0XHRtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCAoIG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCApICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdhZGRlZCcgfSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXCIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZW1vdmU6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0T2JqZWN0QnlJZDogZnVuY3Rpb24gKCBpZCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICdpZCcsIGlkICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblx0XHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRRdWF0ZXJuaW9uKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRSb3RhdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgRXVsZXIoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFNjYWxlKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHRcdHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0Y2FsbGJhY2soIHRoaXMgKTtcclxuXHJcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Y2FsbGJhY2soIHRoaXMgKTtcclxuXHJcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG5cclxuXHRcdFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNhbGxiYWNrKCBwYXJlbnQgKTtcclxuXHJcblx0XHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRmb3JjZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0XHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcclxuXHRcdFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xyXG5cclxuXHRcdFx0dmFyIG91dHB1dCA9IHt9O1xyXG5cclxuXHRcdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cclxuXHRcdFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcclxuXHRcdFx0Ly8gYmVpbmcgc2VyaWFsaXplZC5cclxuXHRcdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcclxuXHRcdFx0XHRtZXRhID0ge1xyXG5cdFx0XHRcdFx0Z2VvbWV0cmllczoge30sXHJcblx0XHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxyXG5cdFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxyXG5cdFx0XHRcdFx0aW1hZ2VzOiB7fSxcclxuXHRcdFx0XHRcdHNoYXBlczoge31cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XHJcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXHJcblx0XHRcdFx0XHR0eXBlOiAnT2JqZWN0JyxcclxuXHRcdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xyXG5cclxuXHRcdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XHJcblx0XHRcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XHJcblx0XHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xyXG5cdFx0XHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcclxuXHRcdFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuXHRcdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcclxuXHJcblx0XHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2VyaWFsaXplKCBsaWJyYXJ5LCBlbGVtZW50ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlicmFyeVsgZWxlbWVudC51dWlkIF0gPSBlbGVtZW50LnRvSlNPTiggbWV0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBlbGVtZW50LnV1aWQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0Lmdlb21ldHJ5ID0gc2VyaWFsaXplKCBtZXRhLmdlb21ldHJpZXMsIHRoaXMuZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNoYXBlcyA9IHBhcmFtZXRlcnMuc2hhcGVzO1xyXG5cclxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlcyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdGhpcy5tYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB1dWlkcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHV1aWRzLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWxbIGkgXSApICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuY2hpbGRyZW4gPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XHJcblx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XHJcblx0XHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xyXG5cdFx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xyXG5cdFx0XHRcdHZhciBzaGFwZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNoYXBlcyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcclxuXHRcdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcclxuXHRcdFx0XHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcclxuXHRcdFx0XHRpZiAoIHNoYXBlcy5sZW5ndGggPiAwICkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xyXG5cclxuXHRcdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcclxuXHRcdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxyXG5cdFx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XHJcblx0XHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcclxuXHRcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xyXG5cdFx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcclxuXHJcblx0XHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xyXG5cclxuXHRcdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcclxuXHJcblx0XHRcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XHJcblx0XHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xyXG5cdFx0XHR0aGlzLnNjYWxlLmNvcHkoIHNvdXJjZS5zY2FsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XHJcblx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG5cclxuXHRcdFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcclxuXHRcdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XHJcblxyXG5cdFx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcclxuXHRcdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XHJcblxyXG5cdFx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcclxuXHRcdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcclxuXHJcblx0XHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcclxuXHJcblx0XHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xyXG5cdFx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQqL1xyXG5cclxuXHRmdW5jdGlvbiBDYW1lcmEoKSB7XHJcblxyXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDYW1lcmEnO1xyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Q2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IENhbWVyYSxcclxuXHJcblx0XHRpc0NhbWVyYTogdHJ1ZSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdFx0XHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBhcm9zZSAvIGh0dHA6Ly9naXRodWIuY29tL2Fyb3NlXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE9ydGhvZ3JhcGhpY0NhbWVyYSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0Q2FtZXJhLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcclxuXHJcblx0XHR0aGlzLnpvb20gPSAxO1xyXG5cdFx0dGhpcy52aWV3ID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdFx0dGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdFx0dGhpcy50b3AgPSB0b3A7XHJcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuXHJcblx0XHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcclxuXHRcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0fVxyXG5cclxuXHRPcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ2FtZXJhLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IE9ydGhvZ3JhcGhpY0NhbWVyYSxcclxuXHJcblx0XHRpc09ydGhvZ3JhcGhpY0NhbWVyYTogdHJ1ZSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdFx0Q2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcclxuXHRcdFx0dGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcclxuXHRcdFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xyXG5cdFx0XHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XHJcblx0XHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xyXG5cdFx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XHJcblxyXG5cdFx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcclxuXHRcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudmlldyA9IHtcclxuXHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsXHJcblx0XHRcdFx0XHRmdWxsV2lkdGg6IDEsXHJcblx0XHRcdFx0XHRmdWxsSGVpZ2h0OiAxLFxyXG5cdFx0XHRcdFx0b2Zmc2V0WDogMCxcclxuXHRcdFx0XHRcdG9mZnNldFk6IDAsXHJcblx0XHRcdFx0XHR3aWR0aDogMSxcclxuXHRcdFx0XHRcdGhlaWdodDogMVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XHJcblx0XHRcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XHJcblx0XHRcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcclxuXHRcdFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xyXG5cdFx0XHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XHJcblx0XHRcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbGVhclZpZXdPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xyXG5cdFx0XHR2YXIgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xyXG5cdFx0XHR2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XHJcblx0XHRcdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcclxuXHJcblx0XHRcdHZhciBsZWZ0ID0gY3ggLSBkeDtcclxuXHRcdFx0dmFyIHJpZ2h0ID0gY3ggKyBkeDtcclxuXHRcdFx0dmFyIHRvcCA9IGN5ICsgZHk7XHJcblx0XHRcdHZhciBib3R0b20gPSBjeSAtIGR5O1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgJiYgdGhpcy52aWV3LmVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB6b29tVyA9IHRoaXMuem9vbSAvICggdGhpcy52aWV3LndpZHRoIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCApO1xyXG5cdFx0XHRcdHZhciB6b29tSCA9IHRoaXMuem9vbSAvICggdGhpcy52aWV3LmhlaWdodCAvIHRoaXMudmlldy5mdWxsSGVpZ2h0ICk7XHJcblx0XHRcdFx0dmFyIHNjYWxlVyA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gdGhpcy52aWV3LndpZHRoO1xyXG5cdFx0XHRcdHZhciBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGxlZnQgKz0gc2NhbGVXICogKCB0aGlzLnZpZXcub2Zmc2V0WCAvIHpvb21XICk7XHJcblx0XHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogKCB0aGlzLnZpZXcud2lkdGggLyB6b29tVyApO1xyXG5cdFx0XHRcdHRvcCAtPSBzY2FsZUggKiAoIHRoaXMudmlldy5vZmZzZXRZIC8gem9vbUggKTtcclxuXHRcdFx0XHRib3R0b20gPSB0b3AgLSBzY2FsZUggKiAoIHRoaXMudmlldy5oZWlnaHQgLyB6b29tSCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuXHRcdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcclxuXHRcdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcclxuXHRcdFx0ZGF0YS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG5cdFx0XHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcclxuXHRcdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XHJcblx0XHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XHJcblx0XHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XHJcblxyXG5cdFx0dGhpcy5hID0gYTtcclxuXHRcdHRoaXMuYiA9IGI7XHJcblx0XHR0aGlzLmMgPSBjO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsID0gKCBub3JtYWwgJiYgbm9ybWFsLmlzVmVjdG9yMyApID8gbm9ybWFsIDogbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9ICggY29sb3IgJiYgY29sb3IuaXNDb2xvciApID8gY29sb3IgOiBuZXcgQ29sb3IoKTtcclxuXHRcdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggRmFjZTMucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5hID0gc291cmNlLmE7XHJcblx0XHRcdHRoaXMuYiA9IHNvdXJjZS5iO1xyXG5cdFx0XHR0aGlzLmMgPSBzb3VyY2UuYztcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsLmNvcHkoIHNvdXJjZS5ub3JtYWwgKTtcclxuXHRcdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHRcdHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICovXHJcblxyXG5cdHZhciBnZW9tZXRyeUlkID0gMDsgLy8gR2VvbWV0cnkgdXNlcyBldmVuIG51bWJlcnMgYXMgSWRcclxuXHJcblx0ZnVuY3Rpb24gR2VvbWV0cnkoKSB7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBnZW9tZXRyeUlkICs9IDIgfSApO1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cdFx0dGhpcy50eXBlID0gJ0dlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0XHR0aGlzLmNvbG9ycyA9IFtdO1xyXG5cdFx0dGhpcy5mYWNlcyA9IFtdO1xyXG5cdFx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHR0aGlzLnNraW5XZWlnaHRzID0gW107XHJcblx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblxyXG5cdFx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0XHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogR2VvbWV0cnksXHJcblxyXG5cdFx0aXNHZW9tZXRyeTogdHJ1ZSxcclxuXHJcblx0XHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xyXG5cclxuXHRcdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4ICE9PSBudWxsID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XHJcblx0XHRcdHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2LmFycmF5IDogdW5kZWZpbmVkO1xyXG5cdFx0XHR2YXIgdXZzMiA9IGF0dHJpYnV0ZXMudXYyICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2Mi5hcnJheSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcclxuXHJcblx0XHRcdHZhciB0ZW1wTm9ybWFscyA9IFtdO1xyXG5cdFx0XHR2YXIgdGVtcFVWcyA9IFtdO1xyXG5cdFx0XHR2YXIgdGVtcFVWczIgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMsIGogKz0gMiApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApICk7XHJcblxyXG5cdFx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRlbXBOb3JtYWxzLnB1c2goIG5ldyBWZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUuY29sb3JzLnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRlbXBVVnMucHVzaCggbmV3IFZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRlbXBVVnMyLnB1c2goIG5ldyBWZWN0b3IyKCB1dnMyWyBqIF0sIHV2czJbIGogKyAxIF0gKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBhZGRGYWNlKCBhLCBiLCBjLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XHJcblx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIHZlcnRleE5vcm1hbHMsIHZlcnRleENvbG9ycywgbWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0sIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGFkZEZhY2UoIGosIGogKyAxLCBqICsgMiwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XHJcblxyXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIG9mZnNldDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcclxuXHRcdFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdFx0dmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xyXG5cclxuXHRcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblx0XHRcdG1hdHJpeC5zZXQoXHJcblx0XHRcdFx0cywgMCwgMCwgLSBzICogY2VudGVyLngsXHJcblx0XHRcdFx0MCwgcywgMCwgLSBzICogY2VudGVyLnksXHJcblx0XHRcdFx0MCwgMCwgcywgLSBzICogY2VudGVyLnosXHJcblx0XHRcdFx0MCwgMCwgMCwgMVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcblx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XHJcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBhcmVhV2VpZ2h0ZWQgPT09IHVuZGVmaW5lZCApIGFyZWFXZWlnaHRlZCA9IHRydWU7XHJcblxyXG5cdFx0XHR2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcclxuXHJcblx0XHRcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNbIHYgXSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcclxuXHRcdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXHJcblxyXG5cdFx0XHRcdHZhciB2QSwgdkIsIHZDO1xyXG5cdFx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRcdHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcclxuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xyXG5cdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdID0gdmVydGljZXNbIGZhY2UuYiBdLmNsb25lKCk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSB2ZXJ0aWNlc1sgZmFjZS5jIF0uY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZUZsYXRWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgZiwgZmwsIGZhY2U7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGksIGlsLCBmLCBmbCwgZmFjZTtcclxuXHJcblx0XHRcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cdFx0XHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcclxuXHRcdFx0Ly8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdXNlIHRlbXAgZ2VvbWV0cnkgdG8gY29tcHV0ZSBmYWNlIGFuZCB2ZXJ0ZXggbm9ybWFscyBmb3IgZWFjaCBtb3JwaFxyXG5cclxuXHRcdFx0dmFyIHRtcEdlbyA9IG5ldyBHZW9tZXRyeSgpO1xyXG5cdFx0XHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNyZWF0ZSBvbiBmaXJzdCBhY2Nlc3NcclxuXHJcblx0XHRcdFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xyXG5cdFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcclxuXHRcdFx0XHRcdHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlTm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFZlY3RvcjMoKSwgYjogbmV3IFZlY3RvcjMoKSwgYzogbmV3IFZlY3RvcjMoKSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF07XHJcblxyXG5cdFx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcclxuXHJcblx0XHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdFx0Ly8gY29tcHV0ZSBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRcdFx0XHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdFx0Ly8gc3RvcmUgbW9ycGggbm9ybWFsc1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRcdGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHJlc3RvcmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGQgPSAwO1xyXG5cdFx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGkgPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4LFxyXG5cdFx0XHRcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxyXG5cdFx0XHRcdHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXHJcblx0XHRcdFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRcdFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcclxuXHRcdFx0XHRmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcclxuXHRcdFx0XHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXHJcblx0XHRcdFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSxcclxuXHRcdFx0XHRjb2xvcnMxID0gdGhpcy5jb2xvcnMsXHJcblx0XHRcdFx0Y29sb3JzMiA9IGdlb21ldHJ5LmNvbG9ycztcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkgdmVydGV4Q29weS5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY29sb3JzXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29sb3JzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y29sb3JzMS5wdXNoKCBjb2xvcnMyWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlczJbIGkgXSwgZmFjZUNvcHksIG5vcm1hbCwgY29sb3IsXHJcblx0XHRcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcclxuXHRcdFx0XHRcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdFx0ZmFjZUNvcHkgPSBuZXcgRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcclxuXHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlQ29weS5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Q29sb3JzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xyXG5cdFx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcclxuXHJcblx0XHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1dnNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XHJcblxyXG5cdFx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcclxuXHJcblx0XHRcdGlmICggISAoIG1lc2ggJiYgbWVzaC5pc01lc2ggKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHRcdHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxyXG5cdFx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxyXG5cdFx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cclxuXHRcdCAqL1xyXG5cclxuXHRcdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxyXG5cdFx0XHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcclxuXHJcblx0XHRcdHZhciB2LCBrZXk7XHJcblx0XHRcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcclxuXHRcdFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XHJcblx0XHRcdHZhciBpLCBpbCwgZmFjZTtcclxuXHRcdFx0dmFyIGluZGljZXMsIGosIGpsO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0diA9IHRoaXMudmVydGljZXNbIGkgXTtcclxuXHRcdFx0XHRrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcclxuXHRcdFx0XHRcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcclxuXHRcdFx0XHRcdGNoYW5nZXNbIGkgXSA9IHVuaXF1ZS5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XHJcblx0XHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcclxuXHRcdFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cclxuXHRcdFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGZhY2UuYSA9IGNoYW5nZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdGZhY2UuYiA9IGNoYW5nZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcclxuXHRcdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxyXG5cdFx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcclxuXHJcblx0XHRcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xyXG5cdFx0XHR0aGlzLnZlcnRpY2VzID0gdW5pcXVlO1xyXG5cdFx0XHRyZXR1cm4gZGlmZjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNvcnRGYWNlc0J5TWF0ZXJpYWxJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuXHRcdFx0dmFyIGxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIHRhZyBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlc1sgaSBdLl9pZCA9IGk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzb3J0IGZhY2VzXHJcblxyXG5cdFx0XHRmdW5jdGlvbiBtYXRlcmlhbEluZGV4U29ydCggYSwgYiApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGEubWF0ZXJpYWxJbmRleCAtIGIubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VzLnNvcnQoIG1hdGVyaWFsSW5kZXhTb3J0ICk7XHJcblxyXG5cdFx0XHQvLyBzb3J0IHV2c1xyXG5cclxuXHRcdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdFx0dmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcclxuXHJcblx0XHRcdHZhciBuZXdVdnMxLCBuZXdVdnMyO1xyXG5cclxuXHRcdFx0aWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XHJcblx0XHRcdGlmICggdXZzMiAmJiB1dnMyLmxlbmd0aCA9PT0gbGVuZ3RoICkgbmV3VXZzMiA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaWQgPSBmYWNlc1sgaSBdLl9pZDtcclxuXHJcblx0XHRcdFx0aWYgKCBuZXdVdnMxICkgbmV3VXZzMS5wdXNoKCB1dnMxWyBpZCBdICk7XHJcblx0XHRcdFx0aWYgKCBuZXdVdnMyICkgbmV3VXZzMi5wdXNoKCB1dnMyWyBpZCBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG5ld1V2czEgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1V2czE7XHJcblx0XHRcdGlmICggbmV3VXZzMiApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gbmV3VXZzMjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHRcdHZlcnNpb246IDQuNSxcclxuXHRcdFx0XHRcdHR5cGU6ICdHZW9tZXRyeScsXHJcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxyXG5cclxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XHJcblx0XHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGZhY2VzID0gW107XHJcblx0XHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xyXG5cdFx0XHR2YXIgY29sb3JzID0gW107XHJcblx0XHRcdHZhciBjb2xvcnNIYXNoID0ge307XHJcblx0XHRcdHZhciB1dnMgPSBbXTtcclxuXHRcdFx0dmFyIHV2c0hhc2ggPSB7fTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0dmFyIGhhc01hdGVyaWFsID0gdHJ1ZTtcclxuXHRcdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcclxuXHRcdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xyXG5cdFx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XHJcblx0XHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xyXG5cdFx0XHRcdHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZVR5cGUgPSAwO1xyXG5cclxuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTsgLy8gaXNRdWFkXHJcblx0XHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xyXG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XHJcblx0XHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcclxuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcclxuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcclxuXHRcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xyXG5cdFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XHJcblx0XHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xyXG5cdFx0XHRcdGZhY2VzLnB1c2goIGZhY2UubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXHJcblx0XHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxyXG5cdFx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxyXG5cdFx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXHJcblx0XHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcclxuXHRcdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAxIF0gKSxcclxuXHRcdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxyXG5cdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbiApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0aWYgKCBub3JtYWxzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcclxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5vcm1hbHNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcclxuXHJcblx0XHRcdFx0dmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRcdGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xyXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XHJcblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRhdGEuZGF0YSA9IHt9O1xyXG5cclxuXHRcdFx0ZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XHJcblx0XHRcdGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcclxuXHRcdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XHJcblx0XHRcdGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8qXHJcblx0XHRcdCAvLyBIYW5kbGUgcHJpbWl0aXZlc1xyXG5cclxuXHRcdFx0IHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xyXG5cclxuXHRcdFx0IGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0IHZhciB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdCBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XHJcblxyXG5cdFx0XHQgfVxyXG5cclxuXHRcdFx0IHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XHJcblx0XHRcdCB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XHJcblx0XHRcdCByZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHQgfVxyXG5cclxuXHRcdFx0IHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHRcdFx0ICovXHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IEdlb21ldHJ5KCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgaWwsIGosIGpsLCBrLCBrbDtcclxuXHJcblx0XHRcdC8vIHJlc2V0XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0XHRcdHRoaXMuY29sb3JzID0gW107XHJcblx0XHRcdHRoaXMuZmFjZXMgPSBbXTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuXHRcdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcclxuXHRcdFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG5cdFx0XHR0aGlzLnNraW5JbmRpY2VzID0gW107XHJcblx0XHRcdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcclxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyBuYW1lXHJcblxyXG5cdFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcclxuXHJcblx0XHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdFx0dmFyIGNvbG9ycyA9IHNvdXJjZS5jb2xvcnM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHR2YXIgZmFjZXMgPSBzb3VyY2UuZmFjZXM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGZhY2UgdmVydGV4IHV2c1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gc291cmNlLmZhY2VWZXJ0ZXhVdnNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2ID0gdXZzWyBrIF07XHJcblxyXG5cdFx0XHRcdFx0XHR1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBtb3JwaCB0YXJnZXRzXHJcblxyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0ge307XHJcblx0XHRcdFx0bW9ycGhUYXJnZXQubmFtZSA9IG1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaFRhcmdldC52ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bW9ycGhUYXJnZXQudmVydGljZXMucHVzaCggbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXNbIGogXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbHNcclxuXHJcblx0XHRcdFx0aWYgKCBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXQubm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtb3JwaFRhcmdldC5ub3JtYWxzLnB1c2goIG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHNbIGogXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBtb3JwaCBub3JtYWxzXHJcblxyXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIG1vcnBoTm9ybWFsID0ge307XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRleCBub3JtYWxzXHJcblxyXG5cdFx0XHRcdGlmICggbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdG1vcnBoTm9ybWFsLnZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHNyY1ZlcnRleE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHNbIGogXTtcclxuXHRcdFx0XHRcdFx0dmFyIGRlc3RWZXJ0ZXhOb3JtYWwgPSB7fTtcclxuXHJcblx0XHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYSA9IHNyY1ZlcnRleE5vcm1hbC5hLmNsb25lKCk7XHJcblx0XHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYiA9IHNyY1ZlcnRleE5vcm1hbC5iLmNsb25lKCk7XHJcblx0XHRcdFx0XHRcdGRlc3RWZXJ0ZXhOb3JtYWwuYyA9IHNyY1ZlcnRleE5vcm1hbC5jLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRtb3JwaE5vcm1hbC52ZXJ0ZXhOb3JtYWxzLnB1c2goIGRlc3RWZXJ0ZXhOb3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZmFjZSBub3JtYWxzXHJcblxyXG5cdFx0XHRcdGlmICggbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaE5vcm1hbC5mYWNlTm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bW9ycGhOb3JtYWwuZmFjZU5vcm1hbHMucHVzaCggbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHNbIGogXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzLnB1c2goIG1vcnBoTm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBza2luIHdlaWdodHNcclxuXHJcblx0XHRcdHZhciBza2luV2VpZ2h0cyA9IHNvdXJjZS5za2luV2VpZ2h0cztcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2tpbiBpbmRpY2VzXHJcblxyXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBzb3VyY2Uuc2tpbkluZGljZXM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBza2luSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgaSBdLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxpbmUgZGlzdGFuY2VzXHJcblxyXG5cdFx0XHR2YXIgbGluZURpc3RhbmNlcyA9IHNvdXJjZS5saW5lRGlzdGFuY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gbGluZURpc3RhbmNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzLnB1c2goIGxpbmVEaXN0YW5jZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYm91bmRpbmcgYm94XHJcblxyXG5cdFx0XHR2YXIgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XHJcblxyXG5cdFx0XHRpZiAoIGJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJvdW5kaW5nIHNwaGVyZVxyXG5cclxuXHRcdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZmxhZ3NcclxuXHJcblx0XHRcdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gc291cmNlLmVsZW1lbnRzTmVlZFVwZGF0ZTtcclxuXHRcdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBzb3VyY2UudmVydGljZXNOZWVkVXBkYXRlO1xyXG5cdFx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBzb3VyY2UudXZzTmVlZFVwZGF0ZTtcclxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHNvdXJjZS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuXHRcdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gc291cmNlLmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHRcdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBzb3VyY2UubGluZURpc3RhbmNlc05lZWRVcGRhdGU7XHJcblx0XHRcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IHNvdXJjZS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcclxuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcclxuXHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xyXG5cdFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcclxuXHRcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xyXG5cclxuXHRcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHRcdHRoaXMudmVyc2lvbiA9IDA7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCAnbmVlZHNVcGRhdGUnLCB7XHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGlzQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxyXG5cclxuXHRcdHNldEFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIHRoaXMuaXRlbVNpemUgOiAwO1xyXG5cdFx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5keW5hbWljID0gdmFsdWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xyXG5cdFx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xyXG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xyXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBzb3VyY2Uubm9ybWFsaXplZDtcclxuXHJcblx0XHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xyXG5cdFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGNvbG9yID0gY29sb3JzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuXHRcdFx0XHRcdGNvbG9yID0gbmV3IENvbG9yKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IucjtcclxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYTtcclxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xyXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xyXG5cdFx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcclxuXHRcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XHJcblx0XHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xyXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xyXG5cdFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xyXG5cclxuXHRcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcclxuXHRcdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3I0KCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XHJcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XHJcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XHJcblx0XHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcclxuXHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XHJcblxyXG5cdFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XHJcblxyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcclxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XHJcblx0XHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0b25VcGxvYWQ6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gSW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50OEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIFVpbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdFVpbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50OEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG5cdH1cclxuXHJcblx0VWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuXHRVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gSW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG5cdH1cclxuXHJcblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5cdEludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDE2QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gVWludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRVaW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xyXG5cdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50MTZCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRJbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xyXG5cclxuXHR9XHJcblxyXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcblx0VWludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcclxuXHJcblx0XHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcclxuXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGU7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XHJcblxyXG5cdFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XHJcblxyXG5cdH1cclxuXHJcblx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XHJcblx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDY0QnVmZmVyQXR0cmlidXRlO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBEaXJlY3RHZW9tZXRyeSgpIHtcclxuXHJcblx0XHR0aGlzLmluZGljZXMgPSBbXTtcclxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcclxuXHRcdHRoaXMubm9ybWFscyA9IFtdO1xyXG5cdFx0dGhpcy5jb2xvcnMgPSBbXTtcclxuXHRcdHRoaXMudXZzID0gW107XHJcblx0XHR0aGlzLnV2czIgPSBbXTtcclxuXHJcblx0XHR0aGlzLmdyb3VwcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0ge307XHJcblxyXG5cdFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xyXG5cdFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuXHRcdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xyXG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGZsYWdzXHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBEaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGdyb3VwO1xyXG5cdFx0XHR2YXIgZ3JvdXBzID0gW107XHJcblx0XHRcdHZhciBtYXRlcmlhbEluZGV4ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0Ly8gbWF0ZXJpYWxzXHJcblxyXG5cdFx0XHRcdGlmICggZmFjZS5tYXRlcmlhbEluZGV4ICE9PSBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcclxuXHRcdFx0XHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGdyb3VwID0ge1xyXG5cdFx0XHRcdFx0XHRzdGFydDogaSAqIDMsXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcclxuXHRcdFx0XHRncm91cHMucHVzaCggZ3JvdXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XHJcblxyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xyXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2MiA9IGZhY2VWZXJ0ZXhVdnNbIDEgXSAmJiBmYWNlVmVydGV4VXZzWyAxIF0ubGVuZ3RoID4gMDtcclxuXHJcblx0XHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdFx0XHR2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb247XHJcblxyXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaSBdID0gW107XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldHMucG9zaXRpb24gPSBtb3JwaFRhcmdldHNQb3NpdGlvbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0c05vcm1hbDtcclxuXHJcblx0XHRcdGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNraW5zXHJcblxyXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcclxuXHRcdFx0dmFyIHNraW5XZWlnaHRzID0gZ2VvbWV0cnkuc2tpbldlaWdodHM7XHJcblxyXG5cdFx0XHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcclxuXHRcdFx0dmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGZhY2UuYSBdLCB2ZXJ0aWNlc1sgZmFjZS5iIF0sIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcclxuXHJcblx0XHRcdFx0XHR0aGlzLm5vcm1hbHMucHVzaCggbm9ybWFsLCBub3JtYWwsIG5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHJcblx0XHRcdFx0aWYgKCB2ZXJ0ZXhDb2xvcnMubGVuZ3RoID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIHZlcnRleENvbG9yc1sgMCBdLCB2ZXJ0ZXhDb2xvcnNbIDEgXSwgdmVydGV4Q29sb3JzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMudXZzLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdiAnLCBpICk7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyICcsIGkgKTtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMudXZzMi5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBqIF0udmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGogXS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc2tpbnNcclxuXHJcblx0XHRcdFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBmYWNlLmEgXSwgc2tpbkluZGljZXNbIGZhY2UuYiBdLCBza2luSW5kaWNlc1sgZmFjZS5jIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGhhc1NraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGZhY2UuYSBdLCBza2luV2VpZ2h0c1sgZmFjZS5iIF0sIHNraW5XZWlnaHRzWyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNvbXB1dGVHcm91cHMoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xyXG5cdFx0XHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xyXG5cdFx0XHR0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xyXG5cdFx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIGFycmF5TWF4KCBhcnJheSApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiAtIEluZmluaXR5O1xyXG5cclxuXHRcdHZhciBtYXggPSBhcnJheVsgMCBdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFycmF5WyBpIF0gPiBtYXggKSBtYXggPSBhcnJheVsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF4O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0dmFyIGJ1ZmZlckdlb21ldHJ5SWQgPSAxOyAvLyBCdWZmZXJHZW9tZXRyeSB1c2VzIG9kZCBudW1iZXJzIGFzIElkXHJcblxyXG5cdGZ1bmN0aW9uIEJ1ZmZlckdlb21ldHJ5KCkge1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogYnVmZmVyR2VvbWV0cnlJZCArPSAyIH0gKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSAnJztcclxuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5pbmRleCA9IG51bGw7XHJcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHRcdHRoaXMuZ3JvdXBzID0gW107XHJcblxyXG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xyXG5cclxuXHR9XHJcblxyXG5cdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBCdWZmZXJHZW9tZXRyeSxcclxuXHJcblx0XHRpc0J1ZmZlckdlb21ldHJ5OiB0cnVlLFxyXG5cclxuXHRcdGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbmRleDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlNYXgoIGluZGV4ICkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdGlmICggISAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCdWZmZXJBdHRyaWJ1dGUgKSAmJiAhICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xyXG5cdFx0XHRcdHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0QXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZW1vdmVBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkR3JvdXA6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdFx0dGhpcy5ncm91cHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRzdGFydDogc3RhcnQsXHJcblx0XHRcdFx0Y291bnQ6IGNvdW50LFxyXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5ncm91cHMgPSBbXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xyXG5cdFx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcclxuXHRcdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRcdGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbE1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBub3JtYWwgKTtcclxuXHRcdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHgtYXhpc1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBzY2FsZSBnZW9tZXRyeVxyXG5cclxuXHRcdFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBzY2FsZSggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xyXG5cclxuXHRcdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGNlbnRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcigpLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcclxuXHJcblx0XHRcdHJldHVybiBvZmZzZXQ7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5pc1BvaW50cyB8fCBvYmplY3QuaXNMaW5lICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcclxuXHRcdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIGxpbmVEaXN0YW5jZXMuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHRcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZGlyZWN0ID0gZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZGlyZWN0ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcclxuXHRcdFx0XHRkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcclxuXHRcdFx0XHRkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XHJcblx0XHRcdFx0ZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xyXG5cdFx0XHRcdGRpcmVjdC5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBkaXJlY3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xyXG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy51djtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApO1xyXG5cdFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUdyb3Vwcyggb2JqZWN0Lmdlb21ldHJ5ICk7XHJcblx0XHRcdFx0dGhpcy5ncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBEaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmZyb21EaXJlY3RHZW9tZXRyeSggZ2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0ZnJvbURpcmVjdEdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cy5sZW5ndGggKiAyICk7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1djInLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMyLCAyICkuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2czIgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBUeXBlQXJyYXkgPSBhcnJheU1heCggZ2VvbWV0cnkuaW5kaWNlcyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xyXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XHJcblx0XHRcdFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApLmNvcHlJbmRpY2VzQXJyYXkoIGdlb21ldHJ5LmluZGljZXMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ3JvdXBzXHJcblxyXG5cdFx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcclxuXHJcblx0XHRcdC8vIG1vcnBoc1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xyXG5cclxuXHRcdFx0XHRcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNraW5uaW5nXHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBza2luSW5kaWNlcyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2tpbldlaWdodHMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xyXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgYm94ID0gbmV3IEJveDMoKTtcclxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblxyXG5cdFx0XHRcdGlmICggcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xyXG5cclxuXHRcdFx0XHRcdGJveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0Ym94LmdldENlbnRlciggY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcclxuXHRcdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcclxuXHJcblx0XHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmVjdG9yLnggPSBwb3NpdGlvbi5nZXRYKCBpICk7XHJcblx0XHRcdFx0XHRcdHZlY3Rvci55ID0gcG9zaXRpb24uZ2V0WSggaSApO1xyXG5cdFx0XHRcdFx0XHR2ZWN0b3IueiA9IHBvc2l0aW9uLmdldFooIGkgKTtcclxuXHRcdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblx0XHRcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9ucy5sZW5ndGggKSwgMyApICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVzZXQgZXhpc3Rpbmcgbm9ybWFscyB0byB6ZXJvXHJcblxyXG5cdFx0XHRcdFx0dmFyIGFycmF5ID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YXJyYXlbIGkgXSA9IDA7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblxyXG5cdFx0XHRcdHZhciB2QSwgdkIsIHZDO1xyXG5cdFx0XHRcdHZhciBwQSA9IG5ldyBWZWN0b3IzKCksIHBCID0gbmV3IFZlY3RvcjMoKSwgcEMgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0Ly8gaW5kZXhlZCBlbGVtZW50c1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGdyb3Vwcy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XHJcblx0XHRcdFx0XHRcdHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcclxuXHRcdFx0XHRcdFx0XHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xyXG5cdFx0XHRcdFx0XHRcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCB2QSApO1xyXG5cdFx0XHRcdFx0XHRcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCB2QiApO1xyXG5cdFx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcclxuXHRcdFx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgXSArPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcclxuXHRcdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XHJcblx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xyXG5cdFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNCBdID0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggISAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZUFycmF5MVsgaiBdID0gYXR0cmlidXRlQXJyYXkyWyBpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXplTm9ybWFscygpIHtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlY3Rvci54ID0gbm9ybWFscy5nZXRYKCBpICk7XHJcblx0XHRcdFx0XHR2ZWN0b3IueSA9IG5vcm1hbHMuZ2V0WSggaSApO1xyXG5cdFx0XHRcdFx0dmVjdG9yLnogPSBub3JtYWxzLmdldFooIGkgKTtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFscy5zZXRYWVooIGksIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0dG9Ob25JbmRleGVkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHRcdHZhciBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XHJcblx0XHRcdFx0dmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XHJcblxyXG5cdFx0XHRcdHZhciBpbmRleCA9IDAsIGluZGV4MiA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeTIuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheTIsIGl0ZW1TaXplICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBnZW9tZXRyeTI7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBkYXRhID0ge1xyXG5cdFx0XHRcdG1ldGFkYXRhOiB7XHJcblx0XHRcdFx0XHR2ZXJzaW9uOiA0LjUsXHJcblx0XHRcdFx0XHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxyXG5cdFx0XHRcdFx0Z2VuZXJhdG9yOiAnQnVmZmVyR2VvbWV0cnkudG9KU09OJ1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cclxuXHJcblx0XHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcclxuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cdFx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XHJcblxyXG5cdFx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcclxuXHRcdFx0XHRcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0XHRhcnJheTogYXJyYXlcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XHJcblx0XHRcdFx0XHRpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxyXG5cdFx0XHRcdFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXHJcblx0XHRcdFx0XHRhcnJheTogYXJyYXksXHJcblx0XHRcdFx0XHRub3JtYWxpemVkOiBhdHRyaWJ1dGUubm9ybWFsaXplZFxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG5cclxuXHRcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xyXG5cdFx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxyXG5cdFx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0LypcclxuXHRcdFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXHJcblxyXG5cdFx0XHQgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XHJcblxyXG5cdFx0XHQgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHQgdmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0IGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdCB2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcclxuXHJcblx0XHRcdCB9XHJcblxyXG5cdFx0XHQgdmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcclxuXHRcdFx0IHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcclxuXHRcdFx0IHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0XHRcdCB9XHJcblxyXG5cdFx0XHQgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cdFx0XHQgKi9cclxuXHJcblx0XHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRcdHZhciBuYW1lLCBpLCBsO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXRcclxuXHJcblx0XHRcdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdFx0dGhpcy5ncm91cHMgPSBbXTtcclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xyXG5cclxuXHRcdFx0Ly8gbmFtZVxyXG5cclxuXHRcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XHJcblxyXG5cdFx0XHQvLyBpbmRleFxyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYXR0cmlidXRlc1xyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcclxuXHJcblx0XHRcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHRcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBzb3VyY2UubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yICggbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cdFx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGdyb3Vwc1xyXG5cclxuXHRcdFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJvdW5kaW5nIGJveFxyXG5cclxuXHRcdFx0dmFyIGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xyXG5cclxuXHRcdFx0aWYgKCBib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBib3VuZGluZyBzcGhlcmVcclxuXHJcblx0XHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZHJhdyByYW5nZVxyXG5cclxuXHRcdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xyXG5cdFx0XHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IHNvdXJjZS5kcmF3UmFuZ2UuY291bnQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICovXHJcblxyXG5cdC8vIEJveEdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIEJveEdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRkZXB0aDogZGVwdGgsXHJcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSApO1xyXG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Qm94R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0Qm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94R2VvbWV0cnk7XHJcblxyXG5cdC8vIEJveEJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdCb3hCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRkZXB0aDogZGVwdGgsXHJcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHdpZHRoID0gd2lkdGggfHwgMTtcclxuXHRcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xyXG5cdFx0ZGVwdGggPSBkZXB0aCB8fCAxO1xyXG5cclxuXHRcdC8vIHNlZ21lbnRzXHJcblxyXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xyXG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XHJcblx0XHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggZGVwdGhTZWdtZW50cyApIHx8IDE7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW107XHJcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgdXZzID0gW107XHJcblxyXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xyXG5cclxuXHRcdHZhciBudW1iZXJPZlZlcnRpY2VzID0gMDtcclxuXHRcdHZhciBncm91cFN0YXJ0ID0gMDtcclxuXHJcblx0XHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxyXG5cclxuXHRcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDAgKTsgLy8gcHhcclxuXHRcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDEgKTsgLy8gbnhcclxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAyICk7IC8vIHB5XHJcblx0XHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDMgKTsgLy8gbnlcclxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XHJcblx0XHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDUgKTsgLy8gbnpcclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdywgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdyaWRYLCBncmlkWSwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHRcdHZhciBzZWdtZW50V2lkdGggPSB3aWR0aCAvIGdyaWRYO1xyXG5cdFx0XHR2YXIgc2VnbWVudEhlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xyXG5cclxuXHRcdFx0dmFyIHdpZHRoSGFsZiA9IHdpZHRoIC8gMjtcclxuXHRcdFx0dmFyIGhlaWdodEhhbGYgPSBoZWlnaHQgLyAyO1xyXG5cdFx0XHR2YXIgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xyXG5cclxuXHRcdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcclxuXHRcdFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXhDb3VudGVyID0gMDtcclxuXHRcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xyXG5cclxuXHRcdFx0dmFyIGl4LCBpeTtcclxuXHJcblx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xyXG5cclxuXHRcdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHggPSBpeCAqIHNlZ21lbnRXaWR0aCAtIHdpZHRoSGFsZjtcclxuXHJcblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxyXG5cclxuXHRcdFx0XHRcdHZlY3RvclsgdSBdID0geCAqIHVkaXI7XHJcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IHkgKiB2ZGlyO1xyXG5cdFx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aEhhbGY7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXHJcblxyXG5cdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XHJcblxyXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSAwO1xyXG5cdFx0XHRcdFx0dmVjdG9yWyB2IF0gPSAwO1xyXG5cdFx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xyXG5cclxuXHRcdFx0XHRcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gbm9ybWFsIGJ1ZmZlclxyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHV2c1xyXG5cclxuXHRcdFx0XHRcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XHJcblx0XHRcdFx0XHR1dnMucHVzaCggMSAtICggaXkgLyBncmlkWSApICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY291bnRlcnNcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRcdC8vIDEuIHlvdSBuZWVkIHRocmVlIGluZGljZXMgdG8gZHJhdyBhIHNpbmdsZSBmYWNlXHJcblx0XHRcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXHJcblx0XHRcdC8vIDMuIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgc2l4ICgyKjMpIGluZGljZXMgcGVyIHNlZ21lbnRcclxuXHJcblx0XHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcclxuXHRcdFx0XHRcdHZhciBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0XHRcdHZhciBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdFx0dmFyIGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xyXG5cclxuXHRcdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBpbmNyZWFzZSBjb3VudGVyXHJcblxyXG5cdFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxyXG5cclxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIG1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xyXG5cclxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqL1xyXG5cclxuXHQvLyBQbGFuZUdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFBsYW5lR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHR3aWR0aDogd2lkdGgsXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRQbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVHZW9tZXRyeTtcclxuXHJcblx0Ly8gUGxhbmVCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBQbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcclxuXHJcblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0d2lkdGg6IHdpZHRoLFxyXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcclxuXHRcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcclxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXHJcblx0XHR9O1xyXG5cclxuXHRcdHdpZHRoID0gd2lkdGggfHwgMTtcclxuXHRcdGhlaWdodCA9IGhlaWdodCB8fCAxO1xyXG5cclxuXHRcdHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xyXG5cdFx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcclxuXHJcblx0XHR2YXIgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcclxuXHRcdHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcclxuXHJcblx0XHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xyXG5cdFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcclxuXHJcblx0XHR2YXIgc2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFg7XHJcblx0XHR2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcclxuXHJcblx0XHR2YXIgaXgsIGl5O1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xyXG5cdFx0dmFyIHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcclxuXHJcblx0XHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgLSB5LCAwICk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xyXG5cclxuXHRcdFx0XHR1dnMucHVzaCggaXggLyBncmlkWCApO1xyXG5cdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XHJcblx0XHRcdFx0dmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcclxuXHRcdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcclxuXHJcblx0XHRcdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRQbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKiAgY29sb3I6IDxoZXg+LFxyXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcblx0ICpcclxuXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcblx0ICpcclxuXHQgKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG5cdCAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcclxuXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG5cdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcblx0ICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuXHQgKlxyXG5cdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcblx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxyXG5cclxuXHRcdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcclxuXHRcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5hb01hcCA9IG51bGw7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xyXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaEJhc2ljTWF0ZXJpYWw7XHJcblxyXG5cdE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hCYXNpY01hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xyXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xyXG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICpcclxuXHQgKiBwYXJhbWV0ZXJzID0ge1xyXG5cdCAqICBkZWZpbmVzOiB7IFwibGFiZWxcIiA6IFwidmFsdWVcIiB9LFxyXG5cdCAqICB1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB2YWx1ZTogMS4wIH0sIFwicGFyYW1ldGVyMlwiOiB7IHZhbHVlMjogMiB9IH0sXHJcblx0ICpcclxuXHQgKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxyXG5cdCAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxyXG5cdCAqXHJcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgbGlnaHRzOiA8Ym9vbD4sXHJcblx0ICpcclxuXHQgKiAgc2tpbm5pbmc6IDxib29sPixcclxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcblx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmRlZmluZXMgPSB7fTtcclxuXHRcdHRoaXMudW5pZm9ybXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xyXG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxufSc7XHJcblxyXG5cdFx0dGhpcy5saW5ld2lkdGggPSAxO1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblxyXG5cdFx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcclxuXHRcdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXHJcblx0XHR0aGlzLmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xyXG5cclxuXHRcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBza2lubmluZyBhdHRyaWJ1dGUgc3RyZWFtc1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXHJcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSB7XHJcblx0XHRcdGRlcml2YXRpdmVzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xyXG5cdFx0XHRmcmFnRGVwdGg6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGZyYWdtZW50IGRlcHRoIHZhbHVlc1xyXG5cdFx0XHRkcmF3QnVmZmVyczogZmFsc2UsIC8vIHNldCB0byB1c2UgZHJhdyBidWZmZXJzXHJcblx0XHRcdHNoYWRlclRleHR1cmVMT0Q6IGZhbHNlIC8vIHNldCB0byB1c2Ugc2hhZGVyIHRleHR1cmUgTE9EXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxyXG5cdFx0Ly8gdXNlIHRoZXNlIGRlZmF1bHQgdmFsdWVzIGluIFdlYkdMLiBUaGlzIGF2b2lkcyBlcnJvcnMgd2hlbiBidWZmZXIgZGF0YSBpcyBtaXNzaW5nLlxyXG5cdFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xyXG5cdFx0XHQnY29sb3InOiBbIDEsIDEsIDEgXSxcclxuXHRcdFx0J3V2JzogWyAwLCAwIF0sXHJcblx0XHRcdCd1djInOiBbIDAsIDAgXVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZGVyTWF0ZXJpYWw7XHJcblxyXG5cdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xyXG5cdFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcclxuXHJcblx0XHR0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcclxuXHJcblx0XHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XHJcblxyXG5cdFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xyXG5cdFx0dGhpcy5jbGlwcGluZyA9IHNvdXJjZS5jbGlwcGluZztcclxuXHJcblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcclxuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcclxuXHJcblx0XHR0aGlzLmV4dGVuc2lvbnMgPSBzb3VyY2UuZXh0ZW5zaW9ucztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IE1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuXHRcdGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xyXG5cdFx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcclxuXHRcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIFJheS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcclxuXHRcdFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcclxuXHJcblx0XHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcclxuXHRcdFx0dGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bG9va0F0OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCB2ICkuc3ViKCB0aGlzLm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmVjYXN0KCB0ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSByZXN1bHQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcclxuXHJcblx0XHRcdFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgc2VnQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIHNlZ0RpciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVNxVG9TZWdtZW50KCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcclxuXHJcblx0XHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZURpc3RSYXlTZWdtZW50LmhcclxuXHRcdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxyXG5cdFx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXHJcblx0XHRcdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcclxuXHRcdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcclxuXHRcdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XHJcblxyXG5cdFx0XHRcdHNlZ0NlbnRlci5jb3B5KCB2MCApLmFkZCggdjEgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblx0XHRcdFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHRcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xyXG5cclxuXHRcdFx0XHR2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcclxuXHRcdFx0XHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xyXG5cdFx0XHRcdHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0XHRcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xyXG5cdFx0XHRcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xyXG5cdFx0XHRcdHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xyXG5cdFx0XHRcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcclxuXHJcblx0XHRcdFx0aWYgKCBkZXQgPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cclxuXHJcblx0XHRcdFx0XHRzMCA9IGEwMSAqIGIxIC0gYjA7XHJcblx0XHRcdFx0XHRzMSA9IGEwMSAqIGIwIC0gYjE7XHJcblx0XHRcdFx0XHRleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzMCA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzMSA+PSAtIGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBzMSA8PSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDBcclxuXHRcdFx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcclxuXHRcdFx0XHRcdFx0XHRcdHMwICo9IGludkRldDtcclxuXHRcdFx0XHRcdFx0XHRcdHMxICo9IGludkRldDtcclxuXHRcdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcclxuXHRcdFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA1XHJcblxyXG5cdFx0XHRcdFx0XHRcdHMxID0gLSBzZWdFeHRlbnQ7XHJcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggczEgPD0gLSBleHREZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XHJcblxyXG5cdFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XHJcblx0XHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcclxuXHJcblx0XHRcdFx0XHRcdFx0czAgPSAwO1xyXG5cdFx0XHRcdFx0XHRcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcclxuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDJcclxuXHJcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcclxuXHRcdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xyXG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIFJheSBhbmQgc2VnbWVudCBhcmUgcGFyYWxsZWwuXHJcblxyXG5cdFx0XHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xyXG5cdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xyXG5cdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcclxuXHJcblx0XHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gc3FyRGlzdDtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RTcGhlcmUoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XHJcblx0XHRcdFx0dmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHRcdFx0XHR2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XHJcblx0XHRcdFx0dmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcclxuXHJcblx0XHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdFx0dmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XHJcblxyXG5cdFx0XHRcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXHJcblx0XHRcdFx0dmFyIHQwID0gdGNhIC0gdGhjO1xyXG5cclxuXHRcdFx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXHJcblx0XHRcdFx0dmFyIHQxID0gdGNhICsgdGhjO1xyXG5cclxuXHRcdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcclxuXHRcdFx0XHRpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XHJcblx0XHRcdFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxyXG5cdFx0XHRcdC8vIGluIG9yZGVyIHRvIGFsd2F5cyByZXR1cm4gYW4gaW50ZXJzZWN0IHBvaW50IHRoYXQgaXMgaW4gZnJvbnQgb2YgdGhlIHJheS5cclxuXHRcdFx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xyXG5cclxuXHRcdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcclxuXHJcblx0XHRcdHJldHVybiB0ID49IDAgPyB0IDogbnVsbDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XHJcblxyXG5cdFx0XHRpZiAoIHQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XHJcblxyXG5cdFx0XHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0XHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdEJveDogZnVuY3Rpb24gKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xyXG5cclxuXHRcdFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcclxuXHRcdFx0XHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXHJcblx0XHRcdFx0aW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xyXG5cclxuXHRcdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xyXG5cclxuXHRcdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cdFx0XHRcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblx0XHRcdFx0dG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGludmRpcnkgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xyXG5cdFx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcclxuXHRcdFx0XHR0eW1heCA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0Ly8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxyXG5cdFx0XHQvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXHJcblxyXG5cdFx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xyXG5cclxuXHRcdFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcclxuXHJcblx0XHRcdGlmICggaW52ZGlyeiA+PSAwICkge1xyXG5cclxuXHRcdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XHJcblx0XHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xyXG5cdFx0XHRcdHR6bWF4ID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xyXG5cclxuXHRcdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcclxuXHJcblx0XHRcdC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcclxuXHJcblx0XHRcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVyc2VjdHNCb3g6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNCb3goIGJveCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSApKCksXHJcblxyXG5cdFx0aW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxyXG5cdFx0XHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBlZGdlMSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBlZGdlMiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlSW50clJheTNUcmlhbmdsZTMuaFxyXG5cclxuXHRcdFx0XHRlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcblx0XHRcdFx0ZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xyXG5cdFx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xyXG5cclxuXHRcdFx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcclxuXHRcdFx0XHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XHJcblx0XHRcdFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXHJcblx0XHRcdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXHJcblx0XHRcdFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcclxuXHRcdFx0XHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcclxuXHRcdFx0XHR2YXIgc2lnbjtcclxuXHJcblx0XHRcdFx0aWYgKCBEZE4gPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRzaWduID0gMTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRzaWduID0gLSAxO1xyXG5cdFx0XHRcdFx0RGROID0gLSBEZE47XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGlmZi5zdWJWZWN0b3JzKCB0aGlzLm9yaWdpbiwgYSApO1xyXG5cdFx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcclxuXHJcblx0XHRcdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0XHRpZiAoIERkUXhFMiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcclxuXHJcblx0XHRcdFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0XHRpZiAoIERkRTF4USA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0XHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxyXG5cdFx0XHRcdHZhciBRZE4gPSAtIHNpZ24gKiBkaWZmLmRvdCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cclxuXHRcdFx0XHRpZiAoIFFkTiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xyXG5cclxuXHRcdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XHJcblx0XHRcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4NCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIExpbmUzKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHRcdHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBMaW5lMy5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0XHRcdHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcclxuXHRcdFx0dGhpcy5lbmQuY29weSggZW5kICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHRcdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkZWx0YTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0UCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBzdGFydEVuZCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xyXG5cclxuXHRcdFx0XHRzdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcclxuXHRcdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xyXG5cclxuXHRcdFx0XHR2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xyXG5cdFx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xyXG5cclxuXHRcdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcclxuXHJcblx0XHRcdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gX01hdGguY2xhbXAoIHQsIDAsIDEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdDtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKTtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0dGhpcy5zdGFydC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0XHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlcXVhbHM6IGZ1bmN0aW9uICggbGluZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFRyaWFuZ2xlKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMuYyA9ICggYyAhPT0gdW5kZWZpbmVkICkgPyBjIDogbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBUcmlhbmdsZSwge1xyXG5cclxuXHRcdG5vcm1hbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWwoIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdFx0XHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XHJcblx0XHRcdFx0cmVzdWx0LmNyb3NzKCB2MCApO1xyXG5cclxuXHRcdFx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcclxuXHRcdFx0XHRpZiAoIHJlc3VsdExlbmd0aFNxID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdC8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXHJcblx0XHQvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxyXG5cdFx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHRcdFx0djEuc3ViVmVjdG9ycyggYiwgYSApO1xyXG5cdFx0XHRcdHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XHJcblxyXG5cdFx0XHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuXHRcdFx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XHJcblx0XHRcdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xyXG5cdFx0XHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuXHRcdFx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XHJcblxyXG5cdFx0XHRcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxyXG5cdFx0XHRcdGlmICggZGVub20gPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XHJcblx0XHRcdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcclxuXHRcdFx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xyXG5cdFx0XHRcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XHJcblxyXG5cdFx0XHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIHYxICk7XHJcblxyXG5cdFx0XHRcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpXHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggVHJpYW5nbGUucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmEuY29weSggYSApO1xyXG5cdFx0XHR0aGlzLmIuY29weSggYiApO1xyXG5cdFx0XHR0aGlzLmMuY29weSggYyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XHJcblx0XHRcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcclxuXHRcdFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHRcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XHJcblx0XHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XHJcblx0XHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFyZWE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gYXJlYSgpIHtcclxuXHJcblx0XHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcclxuXHRcdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSxcclxuXHJcblx0XHRtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHJldHVybiBUcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgUGxhbmUoKTtcclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgcGxhbmUgPSBuZXcgUGxhbmUoKTtcclxuXHRcdFx0dmFyIGVkZ2VMaXN0ID0gWyBuZXcgTGluZTMoKSwgbmV3IExpbmUzKCksIG5ldyBMaW5lMygpIF07XHJcblx0XHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XHJcblxyXG5cdFx0XHRcdC8vIHByb2plY3QgdGhlIHBvaW50IG9udG8gdGhlIHBsYW5lIG9mIHRoZSB0cmlhbmdsZVxyXG5cclxuXHRcdFx0XHRwbGFuZS5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcclxuXHRcdFx0XHRwbGFuZS5wcm9qZWN0UG9pbnQoIHBvaW50LCBwcm9qZWN0ZWRQb2ludCApO1xyXG5cclxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcHJvamVjdGlvbiBsaWVzIHdpdGhpbiB0aGUgdHJpYW5nbGVcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLmNvbnRhaW5zUG9pbnQoIHByb2plY3RlZFBvaW50ICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaWYgc28sIHRoaXMgaXMgdGhlIGNsb3Nlc3QgcG9pbnRcclxuXHJcblx0XHRcdFx0XHRyZXN1bHQuY29weSggcHJvamVjdGVkUG9pbnQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBpZiBub3QsIHRoZSBwb2ludCBmYWxscyBvdXRzaWRlIHRoZSB0cmlhbmdsZS4gdGhlIHJlc3VsdCBpcyB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgdHJpYW5nbGUncyBlZGdlcyBvciB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0XHRcdGVkZ2VMaXN0WyAwIF0uc2V0KCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cdFx0XHRcdFx0ZWRnZUxpc3RbIDEgXS5zZXQoIHRoaXMuYiwgdGhpcy5jICk7XHJcblx0XHRcdFx0XHRlZGdlTGlzdFsgMiBdLnNldCggdGhpcy5jLCB0aGlzLmEgKTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlZGdlTGlzdC5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlZGdlTGlzdFsgaSBdLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHByb2plY3RlZFBvaW50LCB0cnVlLCBjbG9zZXN0UG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHByb2plY3RlZFBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCBjbG9zZXN0UG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cmVzdWx0LmNvcHkoIGNsb3Nlc3RQb2ludCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCksXHJcblxyXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2gnO1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblxyXG5cdFx0dGhpcy5kcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0TWVzaC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBNZXNoLFxyXG5cclxuXHRcdGlzTWVzaDogdHJ1ZSxcclxuXHJcblx0XHRzZXREcmF3TW9kZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuZHJhd01vZGUgPSB2YWx1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLmRyYXdNb2RlID0gc291cmNlLmRyYXdNb2RlO1xyXG5cclxuXHRcdFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlTW9ycGhUYXJnZXRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0XHR2YXIgbSwgbWwsIG5hbWU7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XHJcblx0XHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyggbW9ycGhBdHRyaWJ1dGVzICk7XHJcblxyXG5cdFx0XHRcdGlmICgga2V5cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sga2V5c1sgMCBdIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRuYW1lID0gbW9ycGhBdHRyaWJ1dGVbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIG1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XHJcblx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG5hbWUgPSBtb3JwaFRhcmdldHNbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xyXG5cdFx0XHRcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0XHR2YXIgcmF5ID0gbmV3IFJheSgpO1xyXG5cdFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG5cclxuXHRcdFx0dmFyIHZBID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIHZDID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciB0ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciB0ZW1wQiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciB0ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdXZBID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdFx0dmFyIHV2QiA9IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdFx0dmFyIGJhcnljb29yZCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XHJcblxyXG5cdFx0XHRcdFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHAxLCBwMiwgcDMsIGJhcnljb29yZCApO1xyXG5cclxuXHRcdFx0XHR1djEubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC54ICk7XHJcblx0XHRcdFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xyXG5cdFx0XHRcdHV2My5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnogKTtcclxuXHJcblx0XHRcdFx0dXYxLmFkZCggdXYyICkuYWRkKCB1djMgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGludGVyc2VjdDtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcclxuXHRcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcclxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdFx0dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGEgKTtcclxuXHRcdFx0XHR2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYiApO1xyXG5cdFx0XHRcdHZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBjICk7XHJcblxyXG5cdFx0XHRcdHZhciBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCBvYmplY3QubWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCB2QSwgdkIsIHZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHV2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XHJcblx0XHRcdFx0XHRcdHV2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYiApO1xyXG5cdFx0XHRcdFx0XHR1dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGMgKTtcclxuXHJcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgdkEsIHZCLCB2QywgdXZBLCB1dkIsIHV2QyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBGYWNlMyggYSwgYiwgYywgVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcclxuXHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3Rpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XHJcblx0XHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0Ly8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJheS5pbnRlcnNlY3RzQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgaW50ZXJzZWN0aW9uO1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEsIGIsIGM7XHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdFx0XHR2YXIgdXYgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnV2O1xyXG5cdFx0XHRcdFx0dmFyIGksIGw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGluZGV4LmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRhID0gaW5kZXguZ2V0WCggaSApO1xyXG5cdFx0XHRcdFx0XHRcdGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xyXG5cdFx0XHRcdFx0XHRcdGMgPSBpbmRleC5nZXRYKCBpICsgMiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKCBpIC8gMyApOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gaW5kaWNlcyBidWZmZXIgc2VtYW50aWNzXHJcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YSA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YiA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0XHRcdGMgPSBpICsgMjtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uaW5kZXggPSBhOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3NcclxuXHRcdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGZ2QSwgZnZCLCBmdkM7XHJcblx0XHRcdFx0XHR2YXIgaXNNdWx0aU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0XHRcdFx0dmFyIHV2cztcclxuXHJcblx0XHRcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHRcdFx0XHRcdGlmICggZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkgdXZzID0gZmFjZVZlcnRleFV2cztcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBmIF07XHJcblx0XHRcdFx0XHRcdHZhciBmYWNlTWF0ZXJpYWwgPSBpc011bHRpTWF0ZXJpYWwgPyBtYXRlcmlhbFsgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGZ2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0ZnZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2QS5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHR2Qi5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdFx0XHR2Qy5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGZ2QSApLCBpbmZsdWVuY2UgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGZ2QiApLCBpbmZsdWVuY2UgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR2QS5hZGQoIGZ2QSApO1xyXG5cdFx0XHRcdFx0XHRcdHZCLmFkZCggZnZCICk7XHJcblx0XHRcdFx0XHRcdFx0dkMuYWRkKCBmdkMgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZnZBID0gdkE7XHJcblx0XHRcdFx0XHRcdFx0ZnZCID0gdkI7XHJcblx0XHRcdFx0XHRcdFx0ZnZDID0gdkM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggdGhpcywgZmFjZU1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgZnZBLCBmdkIsIGZ2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHV2cyAmJiB1dnNbIGYgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdXZzX2YgPSB1dnNbIGYgXTtcclxuXHRcdFx0XHRcdFx0XHRcdHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XHJcblx0XHRcdFx0XHRcdFx0XHR1dkIuY29weSggdXZzX2ZbIDEgXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0dXZDLmNvcHkoIHV2c19mWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XHJcblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpICksXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gV2ViR0xCYWNrZ3JvdW5kKCByZW5kZXJlciwgc3RhdGUsIGdlb21ldHJpZXMsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcclxuXHJcblx0XHR2YXIgY2xlYXJDb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcclxuXHRcdHZhciBjbGVhckFscGhhID0gMDtcclxuXHJcblx0XHR2YXIgcGxhbmVDYW1lcmEsIHBsYW5lTWVzaDtcclxuXHRcdHZhciBib3hNZXNoO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlciggcmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgZm9yY2VDbGVhciApIHtcclxuXHJcblx0XHRcdHZhciBiYWNrZ3JvdW5kID0gc2NlbmUuYmFja2dyb3VuZDtcclxuXHJcblx0XHRcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yICkge1xyXG5cclxuXHRcdFx0XHRzZXRDbGVhciggYmFja2dyb3VuZCwgMSApO1xyXG5cdFx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJlci5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuY2xlYXIoIHJlbmRlcmVyLmF1dG9DbGVhckNvbG9yLCByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCwgcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBib3hNZXNoID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ym94TWVzaCA9IG5ldyBNZXNoKFxyXG5cdFx0XHRcdFx0XHRuZXcgQm94QnVmZmVyR2VvbWV0cnkoIDEsIDEsIDEgKSxcclxuXHRcdFx0XHRcdFx0bmV3IFNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRcdFx0XHRcdFx0dW5pZm9ybXM6IFNoYWRlckxpYi5jdWJlLnVuaWZvcm1zLFxyXG5cdFx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogU2hhZGVyTGliLmN1YmUudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS5mcmFnbWVudFNoYWRlcixcclxuXHRcdFx0XHRcdFx0XHRzaWRlOiBCYWNrU2lkZSxcclxuXHRcdFx0XHRcdFx0XHRkZXB0aFRlc3Q6IHRydWUsXHJcblx0XHRcdFx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0Zm9nOiBmYWxzZVxyXG5cdFx0XHRcdFx0XHR9IClcclxuXHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0Ym94TWVzaC5nZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdub3JtYWwnICk7XHJcblx0XHRcdFx0XHRib3hNZXNoLmdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ3V2JyApO1xyXG5cclxuXHRcdFx0XHRcdGJveE1lc2gub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cmllcy51cGRhdGUoIGJveE1lc2guZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRib3hNZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnRDdWJlLnZhbHVlID0gYmFja2dyb3VuZDtcclxuXHJcblx0XHRcdFx0cmVuZGVyTGlzdC5wdXNoKCBib3hNZXNoLCBib3hNZXNoLmdlb21ldHJ5LCBib3hNZXNoLm1hdGVyaWFsLCAwLCBudWxsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBsYW5lQ2FtZXJhID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0cGxhbmVDYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDEsIDEsIDEsIC0gMSwgMCwgMSApO1xyXG5cclxuXHRcdFx0XHRcdHBsYW5lTWVzaCA9IG5ldyBNZXNoKFxyXG5cdFx0XHRcdFx0XHRuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSggMiwgMiApLFxyXG5cdFx0XHRcdFx0XHRuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIGZvZzogZmFsc2UgfSApXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJpZXMudXBkYXRlKCBwbGFuZU1lc2guZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwbGFuZU1lc2gubWF0ZXJpYWwubWFwID0gYmFja2dyb3VuZDtcclxuXHJcblx0XHRcdFx0Ly8gVE9ETyBQdXNoIHRoaXMgdG8gcmVuZGVyTGlzdFxyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHBsYW5lQ2FtZXJhLCBudWxsLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgcGxhbmVNZXNoLCBudWxsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNldENsZWFyKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBhbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRnZXRDbGVhckNvbG9yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjbGVhckNvbG9yO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0XHRcdGNsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xyXG5cdFx0XHRcdGNsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xyXG5cdFx0XHRcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRnZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjbGVhckFscGhhO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0Q2xlYXJBbHBoYTogZnVuY3Rpb24gKCBhbHBoYSApIHtcclxuXHJcblx0XHRcdFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xyXG5cdFx0XHRcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZW5kZXI6IHJlbmRlclxyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XHJcblxyXG5cdFx0aWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGEucHJvZ3JhbSAmJiBiLnByb2dyYW0gJiYgYS5wcm9ncmFtICE9PSBiLnByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5wcm9ncmFtLmlkIC0gYi5wcm9ncmFtLmlkO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQ7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS56IC0gYi56O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XHJcblxyXG5cdFx0fSBpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlckxpc3QoKSB7XHJcblxyXG5cdFx0dmFyIHJlbmRlckl0ZW1zID0gW107XHJcblx0XHR2YXIgcmVuZGVySXRlbXNJbmRleCA9IDA7XHJcblxyXG5cdFx0dmFyIG9wYXF1ZSA9IFtdO1xyXG5cdFx0dmFyIHRyYW5zcGFyZW50ID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcclxuXHJcblx0XHRcdHJlbmRlckl0ZW1zSW5kZXggPSAwO1xyXG5cclxuXHRcdFx0b3BhcXVlLmxlbmd0aCA9IDA7XHJcblx0XHRcdHRyYW5zcGFyZW50Lmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCB6LCBncm91cCApIHtcclxuXHJcblx0XHRcdHZhciByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbIHJlbmRlckl0ZW1zSW5kZXggXTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVySXRlbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJJdGVtID0ge1xyXG5cdFx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcclxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0LFxyXG5cdFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cdFx0XHRcdFx0cHJvZ3JhbTogbWF0ZXJpYWwucHJvZ3JhbSxcclxuXHRcdFx0XHRcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXHJcblx0XHRcdFx0XHR6OiB6LFxyXG5cdFx0XHRcdFx0Z3JvdXA6IGdyb3VwXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmVuZGVySXRlbXNbIHJlbmRlckl0ZW1zSW5kZXggXSA9IHJlbmRlckl0ZW07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xyXG5cdFx0XHRcdHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xyXG5cdFx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHRcdFx0XHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0cmVuZGVySXRlbS5wcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbTtcclxuXHRcdFx0XHRyZW5kZXJJdGVtLnJlbmRlck9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xyXG5cdFx0XHRcdHJlbmRlckl0ZW0ueiA9IHo7XHJcblx0XHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0KCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSA/IHRyYW5zcGFyZW50IDogb3BhcXVlICkucHVzaCggcmVuZGVySXRlbSApO1xyXG5cclxuXHRcdFx0cmVuZGVySXRlbXNJbmRleCArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc29ydCgpIHtcclxuXHJcblx0XHRcdGlmICggb3BhcXVlLmxlbmd0aCA+IDEgKSBvcGFxdWUuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcclxuXHRcdFx0aWYgKCB0cmFuc3BhcmVudC5sZW5ndGggPiAxICkgdHJhbnNwYXJlbnQuc29ydCggcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG9wYXF1ZTogb3BhcXVlLFxyXG5cdFx0XHR0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQsXHJcblxyXG5cdFx0XHRpbml0OiBpbml0LFxyXG5cdFx0XHRwdXNoOiBwdXNoLFxyXG5cclxuXHRcdFx0c29ydDogc29ydFxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlckxpc3RzKCkge1xyXG5cclxuXHRcdHZhciBsaXN0cyA9IHt9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldCggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdHZhciBoYXNoID0gc2NlbmUuaWQgKyAnLCcgKyBjYW1lcmEuaWQ7XHJcblx0XHRcdHZhciBsaXN0ID0gbGlzdHNbIGhhc2ggXTtcclxuXHJcblx0XHRcdGlmICggbGlzdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyTGlzdHM6JywgaGFzaCApO1xyXG5cclxuXHRcdFx0XHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xyXG5cdFx0XHRcdGxpc3RzWyBoYXNoIF0gPSBsaXN0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGxpc3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0XHRsaXN0cyA9IHt9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRnZXQ6IGdldCxcclxuXHRcdFx0ZGlzcG9zZTogZGlzcG9zZVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggYlsgMSBdICkgLSBNYXRoLmFicyggYVsgMSBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gV2ViR0xNb3JwaHRhcmdldHMoIGdsICkge1xyXG5cclxuXHRcdHZhciBpbmZsdWVuY2VzTGlzdCA9IHt9O1xyXG5cdFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKTtcclxuXHJcblx0XHRmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBwcm9ncmFtICkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xyXG5cclxuXHRcdFx0dmFyIGxlbmd0aCA9IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0dmFyIGluZmx1ZW5jZXMgPSBpbmZsdWVuY2VzTGlzdFsgZ2VvbWV0cnkuaWQgXTtcclxuXHJcblx0XHRcdGlmICggaW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbml0aWFsaXNlIGxpc3RcclxuXHJcblx0XHRcdFx0aW5mbHVlbmNlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0aW5mbHVlbmNlc1sgaSBdID0gWyBpLCAwIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5mbHVlbmNlc0xpc3RbIGdlb21ldHJ5LmlkIF0gPSBpbmZsdWVuY2VzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbDtcclxuXHJcblx0XHRcdC8vIFJlbW92ZSBjdXJyZW50IG1vcnBoQXR0cmlidXRlc1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZmx1ZW5jZVsgMSBdICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSApO1xyXG5cdFx0XHRcdFx0aWYgKCBtb3JwaE5vcm1hbHMgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENvbGxlY3QgaW5mbHVlbmNlc1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpbmZsdWVuY2VbIDAgXSA9IGk7XHJcblx0XHRcdFx0aW5mbHVlbmNlWyAxIF0gPSBvYmplY3RJbmZsdWVuY2VzWyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpbmZsdWVuY2VzLnNvcnQoIGFic051bWVyaWNhbFNvcnQgKTtcclxuXHJcblx0XHRcdC8vIEFkZCBtb3JwaEF0dHJpYnV0ZXNcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IGluZmx1ZW5jZVsgMCBdO1xyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gaW5mbHVlbmNlWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhUYXJnZXRzWyBpbmRleCBdICk7XHJcblx0XHRcdFx0XHRcdGlmICggbW9ycGhOb3JtYWxzICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhOb3JtYWxzWyBpbmRleCBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKCBnbCwgJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsIG1vcnBoSW5mbHVlbmNlcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cclxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcclxuXHJcblx0XHR2YXIgbW9kZTtcclxuXHJcblx0XHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdG1vZGUgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHR5cGUsIGJ5dGVzUGVyRWxlbWVudDtcclxuXHJcblx0XHRmdW5jdGlvbiBzZXRJbmRleCggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gdmFsdWUudHlwZTtcclxuXHRcdFx0Ynl0ZXNQZXJFbGVtZW50ID0gdmFsdWUuYnl0ZXNQZXJFbGVtZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZW5kZXIoIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHRcdGdsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50ICk7XHJcblxyXG5cdFx0XHRpbmZvUmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xyXG5cclxuXHRcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcclxuXHRcdFx0ZWxzZSBpZiAoIG1vZGUgPT09IGdsLlBPSU5UUyApIGluZm9SZW5kZXIucG9pbnRzICs9IGNvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuXHRcdFx0aW5mb1JlbmRlci5jYWxscyArKztcclxuXHRcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xyXG5cclxuXHRcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xyXG5cdFx0XHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xyXG5cdFx0dGhpcy5zZXRJbmRleCA9IHNldEluZGV4O1xyXG5cdFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0XHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcclxuXHJcblx0XHR2YXIgbW9kZTtcclxuXHJcblx0XHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdG1vZGUgPSB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XHJcblxyXG5cdFx0XHRnbC5kcmF3QXJyYXlzKCBtb2RlLCBzdGFydCwgY291bnQgKTtcclxuXHJcblx0XHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XHJcblxyXG5cdFx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xyXG5cdFx0XHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gY291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIHN0YXJ0LCBjb3VudCApIHtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBwb3NpdGlvbi5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHRjb3VudCA9IHBvc2l0aW9uLmRhdGEuY291bnQ7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgc3RhcnQsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW5mb1JlbmRlci5jYWxscyArKztcclxuXHRcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xyXG5cclxuXHRcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xyXG5cdFx0XHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xyXG5cdFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XHJcblx0XHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoIGdsLCBhdHRyaWJ1dGVzLCBpbmZvTWVtb3J5ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyaWVzID0ge307XHJcblx0XHR2YXIgd2lyZWZyYW1lQXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcclxuXHRcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcclxuXHJcblx0XHRcdGlmICggYnVmZmVyZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZXMucmVtb3ZlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gYnVmZmVyZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xyXG5cclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG5cdFx0XHQvLyBUT0RPIFJlbW92ZSBkdXBsaWNhdGUgY29kZVxyXG5cclxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGdlb21ldHJ5LmlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0YXR0cmlidXRlcy5yZW1vdmUoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRcdGRlbGV0ZSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlc1sgYnVmZmVyZ2VvbWV0cnkuaWQgXTtcclxuXHJcblx0XHRcdGlmICggYXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGVzLnJlbW92ZSggYXR0cmlidXRlICk7XHJcblx0XHRcdFx0ZGVsZXRlIHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGJ1ZmZlcmdlb21ldHJ5LmlkIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0aW5mb01lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXQoIG9iamVjdCwgZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBidWZmZXJnZW9tZXRyeSApIHJldHVybiBidWZmZXJnZW9tZXRyeTtcclxuXHJcblx0XHRcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gYnVmZmVyZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRpbmZvTWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdFx0XHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZSggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZXMudXBkYXRlKCBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBtb3JwaCB0YXJnZXRzXHJcblxyXG5cdFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgKSByZXR1cm4gYXR0cmlidXRlO1xyXG5cclxuXHRcdFx0dmFyIGluZGljZXMgPSBbXTtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeUluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGEgPSBhcnJheVsgaSArIDAgXTtcclxuXHRcdFx0XHRcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XHJcblx0XHRcdFx0XHR2YXIgYyA9IGFycmF5WyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgYXJyYXkgPSBnZW9tZXRyeUF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9IGkgKyAwO1xyXG5cdFx0XHRcdFx0dmFyIGIgPSBpICsgMTtcclxuXHRcdFx0XHRcdHZhciBjID0gaSArIDI7XHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcclxuXHJcblx0XHRcdGF0dHJpYnV0ZSA9IG5ldyAoIGFycmF5TWF4KCBpbmRpY2VzICkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICk7XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGVzLnVwZGF0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xyXG5cclxuXHRcdFx0d2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXSA9IGF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdHJldHVybiBhdHRyaWJ1dGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRnZXQ6IGdldCxcclxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXHJcblxyXG5cdFx0XHRnZXRXaXJlZnJhbWVBdHRyaWJ1dGU6IGdldFdpcmVmcmFtZUF0dHJpYnV0ZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gVW5pZm9ybXNDYWNoZSgpIHtcclxuXHJcblx0XHR2YXIgbGlnaHRzID0ge307XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCBsaWdodCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoKSxcclxuXHJcblx0XHRcdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxyXG5cdFx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcclxuXHRcdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1Nwb3RMaWdodCc6XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zID0ge1xyXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXHJcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXHJcblx0XHRcdFx0XHRcdFx0Y29uZUNvczogMCxcclxuXHRcdFx0XHRcdFx0XHRwZW51bWJyYUNvczogMCxcclxuXHRcdFx0XHRcdFx0XHRkZWNheTogMCxcclxuXHJcblx0XHRcdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxyXG5cdFx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcclxuXHRcdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcclxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXHJcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXHJcblx0XHRcdFx0XHRcdFx0ZGVjYXk6IDAsXHJcblxyXG5cdFx0XHRcdFx0XHRcdHNoYWRvdzogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0c2hhZG93QmlhczogMCxcclxuXHRcdFx0XHRcdFx0XHRzaGFkb3dSYWRpdXM6IDEsXHJcblx0XHRcdFx0XHRcdFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKSxcclxuXHRcdFx0XHRcdFx0XHRzaGFkb3dDYW1lcmFOZWFyOiAxLFxyXG5cdFx0XHRcdFx0XHRcdHNoYWRvd0NhbWVyYUZhcjogMTAwMFxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcclxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXHJcblx0XHRcdFx0XHRcdFx0c2t5Q29sb3I6IG5ldyBDb2xvcigpLFxyXG5cdFx0XHRcdFx0XHRcdGdyb3VuZENvbG9yOiBuZXcgQ29sb3IoKVxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdSZWN0QXJlYUxpZ2h0JzpcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMgPSB7XHJcblx0XHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxyXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxyXG5cdFx0XHRcdFx0XHRcdGhhbGZXaWR0aDogbmV3IFZlY3RvcjMoKSxcclxuXHRcdFx0XHRcdFx0XHRoYWxmSGVpZ2h0OiBuZXcgVmVjdG9yMygpXHJcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNldCBSZWN0QXJlYUxpZ2h0IHNoYWRvdyB1bmlmb3Jtc1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0cmV0dXJuIHVuaWZvcm1zO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gV2ViR0xMaWdodHMoKSB7XHJcblxyXG5cdFx0dmFyIGNhY2hlID0gbmV3IFVuaWZvcm1zQ2FjaGUoKTtcclxuXHJcblx0XHR2YXIgc3RhdGUgPSB7XHJcblxyXG5cdFx0XHRoYXNoOiAnJyxcclxuXHJcblx0XHRcdGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxyXG5cdFx0XHRkaXJlY3Rpb25hbDogW10sXHJcblx0XHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcclxuXHRcdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxyXG5cdFx0XHRzcG90OiBbXSxcclxuXHRcdFx0c3BvdFNoYWRvd01hcDogW10sXHJcblx0XHRcdHNwb3RTaGFkb3dNYXRyaXg6IFtdLFxyXG5cdFx0XHRyZWN0QXJlYTogW10sXHJcblx0XHRcdHBvaW50OiBbXSxcclxuXHRcdFx0cG9pbnRTaGFkb3dNYXA6IFtdLFxyXG5cdFx0XHRwb2ludFNoYWRvd01hdHJpeDogW10sXHJcblx0XHRcdGhlbWk6IFtdXHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgbWF0cml4NCA9IG5ldyBNYXRyaXg0KCk7XHJcblx0XHR2YXIgbWF0cml4NDIgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNldHVwKCBsaWdodHMsIHNoYWRvd3MsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdHZhciByID0gMCwgZyA9IDAsIGIgPSAwO1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcclxuXHRcdFx0dmFyIHBvaW50TGVuZ3RoID0gMDtcclxuXHRcdFx0dmFyIHNwb3RMZW5ndGggPSAwO1xyXG5cdFx0XHR2YXIgcmVjdEFyZWFMZW5ndGggPSAwO1xyXG5cdFx0XHR2YXIgaGVtaUxlbmd0aCA9IDA7XHJcblxyXG5cdFx0XHR2YXIgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRcdHZhciBjb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRcdHZhciBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XHJcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRcdHZhciBzaGFkb3dNYXAgPSAoIGxpZ2h0LnNoYWRvdyAmJiBsaWdodC5zaGFkb3cubWFwICkgPyBsaWdodC5zaGFkb3cubWFwLnRleHR1cmUgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0LmlzQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdHIgKz0gY29sb3IuciAqIGludGVuc2l0eTtcclxuXHRcdFx0XHRcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcclxuXHRcdFx0XHRcdGIgKz0gY29sb3IuYiAqIGludGVuc2l0eTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcclxuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCB2ZWN0b3IzICk7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcclxuXHJcblx0XHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xyXG5cclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gc2hhZG93TWFwO1xyXG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xyXG5cdFx0XHRcdFx0c3RhdGUuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0XHRkaXJlY3Rpb25hbExlbmd0aCArKztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNTcG90TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnBlbnVtYnJhQ29zID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICogKCAxIC0gbGlnaHQucGVudW1icmEgKSApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hcFsgc3BvdExlbmd0aCBdID0gc2hhZG93TWFwO1xyXG5cdFx0XHRcdFx0c3RhdGUuc3BvdFNoYWRvd01hdHJpeFsgc3BvdExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcclxuXHRcdFx0XHRcdHN0YXRlLnNwb3RbIHNwb3RMZW5ndGggXSA9IHVuaWZvcm1zO1xyXG5cclxuXHRcdFx0XHRcdHNwb3RMZW5ndGggKys7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUmVjdEFyZWFMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gKGEpIGludGVuc2l0eSBjb250cm9scyBpcnJhZGlhbmNlIG9mIGVudGlyZSBsaWdodFxyXG5cdFx0XHRcdFx0dW5pZm9ybXMuY29sb3JcclxuXHRcdFx0XHRcdFx0LmNvcHkoIGNvbG9yIClcclxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgLyAoIGxpZ2h0LndpZHRoICogbGlnaHQuaGVpZ2h0ICkgKTtcclxuXHJcblx0XHRcdFx0XHQvLyAoYikgaW50ZW5zaXR5IGNvbnRyb2xzIHRoZSByYWRpYW5jZSBwZXIgbGlnaHQgYXJlYVxyXG5cdFx0XHRcdFx0Ly8gdW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZXh0cmFjdCBsb2NhbCByb3RhdGlvbiBvZiBsaWdodCB0byBkZXJpdmUgd2lkdGgvaGVpZ2h0IGhhbGYgdmVjdG9yc1xyXG5cdFx0XHRcdFx0bWF0cml4NDIuaWRlbnRpdHkoKTtcclxuXHRcdFx0XHRcdG1hdHJpeDQuY29weSggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdG1hdHJpeDQucHJlbXVsdGlwbHkoIHZpZXdNYXRyaXggKTtcclxuXHRcdFx0XHRcdG1hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbiggbWF0cml4NCApO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQoIGxpZ2h0LndpZHRoICogMC41LCAwLjAsIDAuMCApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuaGFsZkhlaWdodC5hcHBseU1hdHJpeDQoIG1hdHJpeDQyICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgZGlzdGFuY2U/XHJcblx0XHRcdFx0XHQvLyB1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnJlY3RBcmVhWyByZWN0QXJlYUxlbmd0aCBdID0gdW5pZm9ybXM7XHJcblxyXG5cdFx0XHRcdFx0cmVjdEFyZWFMZW5ndGggKys7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xyXG5cdFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XHJcblxyXG5cdFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XHJcblx0XHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Q2FtZXJhRmFyID0gc2hhZG93LmNhbWVyYS5mYXI7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnBvaW50U2hhZG93TWFwWyBwb2ludExlbmd0aCBdID0gc2hhZG93TWFwO1xyXG5cdFx0XHRcdFx0c3RhdGUucG9pbnRTaGFkb3dNYXRyaXhbIHBvaW50TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xyXG5cdFx0XHRcdFx0c3RhdGUucG9pbnRbIHBvaW50TGVuZ3RoIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0XHRwb2ludExlbmd0aCArKztcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2t5Q29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5ncm91bmRDb2xvci5jb3B5KCBsaWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5oZW1pWyBoZW1pTGVuZ3RoIF0gPSB1bmlmb3JtcztcclxuXHJcblx0XHRcdFx0XHRoZW1pTGVuZ3RoICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5hbWJpZW50WyAwIF0gPSByO1xyXG5cdFx0XHRzdGF0ZS5hbWJpZW50WyAxIF0gPSBnO1xyXG5cdFx0XHRzdGF0ZS5hbWJpZW50WyAyIF0gPSBiO1xyXG5cclxuXHRcdFx0c3RhdGUuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XHJcblx0XHRcdHN0YXRlLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcclxuXHRcdFx0c3RhdGUucmVjdEFyZWEubGVuZ3RoID0gcmVjdEFyZWFMZW5ndGg7XHJcblx0XHRcdHN0YXRlLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xyXG5cdFx0XHRzdGF0ZS5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBUT0RPIChzYW0tZy1zdGVlbCkgd2h5IGFyZW4ndCB3ZSB1c2luZyBqb2luXHJcblx0XHRcdHN0YXRlLmhhc2ggPSBkaXJlY3Rpb25hbExlbmd0aCArICcsJyArIHBvaW50TGVuZ3RoICsgJywnICsgc3BvdExlbmd0aCArICcsJyArIHJlY3RBcmVhTGVuZ3RoICsgJywnICsgaGVtaUxlbmd0aCArICcsJyArIHNoYWRvd3MubGVuZ3RoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzZXR1cDogc2V0dXAsXHJcblx0XHRcdHN0YXRlOiBzdGF0ZVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTE9iamVjdHMoIGdlb21ldHJpZXMsIGluZm9SZW5kZXIgKSB7XHJcblxyXG5cdFx0dmFyIHVwZGF0ZUxpc3QgPSB7fTtcclxuXHJcblx0XHRmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdHZhciBmcmFtZSA9IGluZm9SZW5kZXIuZnJhbWU7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblx0XHRcdHZhciBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QsIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUgb25jZSBwZXIgZnJhbWVcclxuXHJcblx0XHRcdGlmICggdXBkYXRlTGlzdFsgYnVmZmVyZ2VvbWV0cnkuaWQgXSAhPT0gZnJhbWUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRidWZmZXJnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyaWVzLnVwZGF0ZSggYnVmZmVyZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0dXBkYXRlTGlzdFsgYnVmZmVyZ2VvbWV0cnkuaWQgXSA9IGZyYW1lO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBjbGVhcigpIHtcclxuXHJcblx0XHRcdHVwZGF0ZUxpc3QgPSB7fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdHVwZGF0ZTogdXBkYXRlLFxyXG5cdFx0XHRjbGVhcjogY2xlYXJcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVzLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cclxuXHRcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xyXG5cclxuXHRcdGlmICggZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxyXG5cdFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdHZhciBwcm9ncmFtSWRDb3VudCA9IDA7XHJcblxyXG5cdGZ1bmN0aW9uIGdldEVuY29kaW5nQ29tcG9uZW50cyggZW5jb2RpbmcgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggZW5jb2RpbmcgKSB7XHJcblxyXG5cdFx0XHRjYXNlIExpbmVhckVuY29kaW5nOlxyXG5cdFx0XHRcdHJldHVybiBbICdMaW5lYXInLCAnKCB2YWx1ZSApJyBdO1xyXG5cdFx0XHRjYXNlIHNSR0JFbmNvZGluZzpcclxuXHRcdFx0XHRyZXR1cm4gWyAnc1JHQicsICcoIHZhbHVlICknIF07XHJcblx0XHRcdGNhc2UgUkdCRUVuY29kaW5nOlxyXG5cdFx0XHRcdHJldHVybiBbICdSR0JFJywgJyggdmFsdWUgKScgXTtcclxuXHRcdFx0Y2FzZSBSR0JNN0VuY29kaW5nOlxyXG5cdFx0XHRcdHJldHVybiBbICdSR0JNJywgJyggdmFsdWUsIDcuMCApJyBdO1xyXG5cdFx0XHRjYXNlIFJHQk0xNkVuY29kaW5nOlxyXG5cdFx0XHRcdHJldHVybiBbICdSR0JNJywgJyggdmFsdWUsIDE2LjAgKScgXTtcclxuXHRcdFx0Y2FzZSBSR0JERW5jb2Rpbmc6XHJcblx0XHRcdFx0cmV0dXJuIFsgJ1JHQkQnLCAnKCB2YWx1ZSwgMjU2LjAgKScgXTtcclxuXHRcdFx0Y2FzZSBHYW1tYUVuY29kaW5nOlxyXG5cdFx0XHRcdHJldHVybiBbICdHYW1tYScsICcoIHZhbHVlLCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKScgXTtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICd1bnN1cHBvcnRlZCBlbmNvZGluZzogJyArIGVuY29kaW5nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBlbmNvZGluZyApIHtcclxuXHJcblx0XHR2YXIgY29tcG9uZW50cyA9IGdldEVuY29kaW5nQ29tcG9uZW50cyggZW5jb2RpbmcgKTtcclxuXHRcdHJldHVybiAndmVjNCAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjNCB2YWx1ZSApIHsgcmV0dXJuICcgKyBjb21wb25lbnRzWyAwIF0gKyAnVG9MaW5lYXInICsgY29tcG9uZW50c1sgMSBdICsgJzsgfSc7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIGVuY29kaW5nICkge1xyXG5cclxuXHRcdHZhciBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApO1xyXG5cdFx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG8nICsgY29tcG9uZW50c1sgMCBdICsgY29tcG9uZW50c1sgMSBdICsgJzsgfSc7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCB0b25lTWFwcGluZyApIHtcclxuXHJcblx0XHR2YXIgdG9uZU1hcHBpbmdOYW1lO1xyXG5cclxuXHRcdHN3aXRjaCAoIHRvbmVNYXBwaW5nICkge1xyXG5cclxuXHRcdFx0Y2FzZSBMaW5lYXJUb25lTWFwcGluZzpcclxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnTGluZWFyJztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgUmVpbmhhcmRUb25lTWFwcGluZzpcclxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnUmVpbmhhcmQnO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc6XHJcblx0XHRcdFx0dG9uZU1hcHBpbmdOYW1lID0gJ1VuY2hhcnRlZDInO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBDaW5lb25Ub25lTWFwcGluZzpcclxuXHRcdFx0XHR0b25lTWFwcGluZ05hbWUgPSAnT3B0aW1pemVkQ2luZW9uJztcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAndW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6ICcgKyB0b25lTWFwcGluZyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJ3ZlYzMgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzMgY29sb3IgKSB7IHJldHVybiAnICsgdG9uZU1hcHBpbmdOYW1lICsgJ1RvbmVNYXBwaW5nKCBjb2xvciApOyB9JztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZUV4dGVuc2lvbnMoIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIHJlbmRlcmVyRXh0ZW5zaW9ucyApIHtcclxuXHJcblx0XHRleHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcclxuXHJcblx0XHR2YXIgY2h1bmtzID0gW1xyXG5cdFx0XHQoIGV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgfHwgcGFyYW1ldGVycy5lbnZNYXBDdWJlVVYgfHwgcGFyYW1ldGVycy5idW1wTWFwIHx8IHBhcmFtZXRlcnMubm9ybWFsTWFwIHx8IHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgKSA/ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZScgOiAnJyxcclxuXHRcdFx0KCBleHRlbnNpb25zLmZyYWdEZXB0aCB8fCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcclxuXHRcdFx0KCBleHRlbnNpb25zLmRyYXdCdWZmZXJzICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ1dFQkdMX2RyYXdfYnVmZmVycycgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9kcmF3X2J1ZmZlcnMgOiByZXF1aXJlJyA6ICcnLFxyXG5cdFx0XHQoIGV4dGVuc2lvbnMuc2hhZGVyVGV4dHVyZUxPRCB8fCBwYXJhbWV0ZXJzLmVudk1hcCApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyApID8gJyNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZScgOiAnJ1xyXG5cdFx0XTtcclxuXHJcblx0XHRyZXR1cm4gY2h1bmtzLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0dmFyIGNodW5rcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCAnXFxuJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApIHtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IHt9O1xyXG5cclxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcclxuXHRcdFx0dmFyIG5hbWUgPSBpbmZvLm5hbWU7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6JywgbmFtZSwgaSApO1xyXG5cclxuXHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHN0cmluZyAhPT0gJyc7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHJldHVybiBzdHJpbmdcclxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fRElSX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cyApXHJcblx0XHRcdC5yZXBsYWNlKCAvTlVNX1BPSU5UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVBvaW50TGlnaHRzIClcclxuXHRcdFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VJbmNsdWRlcyggc3RyaW5nICkge1xyXG5cclxuXHRcdHZhciBwYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC5dKyk+L2dtO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlcGxhY2UoIG1hdGNoLCBpbmNsdWRlICkge1xyXG5cclxuXHRcdFx0dmFyIHJlcGxhY2UgPSBTaGFkZXJDaHVua1sgaW5jbHVkZSBdO1xyXG5cclxuXHRcdFx0aWYgKCByZXBsYWNlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8JyArIGluY2x1ZGUgKyAnPicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwYXJzZUluY2x1ZGVzKCByZXBsYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHVucm9sbExvb3BzKCBzdHJpbmcgKSB7XHJcblxyXG5cdFx0dmFyIHBhdHRlcm4gPSAvZm9yIFxcKCBpbnQgaSBcXD0gKFxcZCspXFw7IGkgPCAoXFxkKylcXDsgaSBcXCtcXCsgXFwpIFxceyhbXFxzXFxTXSs/KSg/PVxcfSlcXH0vZztcclxuXHJcblx0XHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCApIHtcclxuXHJcblx0XHRcdHZhciB1bnJvbGwgPSAnJztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gcGFyc2VJbnQoIHN0YXJ0ICk7IGkgPCBwYXJzZUludCggZW5kICk7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHVucm9sbCArPSBzbmlwcGV0LnJlcGxhY2UoIC9cXFsgaSBcXF0vZywgJ1sgJyArIGkgKyAnIF0nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdW5yb2xsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBleHRlbnNpb25zLCBjb2RlLCBtYXRlcmlhbCwgc2hhZGVyLCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblxyXG5cdFx0dmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXIudmVydGV4U2hhZGVyO1xyXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcclxuXHJcblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwICkge1xyXG5cclxuXHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcclxuXHRcdHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xyXG5cdFx0dmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcclxuXHJcblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIEN1YmVSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFX1VWJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XHJcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX1NQSEVSRSc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcclxuXHRcdFx0XHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxyXG5cdFx0XHRcdFx0ZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcclxuXHJcblx0XHRcdFx0Y2FzZSBNdWx0aXBseU9wZXJhdGlvbjpcclxuXHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBNaXhPcGVyYXRpb246XHJcblx0XHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlIEFkZE9wZXJhdGlvbjpcclxuXHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcclxuXHJcblx0XHQvLyBjb25zb2xlLmxvZyggJ2J1aWxkaW5nIG5ldyBwcm9ncmFtICcgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBjdXN0b21FeHRlbnNpb25zID0gZ2VuZXJhdGVFeHRlbnNpb25zKCBtYXRlcmlhbC5leHRlbnNpb25zLCBwYXJhbWV0ZXJzLCBleHRlbnNpb25zICk7XHJcblxyXG5cdFx0dmFyIGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG5cclxuXHRcdHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHByZWZpeFZlcnRleCA9IFtcclxuXHJcblx0XHRcdFx0Y3VzdG9tRGVmaW5lc1xyXG5cclxuXHRcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdFx0XHRpZiAoIHByZWZpeFZlcnRleC5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRwcmVmaXhWZXJ0ZXggKz0gJ1xcbic7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtcclxuXHJcblx0XHRcdFx0Y3VzdG9tRXh0ZW5zaW9ucyxcclxuXHRcdFx0XHRjdXN0b21EZWZpbmVzXHJcblxyXG5cdFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcclxuXHJcblx0XHRcdGlmICggcHJlZml4RnJhZ21lbnQubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0cHJlZml4RnJhZ21lbnQgKz0gJ1xcbic7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHByZWZpeFZlcnRleCA9IFtcclxuXHJcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXHJcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxyXG5cclxuXHRcdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgc2hhZGVyLm5hbWUsXHJcblxyXG5cdFx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcclxuXHJcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcclxuXHJcblx0XHRcdFx0JyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxyXG5cdFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCAmJiBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy51c2VWZXJ0ZXhUZXh0dXJlID8gJyNkZWZpbmUgQk9ORV9URVhUVVJFJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxyXG5cclxuXHRcdFx0XHQnI2RlZmluZSBOVU1fQ0xJUFBJTkdfUExBTkVTICcgKyBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcclxuXHJcblx0XHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXHJcblx0XHRcdFx0J3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JyxcclxuXHRcdFx0XHQndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsXHJcblxyXG5cdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxyXG5cdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyxcclxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcclxuXHJcblx0XHRcdFx0JyNpZmRlZiBVU0VfQ09MT1InLFxyXG5cclxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxyXG5cclxuXHRcdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdFx0JyNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTJyxcclxuXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXHJcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXHJcblxyXG5cdFx0XHRcdCdcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTJyxcclxuXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcclxuXHJcblx0XHRcdFx0J1x0I2Vsc2UnLFxyXG5cclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDsnLFxyXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXHJcblx0XHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7JyxcclxuXHRcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NzsnLFxyXG5cclxuXHRcdFx0XHQnXHQjZW5kaWYnLFxyXG5cclxuXHRcdFx0XHQnI2VuZGlmJyxcclxuXHJcblx0XHRcdFx0JyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxyXG5cclxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JyxcclxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsXHJcblxyXG5cdFx0XHRcdCcjZW5kaWYnLFxyXG5cclxuXHRcdFx0XHQnXFxuJ1xyXG5cclxuXHRcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtcclxuXHJcblx0XHRcdFx0Y3VzdG9tRXh0ZW5zaW9ucyxcclxuXHJcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXHJcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxyXG5cclxuXHRcdFx0XHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgc2hhZGVyLm5hbWUsXHJcblxyXG5cdFx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxyXG5cclxuXHRcdFx0XHQnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxyXG5cclxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxyXG5cdFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXHJcblxyXG5cdFx0XHRcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXHJcblx0XHRcdFx0JyNkZWZpbmUgVU5JT05fQ0xJUFBJTkdfUExBTkVTICcgKyAoIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMgLSBwYXJhbWV0ZXJzLm51bUNsaXBJbnRlcnNlY3Rpb24gKSxcclxuXHJcblx0XHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA/ICcjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEEnIDogJycsXHJcblxyXG5cdFx0XHRcdHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyAnI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2RlZmluZSBURVhUVVJFX0xPRF9FWFQnIDogJycsXHJcblxyXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxyXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcclxuXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyAnI2RlZmluZSBUT05FX01BUFBJTkcnIDogJycsXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyBTaGFkZXJDaHVua1sgJ3RvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB0b25lTWFwcGluZygpIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcclxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oICd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKSA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmRpdGhlcmluZyA/ICcjZGVmaW5lIERJVEhFUklORycgOiAnJyxcclxuXHJcblx0XHRcdFx0KCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nIHx8IHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgfHwgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgKSA/IFNoYWRlckNodW5rWyAnZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnbWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgKSA6ICcnLFxyXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdlbnZNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyApIDogJycsXHJcblx0XHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nICkgOiAnJyxcclxuXHRcdFx0XHRwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nID8gZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCAnbGluZWFyVG9PdXRwdXRUZXhlbCcsIHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgKSA6ICcnLFxyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJzLmRlcHRoUGFja2luZyA/ICcjZGVmaW5lIERFUFRIX1BBQ0tJTkcgJyArIG1hdGVyaWFsLmRlcHRoUGFja2luZyA6ICcnLFxyXG5cclxuXHRcdFx0XHQnXFxuJ1xyXG5cclxuXHRcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlcnRleFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0dmVydGV4U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggdmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXIgPSBwYXJzZUluY2x1ZGVzKCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0ZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKCBmcmFnbWVudFNoYWRlciwgcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdGlmICggISBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xyXG5cdFx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKCBmcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdmVydGV4R2xzbCA9IHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcclxuXHRcdHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XHJcblx0XHQvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcclxuXHJcblx0XHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcclxuXHRcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50R2xzbCApO1xyXG5cclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXHJcblx0XHRcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcclxuXHRcdHZhciB2ZXJ0ZXhMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xyXG5cdFx0dmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdHZhciBydW5uYWJsZSA9IHRydWU7XHJcblx0XHR2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBjb25zb2xlLmxvZyggJyoqVkVSVEVYKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsVmVydGV4U2hhZGVyICkgKTtcclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnKipGUkFHTUVOVCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbEZyYWdtZW50U2hhZGVyICkgKTtcclxuXHJcblx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0cnVubmFibGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBwcm9ncmFtTG9nICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XHJcblxyXG5cdFx0XHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpYWdub3N0aWNzID0ge1xyXG5cclxuXHRcdFx0XHRydW5uYWJsZTogcnVubmFibGUsXHJcblx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG5cclxuXHRcdFx0XHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcclxuXHJcblx0XHRcdFx0XHRsb2c6IHZlcnRleExvZyxcclxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4VmVydGV4XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdGZyYWdtZW50U2hhZGVyOiB7XHJcblxyXG5cdFx0XHRcdFx0bG9nOiBmcmFnbWVudExvZyxcclxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xlYW4gdXBcclxuXHJcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XHJcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcclxuXHJcblx0XHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgdW5pZm9ybSBsb2NhdGlvbnNcclxuXHJcblx0XHR2YXIgY2FjaGVkVW5pZm9ybXM7XHJcblxyXG5cdFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y2FjaGVkVW5pZm9ybXMgPSBuZXcgV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xyXG5cclxuXHRcdHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xyXG5cclxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggY2FjaGVkQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGZyZWUgcmVzb3VyY2VcclxuXHJcblx0XHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XHJcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIERFUFJFQ0FURURcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC51bmlmb3JtcyBpcyBub3cgLmdldFVuaWZvcm1zKCkuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0YXR0cmlidXRlczoge1xyXG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHR9ICk7XHJcblxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5pZCA9IHByb2dyYW1JZENvdW50ICsrO1xyXG5cdFx0dGhpcy5jb2RlID0gY29kZTtcclxuXHRcdHRoaXMudXNlZFRpbWVzID0gMTtcclxuXHRcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xyXG5cdFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gV2ViR0xQcm9ncmFtcyggcmVuZGVyZXIsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApIHtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbXMgPSBbXTtcclxuXHJcblx0XHR2YXIgc2hhZGVySURzID0ge1xyXG5cdFx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcclxuXHRcdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxyXG5cdFx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxyXG5cdFx0XHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuXHRcdFx0TWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxyXG5cdFx0XHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcclxuXHRcdFx0TWVzaFRvb25NYXRlcmlhbDogJ3Bob25nJyxcclxuXHRcdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXHJcblx0XHRcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxyXG5cdFx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcclxuXHRcdFx0TGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcclxuXHRcdFx0UG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxyXG5cdFx0XHRTaGFkb3dNYXRlcmlhbDogJ3NoYWRvdydcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIHBhcmFtZXRlck5hbWVzID0gW1xyXG5cdFx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJtYXBFbmNvZGluZ1wiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIiwgXCJlbnZNYXBFbmNvZGluZ1wiLFxyXG5cdFx0XHRcImxpZ2h0TWFwXCIsIFwiYW9NYXBcIiwgXCJlbWlzc2l2ZU1hcFwiLCBcImVtaXNzaXZlTWFwRW5jb2RpbmdcIiwgXCJidW1wTWFwXCIsIFwibm9ybWFsTWFwXCIsIFwiZGlzcGxhY2VtZW50TWFwXCIsIFwic3BlY3VsYXJNYXBcIixcclxuXHRcdFx0XCJyb3VnaG5lc3NNYXBcIiwgXCJtZXRhbG5lc3NNYXBcIiwgXCJncmFkaWVudE1hcFwiLFxyXG5cdFx0XHRcImFscGhhTWFwXCIsIFwiY29tYmluZVwiLCBcInZlcnRleENvbG9yc1wiLCBcImZvZ1wiLCBcInVzZUZvZ1wiLCBcImZvZ0V4cFwiLFxyXG5cdFx0XHRcImZsYXRTaGFkaW5nXCIsIFwic2l6ZUF0dGVudWF0aW9uXCIsIFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclwiLCBcInNraW5uaW5nXCIsXHJcblx0XHRcdFwibWF4Qm9uZXNcIiwgXCJ1c2VWZXJ0ZXhUZXh0dXJlXCIsIFwibW9ycGhUYXJnZXRzXCIsIFwibW9ycGhOb3JtYWxzXCIsXHJcblx0XHRcdFwibWF4TW9ycGhUYXJnZXRzXCIsIFwibWF4TW9ycGhOb3JtYWxzXCIsIFwicHJlbXVsdGlwbGllZEFscGhhXCIsXHJcblx0XHRcdFwibnVtRGlyTGlnaHRzXCIsIFwibnVtUG9pbnRMaWdodHNcIiwgXCJudW1TcG90TGlnaHRzXCIsIFwibnVtSGVtaUxpZ2h0c1wiLCBcIm51bVJlY3RBcmVhTGlnaHRzXCIsXHJcblx0XHRcdFwic2hhZG93TWFwRW5hYmxlZFwiLCBcInNoYWRvd01hcFR5cGVcIiwgXCJ0b25lTWFwcGluZ1wiLCAncGh5c2ljYWxseUNvcnJlY3RMaWdodHMnLFxyXG5cdFx0XHRcImFscGhhVGVzdFwiLCBcImRvdWJsZVNpZGVkXCIsIFwiZmxpcFNpZGVkXCIsIFwibnVtQ2xpcHBpbmdQbGFuZXNcIiwgXCJudW1DbGlwSW50ZXJzZWN0aW9uXCIsIFwiZGVwdGhQYWNraW5nXCIsIFwiZGl0aGVyaW5nXCJcclxuXHRcdF07XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdHZhciBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcclxuXHRcdFx0dmFyIGJvbmVzID0gc2tlbGV0b24uYm9uZXM7XHJcblxyXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gMTAyNDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcclxuXHRcdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcclxuXHRcdFx0XHQvL1xyXG5cdFx0XHRcdC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXHJcblx0XHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXHJcblx0XHRcdFx0Ly8gICAgKHVwIHRvIDU0IHNob3VsZCBiZSBzYWZlKVxyXG5cclxuXHRcdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xyXG5cdFx0XHRcdHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XHJcblxyXG5cdFx0XHRcdHZhciBtYXhCb25lcyA9IE1hdGgubWluKCBuVmVydGV4TWF0cmljZXMsIGJvbmVzLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgYm9uZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFNrZWxldG9uIGhhcyAnICsgYm9uZXMubGVuZ3RoICsgJyBib25lcy4gVGhpcyBHUFUgc3VwcG9ydHMgJyArIG1heEJvbmVzICsgJy4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbWF4Qm9uZXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hcCwgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcclxuXHJcblx0XHRcdHZhciBlbmNvZGluZztcclxuXHJcblx0XHRcdGlmICggISBtYXAgKSB7XHJcblxyXG5cdFx0XHRcdGVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXAuaXNUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRlbmNvZGluZyA9IG1hcC5lbmNvZGluZztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xQcm9ncmFtcy5nZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiICk7XHJcblx0XHRcdFx0ZW5jb2RpbmcgPSBtYXAudGV4dHVyZS5lbmNvZGluZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFkZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgV2ViR0xSZW5kZXJlci5nYW1tYUlucHV0L2dhbW1hT3V0cHV0IHBhcmFtZXRlciwgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQgYXQgc29tZSBwb2ludC5cclxuXHRcdFx0aWYgKCBlbmNvZGluZyA9PT0gTGluZWFyRW5jb2RpbmcgJiYgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcclxuXHJcblx0XHRcdFx0ZW5jb2RpbmcgPSBHYW1tYUVuY29kaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGVuY29kaW5nO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIHNoYWRvd3MsIGZvZywgbkNsaXBQbGFuZXMsIG5DbGlwSW50ZXJzZWN0aW9uLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcclxuXHJcblx0XHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXHJcblx0XHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXHJcblxyXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBvYmplY3QuaXNTa2lubmVkTWVzaCA/IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIDogMDtcclxuXHRcdFx0dmFyIHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5wcmVjaXNpb247XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XHJcblxyXG5cdFx0XHRcdGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtLmdldFBhcmFtZXRlcnM6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHJcblx0XHRcdHZhciBwYXJhbWV0ZXJzID0ge1xyXG5cclxuXHRcdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXHJcblxyXG5cdFx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxyXG5cdFx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcclxuXHRcdFx0XHRvdXRwdXRFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggKCAhIGN1cnJlbnRSZW5kZXJUYXJnZXQgKSA/IG51bGwgOiBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUsIHJlbmRlcmVyLmdhbW1hT3V0cHV0ICksXHJcblx0XHRcdFx0bWFwOiAhISBtYXRlcmlhbC5tYXAsXHJcblx0XHRcdFx0bWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLm1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxyXG5cdFx0XHRcdGVudk1hcDogISEgbWF0ZXJpYWwuZW52TWFwLFxyXG5cdFx0XHRcdGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcclxuXHRcdFx0XHRlbnZNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW52TWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXHJcblx0XHRcdFx0ZW52TWFwQ3ViZVVWOiAoICEhIG1hdGVyaWFsLmVudk1hcCApICYmICggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgKSB8fCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZyApICksXHJcblx0XHRcdFx0bGlnaHRNYXA6ICEhIG1hdGVyaWFsLmxpZ2h0TWFwLFxyXG5cdFx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcclxuXHRcdFx0XHRlbWlzc2l2ZU1hcDogISEgbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXHJcblx0XHRcdFx0ZW1pc3NpdmVNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW1pc3NpdmVNYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcclxuXHRcdFx0XHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxyXG5cdFx0XHRcdG5vcm1hbE1hcDogISEgbWF0ZXJpYWwubm9ybWFsTWFwLFxyXG5cdFx0XHRcdGRpc3BsYWNlbWVudE1hcDogISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxyXG5cdFx0XHRcdHJvdWdobmVzc01hcDogISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxyXG5cdFx0XHRcdG1ldGFsbmVzc01hcDogISEgbWF0ZXJpYWwubWV0YWxuZXNzTWFwLFxyXG5cdFx0XHRcdHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcclxuXHRcdFx0XHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXHJcblxyXG5cdFx0XHRcdGdyYWRpZW50TWFwOiAhISBtYXRlcmlhbC5ncmFkaWVudE1hcCxcclxuXHJcblx0XHRcdFx0Y29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcclxuXHJcblx0XHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXHJcblxyXG5cdFx0XHRcdGZvZzogISEgZm9nLFxyXG5cdFx0XHRcdHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxyXG5cdFx0XHRcdGZvZ0V4cDogKCBmb2cgJiYgZm9nLmlzRm9nRXhwMiApLFxyXG5cclxuXHRcdFx0XHRmbGF0U2hhZGluZzogbWF0ZXJpYWwuZmxhdFNoYWRpbmcsXHJcblxyXG5cdFx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxyXG5cdFx0XHRcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxyXG5cclxuXHRcdFx0XHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcgJiYgbWF4Qm9uZXMgPiAwLFxyXG5cdFx0XHRcdG1heEJvbmVzOiBtYXhCb25lcyxcclxuXHRcdFx0XHR1c2VWZXJ0ZXhUZXh0dXJlOiBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyxcclxuXHJcblx0XHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXHJcblx0XHRcdFx0bW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXHJcblx0XHRcdFx0bWF4TW9ycGhUYXJnZXRzOiByZW5kZXJlci5tYXhNb3JwaFRhcmdldHMsXHJcblx0XHRcdFx0bWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXHJcblxyXG5cdFx0XHRcdG51bURpckxpZ2h0czogbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCxcclxuXHRcdFx0XHRudW1Qb2ludExpZ2h0czogbGlnaHRzLnBvaW50Lmxlbmd0aCxcclxuXHRcdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXHJcblx0XHRcdFx0bnVtUmVjdEFyZWFMaWdodHM6IGxpZ2h0cy5yZWN0QXJlYS5sZW5ndGgsXHJcblx0XHRcdFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxyXG5cclxuXHRcdFx0XHRudW1DbGlwcGluZ1BsYW5lczogbkNsaXBQbGFuZXMsXHJcblx0XHRcdFx0bnVtQ2xpcEludGVyc2VjdGlvbjogbkNsaXBJbnRlcnNlY3Rpb24sXHJcblxyXG5cdFx0XHRcdGRpdGhlcmluZzogbWF0ZXJpYWwuZGl0aGVyaW5nLFxyXG5cclxuXHRcdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBzaGFkb3dzLmxlbmd0aCA+IDAsXHJcblx0XHRcdFx0c2hhZG93TWFwVHlwZTogcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUsXHJcblxyXG5cdFx0XHRcdHRvbmVNYXBwaW5nOiByZW5kZXJlci50b25lTWFwcGluZyxcclxuXHRcdFx0XHRwaHlzaWNhbGx5Q29ycmVjdExpZ2h0czogcmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMsXHJcblxyXG5cdFx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhLFxyXG5cclxuXHRcdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcclxuXHRcdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSxcclxuXHRcdFx0XHRmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlLFxyXG5cclxuXHRcdFx0XHRkZXB0aFBhY2tpbmc6ICggbWF0ZXJpYWwuZGVwdGhQYWNraW5nICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsLmRlcHRoUGFja2luZyA6IGZhbHNlXHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIHBhcmFtZXRlcnM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xyXG5cclxuXHRcdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRhcnJheS5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xyXG5cdFx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggbmFtZSApO1xyXG5cdFx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHBhcmFtZXRlck5hbWVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVyc1sgcGFyYW1ldGVyTmFtZXNbIGkgXSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcnJheS5wdXNoKCBtYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKSApO1xyXG5cclxuXHRcdFx0YXJyYXkucHVzaCggcmVuZGVyZXIuZ2FtbWFPdXRwdXQgKTtcclxuXHJcblx0XHRcdHJldHVybiBhcnJheS5qb2luKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmFjcXVpcmVQcm9ncmFtID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgc2hhZGVyLCBwYXJhbWV0ZXJzLCBjb2RlICkge1xyXG5cclxuXHRcdFx0dmFyIHByb2dyYW07XHJcblxyXG5cdFx0XHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcclxuXHRcdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgcHJvZ3JhbUluZm8gPSBwcm9ncmFtc1sgcCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xyXG5cdFx0XHRcdFx0KysgcHJvZ3JhbS51c2VkVGltZXM7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRwcm9ncmFtID0gbmV3IFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGV4dGVuc2lvbnMsIGNvZGUsIG1hdGVyaWFsLCBzaGFkZXIsIHBhcmFtZXRlcnMgKTtcclxuXHRcdFx0XHRwcm9ncmFtcy5wdXNoKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiAoIHByb2dyYW0gKSB7XHJcblxyXG5cdFx0XHRpZiAoIC0tIHByb2dyYW0udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBSZW1vdmUgZnJvbSB1bm9yZGVyZWQgc2V0XHJcblx0XHRcdFx0dmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XHJcblx0XHRcdFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XHJcblx0XHRcdFx0cHJvZ3JhbXMucG9wKCk7XHJcblxyXG5cdFx0XHRcdC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXHJcblx0XHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XHJcblx0XHR0aGlzLnByb2dyYW1zID0gcHJvZ3JhbXM7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgaW5mb01lbW9yeSApIHtcclxuXHJcblx0XHR2YXIgX2lzV2ViR0wyID0gKCB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgX2dsIGluc3RhbmNlb2Ygd2luZG93LldlYkdMMlJlbmRlcmluZ0NvbnRleHQgKTtcclxuXHRcdHZhciBfdmlkZW9UZXh0dXJlcyA9IHt9O1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUoIGltYWdlLCBtYXhTaXplICkge1xyXG5cclxuXHRcdFx0aWYgKCBpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcclxuXHRcdFx0XHQvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxyXG5cclxuXHRcdFx0XHR2YXIgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xyXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcclxuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogc2NhbGUgKTtcclxuXHJcblx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FudmFzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGltYWdlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIF9NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBfTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBtYWtlUG93ZXJPZlR3byggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcclxuXHRcdFx0XHRjYW52YXMud2lkdGggPSBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IF9NYXRoLmZsb29yUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyBub3QgcG93ZXIgb2YgdHdvICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHx8XHJcblx0XHRcdFx0KCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNQb3dlck9mVHdvICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzUG93ZXJPZlR3byAmJlxyXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG5cdFx0ZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soIGYgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGYgPT09IE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIF9nbC5ORUFSRVNUO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIF9nbC5MSU5FQVI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRkZWxldGUgX3ZpZGVvVGV4dHVyZXNbIHRleHR1cmUuaWQgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGluZm9NZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdGluZm9NZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGN1YmUgdGV4dHVyZVxyXG5cclxuXHRcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gMkQgdGV4dHVyZVxyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXHJcblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcclxuXHJcblx0XHRcdGlmICggISByZW5kZXJUYXJnZXQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xyXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJvcGVydGllcy5yZW1vdmUoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcblx0XHRcdHByb3BlcnRpZXMucmVtb3ZlKCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIHNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnLCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRpbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9ICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKTtcclxuXHRcdFx0XHRcdHZhciBpc0RhdGFUZXh0dXJlID0gKCB0ZXh0dXJlLmltYWdlWyAwIF0gJiYgdGV4dHVyZS5pbWFnZVsgMCBdLmlzRGF0YVRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcclxuXHRcdFx0XHRcdFx0aXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcblx0XHRcdFx0XHRcdGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQgKSxcclxuXHRcdFx0XHRcdFx0Z2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XHJcblxyXG5cdFx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICEgaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFJHQkZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCknICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZUR5bmFtaWMoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkge1xyXG5cclxuXHRcdFx0dmFyIGV4dGVuc2lvbjtcclxuXHJcblx0XHRcdGlmICggaXNQb3dlck9mVHdvSW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLndyYXBTICkgKTtcclxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgdXRpbHMuY29udmVydCggdGV4dHVyZS53cmFwVCApICk7XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdXRpbHMuY29udmVydCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdXRpbHMuY29udmVydCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuJywgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWFnRmlsdGVyICkgKTtcclxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xyXG5cdFx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBIYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xyXG5cdFx0XHRcdFx0cHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdF92aWRlb1RleHR1cmVzWyB0ZXh0dXJlLmlkIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGluZm9NZW1vcnkudGV4dHVyZXMgKys7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcclxuXHJcblx0XHRcdHZhciBpbWFnZSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGltYWdlID0gbWFrZVBvd2VyT2ZUd28oIGltYWdlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXHJcblx0XHRcdFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xyXG5cclxuXHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcclxuXHJcblx0XHRcdFx0Ly8gcG9wdWxhdGUgZGVwdGggdGV4dHVyZSB3aXRoIGR1bW15IGRhdGFcclxuXHJcblx0XHRcdFx0dmFyIGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgX2lzV2ViR0wyICkgdGhyb3cgbmV3IEVycm9yKCAnRmxvYXQgRGVwdGggVGV4dHVyZSBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTDIuMCcgKTtcclxuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggX2lzV2ViR0wyICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFdlYkdMIDIuMCByZXF1aXJlcyBzaWduZWQgaW50ZXJuYWxmb3JtYXQgZm9yIGdsVGV4SW1hZ2UyRFxyXG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMTY7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgJiYgaW50ZXJuYWxGb3JtYXQgPT09IF9nbC5ERVBUSF9DT01QT05FTlQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlIGVycm9yIElOVkFMSURfT1BFUkFUSU9OIGlzIGdlbmVyYXRlZCBieSB0ZXhJbWFnZTJEIGlmIGZvcm1hdCBhbmQgaW50ZXJuYWxmb3JtYXQgYXJlXHJcblx0XHRcdFx0XHQvLyBERVBUSF9DT01QT05FTlQgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX1NIT1JUIG9yIFVOU0lHTkVEX0lOVFxyXG5cdFx0XHRcdFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRTaG9ydFR5cGUgJiYgdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludFR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRTaG9ydFR5cGUgb3IgVW5zaWduZWRJbnRUeXBlIGZvciBEZXB0aEZvcm1hdCBEZXB0aFRleHR1cmUuJyApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XHJcblx0XHRcdFx0XHRcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEZXB0aCBzdGVuY2lsIHRleHR1cmVzIG5lZWQgdGhlIERFUFRIX1NURU5DSUwgaW50ZXJuYWwgZm9ybWF0XHJcblx0XHRcdFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX1NURU5DSUw7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlIGVycm9yIElOVkFMSURfT1BFUkFUSU9OIGlzIGdlbmVyYXRlZCBieSB0ZXhJbWFnZTJEIGlmIGZvcm1hdCBhbmQgaW50ZXJuYWxmb3JtYXQgYXJlXHJcblx0XHRcdFx0XHQvLyBERVBUSF9TVEVOQ0lMIGFuZCB0eXBlIGlzIG5vdCBVTlNJR05FRF9JTlRfMjRfOF9XRUJHTC5cclxuXHRcdFx0XHRcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxyXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZEludDI0OFR5cGUgZm9yIERlcHRoU3RlbmNpbEZvcm1hdCBEZXB0aFRleHR1cmUuJyApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xyXG5cdFx0XHRcdFx0XHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXHJcblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXHJcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXHJcblxyXG5cdFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXHJcblxyXG5cdFx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXHJcblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXHJcblx0XHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXHJcblxyXG5cdFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlbmRlciB0YXJnZXRzXHJcblxyXG5cdFx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxyXG5cdFx0ZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCByZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgKTtcclxuXHRcdFx0dmFyIGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHJlbmRlclRhcmdldC50ZXh0dXJlLnR5cGUgKTtcclxuXHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggdGV4dHVyZVRhcmdldCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSwgMCApO1xyXG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcclxuXHRcdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIEZJWE1FOiBXZSBkb24ndCBzdXBwb3J0ICFkZXB0aCAhc3RlbmNpbFxyXG5cdFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0dXAgcmVzb3VyY2VzIGZvciBhIERlcHRoIFRleHR1cmUgZm9yIGEgRkJPIChuZWVkcyBhbiBleHRlbnNpb24pXHJcblx0XHRmdW5jdGlvbiBzZXR1cERlcHRoVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB0aHJvdyBuZXcgRXJyb3IoICdEZXB0aCBUZXh0dXJlIHdpdGggY3ViZSByZW5kZXIgdGFyZ2V0cyBpcyBub3Qgc3VwcG9ydGVkJyApO1xyXG5cclxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xyXG5cclxuXHRcdFx0aWYgKCAhICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGxvYWQgYW4gZW1wdHkgZGVwdGggdGV4dHVyZSB3aXRoIGZyYW1lYnVmZmVyIHNpemVcclxuXHRcdFx0aWYgKCAhIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmUgfHxcclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggIT09IHJlbmRlclRhcmdldC53aWR0aCB8fFxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldC5oZWlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2V0VGV4dHVyZTJEKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgd2ViZ2xEZXB0aFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldHVwIEdMIHJlc291cmNlcyBmb3IgYSBub24tdGV4dHVyZSBkZXB0aCBidWZmZXJcclxuXHRcdGZ1bmN0aW9uIHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID09PSB0cnVlICk7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnICk7XHJcblxyXG5cdFx0XHRcdHNldHVwRGVwdGhUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcclxuXHRcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuXHRcdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcblx0XHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB1cCBHTCByZXNvdXJjZXMgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XHJcblx0XHRmdW5jdGlvbiBzZXR1cFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XHJcblxyXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRpbmZvTWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID09PSB0cnVlICk7XHJcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0Ly8gU2V0dXAgZnJhbWVidWZmZXJcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNldHVwIGNvbG9yIGJ1ZmZlclxyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKSApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU2V0dXAgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVyc1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XHJcblx0XHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcclxuXHRcdFx0XHR2YXIgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcclxuXHJcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgd2ViZ2xUZXh0dXJlICk7XHJcblx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKTtcclxuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCBudWxsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVZpZGVvVGV4dHVyZXMoKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaWQgaW4gX3ZpZGVvVGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0XHRcdF92aWRlb1RleHR1cmVzWyBpZCBdLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcclxuXHRcdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcclxuXHRcdHRoaXMuc2V0VGV4dHVyZUN1YmVEeW5hbWljID0gc2V0VGV4dHVyZUN1YmVEeW5hbWljO1xyXG5cdFx0dGhpcy5zZXR1cFJlbmRlclRhcmdldCA9IHNldHVwUmVuZGVyVGFyZ2V0O1xyXG5cdFx0dGhpcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAgPSB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXA7XHJcblx0XHR0aGlzLnVwZGF0ZVZpZGVvVGV4dHVyZXMgPSB1cGRhdGVWaWRlb1RleHR1cmVzO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFdlYkdMUHJvcGVydGllcygpIHtcclxuXHJcblx0XHR2YXIgcHJvcGVydGllcyA9IHt9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcclxuXHRcdFx0dmFyIG1hcCA9IHByb3BlcnRpZXNbIHV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1hcCA9IHt9O1xyXG5cdFx0XHRcdHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbW92ZSggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNsZWFyKCkge1xyXG5cclxuXHRcdFx0cHJvcGVydGllcyA9IHt9O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRnZXQ6IGdldCxcclxuXHRcdFx0cmVtb3ZlOiByZW1vdmUsXHJcblx0XHRcdGNsZWFyOiBjbGVhclxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFN0YXRlKCBnbCwgZXh0ZW5zaW9ucywgdXRpbHMgKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gQ29sb3JCdWZmZXIoKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSBuZXcgVmVjdG9yNCgpO1xyXG5cdFx0XHR2YXIgY3VycmVudENvbG9yTWFzayA9IG51bGw7XHJcblx0XHRcdHZhciBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cclxuXHRcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoIGNvbG9yTWFzayApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvck1hc2sgIT09IGNvbG9yTWFzayAmJiAhIGxvY2tlZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrICk7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBjb2xvck1hc2s7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcclxuXHJcblx0XHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCByLCBnLCBiLCBhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyggY29sb3IgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xvckNsZWFyLmNvcHkoIGNvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xyXG5cdFx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuc2V0KCAtIDEsIDAsIDAsIDAgKTsgLy8gc2V0IHRvIGludmFsaWQgc3RhdGVcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gRGVwdGhCdWZmZXIoKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHR2YXIgY3VycmVudERlcHRoTWFzayA9IG51bGw7XHJcblx0XHRcdHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcclxuXHRcdFx0dmFyIGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGVwdGhUZXN0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGRpc2FibGUoIGdsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggZGVwdGhNYXNrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICEgbG9ja2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aE1hc2sgKTtcclxuXHRcdFx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IGRlcHRoTWFzaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHNldEZ1bmM6IGZ1bmN0aW9uICggZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkZXB0aEZ1bmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIE5ldmVyRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLk5FVkVSICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgQWx3YXlzRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkFMV0FZUyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIExlc3NEZXB0aDpcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIExlc3NFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5FUVVBTCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBHcmVhdGVyRGVwdGg6XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkdSRUFURVIgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5OT1RFUVVBTCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcclxuXHJcblx0XHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCBkZXB0aCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnREZXB0aENsZWFyICE9PSBkZXB0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnREZXB0aENsZWFyID0gZGVwdGg7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xyXG5cdFx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IG51bGw7XHJcblx0XHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHR2YXIgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcclxuXHRcdFx0dmFyIGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XHJcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcclxuXHRcdFx0dmFyIGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XHJcblx0XHRcdHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHRcdFx0dmFyIGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xyXG5cdFx0XHR2YXIgY3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cclxuXHRcdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoIHN0ZW5jaWxUZXN0ICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggc3RlbmNpbFRlc3QgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlbmFibGUoIGdsLlNURU5DSUxfVEVTVCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkaXNhYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHNldE1hc2s6IGZ1bmN0aW9uICggc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbE1hc2sgIT09IHN0ZW5jaWxNYXNrICYmICEgbG9ja2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxNYXNrICk7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XHJcblx0XHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsUmVmIFx0IT09IHN0ZW5jaWxSZWYgXHR8fFxyXG5cdFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrICE9PSBzdGVuY2lsTWFzayApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcclxuXHJcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xyXG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFJlZiA9IHN0ZW5jaWxSZWY7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBzdGVuY2lsTWFzaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHNldE9wOiBmdW5jdGlvbiAoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsRmFpbFx0ICE9PSBzdGVuY2lsRmFpbCBcdHx8XHJcblx0XHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fFxyXG5cdFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5zdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gc3RlbmNpbEZhaWw7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBzdGVuY2lsWkZhaWw7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcclxuXHJcblx0XHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRzZXRDbGVhcjogZnVuY3Rpb24gKCBzdGVuY2lsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxDbGVhciAhPT0gc3RlbmNpbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmNsZWFyU3RlbmNpbCggc3RlbmNpbCApO1xyXG5cdFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gc3RlbmNpbDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcclxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XHJcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XHJcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcclxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XHJcblx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcclxuXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xyXG5cdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIGNvbG9yQnVmZmVyID0gbmV3IENvbG9yQnVmZmVyKCk7XHJcblx0XHR2YXIgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcclxuXHRcdHZhciBzdGVuY2lsQnVmZmVyID0gbmV3IFN0ZW5jaWxCdWZmZXIoKTtcclxuXHJcblx0XHR2YXIgbWF4VmVydGV4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XHJcblx0XHR2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XHJcblx0XHR2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xyXG5cdFx0dmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcclxuXHJcblx0XHR2YXIgY2FwYWJpbGl0aWVzID0ge307XHJcblxyXG5cdFx0dmFyIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XHJcblxyXG5cdFx0dmFyIGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHJcblx0XHR2YXIgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcclxuXHRcdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XHJcblx0XHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcclxuXHRcdHZhciBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xyXG5cdFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xyXG5cdFx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcclxuXHRcdHZhciBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XHJcblx0XHR2YXIgY3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xyXG5cdFx0dmFyIGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XHJcblxyXG5cdFx0dmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cclxuXHRcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XHJcblx0XHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG5cclxuXHRcdHZhciB2ZXJzaW9uID0gcGFyc2VGbG9hdCggL15XZWJHTFxcIChbMC05XSkvLmV4ZWMoIGdsLmdldFBhcmFtZXRlciggZ2wuVkVSU0lPTiApIClbIDEgXSApO1xyXG5cdFx0dmFyIGxpbmVXaWR0aEF2YWlsYWJsZSA9IHBhcnNlRmxvYXQoIHZlcnNpb24gKSA+PSAxLjA7XHJcblxyXG5cdFx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XHJcblx0XHR2YXIgY3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcclxuXHJcblx0XHR2YXIgY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xyXG5cdFx0dmFyIGN1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSggdHlwZSwgdGFyZ2V0LCBjb3VudCApIHtcclxuXHJcblx0XHRcdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDQgKTsgLy8gNCBpcyByZXF1aXJlZCB0byBtYXRjaCBkZWZhdWx0IHVucGFjayBhbGlnbm1lbnQgb2YgNC5cclxuXHRcdFx0dmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggdHlwZSwgdGV4dHVyZSApO1xyXG5cdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcclxuXHRcdFx0Z2wudGV4UGFyYW1ldGVyaSggdHlwZSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRCggdGFyZ2V0ICsgaSwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBlbXB0eVRleHR1cmVzID0ge307XHJcblx0XHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFXzJEIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFXzJELCAxICk7XHJcblx0XHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFX0NVQkVfTUFQIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDYgKTtcclxuXHJcblx0XHQvLyBpbml0XHJcblxyXG5cdFx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoIDAsIDAsIDAsIDEgKTtcclxuXHRcdGRlcHRoQnVmZmVyLnNldENsZWFyKCAxICk7XHJcblx0XHRzdGVuY2lsQnVmZmVyLnNldENsZWFyKCAwICk7XHJcblxyXG5cdFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XHJcblx0XHRkZXB0aEJ1ZmZlci5zZXRGdW5jKCBMZXNzRXF1YWxEZXB0aCApO1xyXG5cclxuXHRcdHNldEZsaXBTaWRlZCggZmFsc2UgKTtcclxuXHRcdHNldEN1bGxGYWNlKCBDdWxsRmFjZUJhY2sgKTtcclxuXHRcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xyXG5cdFx0c2V0QmxlbmRpbmcoIE5vcm1hbEJsZW5kaW5nICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XHJcblxyXG5cdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcclxuXHJcblx0XHRcdFx0ZXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggYXR0cmlidXRlLCAwICk7XHJcblx0XHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcclxuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IG1lc2hQZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xyXG5cdFx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IG1lc2hQZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICE9PSBsOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gIT09IG5ld0F0dHJpYnV0ZXNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcclxuXHRcdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGVuYWJsZSggaWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xyXG5cdFx0XHRcdGNhcGFiaWxpdGllc1sgaWQgXSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRpc2FibGUoIGlkICkge1xyXG5cclxuXHRcdFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRnbC5kaXNhYmxlKCBpZCApO1xyXG5cdFx0XHRcdGNhcGFiaWxpdGllc1sgaWQgXSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gW107XHJcblxyXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHxcclxuXHRcdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHxcclxuXHRcdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMucHVzaCggZm9ybWF0c1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB1c2VQcm9ncmFtKCBwcm9ncmFtICkge1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50UHJvZ3JhbSAhPT0gcHJvZ3JhbSApIHtcclxuXHJcblx0XHRcdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRCbGVuZGluZyggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kaW5nICE9PSBOb0JsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRlbmFibGUoIGdsLkJMRU5EICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkaXNhYmxlKCBnbC5CTEVORCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBibGVuZGluZyAhPT0gQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyB8fCBwcmVtdWx0aXBsaWVkQWxwaGEgIT09IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSApIHtcclxuXHJcblx0XHRcdFx0XHRzd2l0Y2ggKCBibGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBNdWx0aXBseUJsZW5kaW5nOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiwgZ2wuWkVSTywgZ2wuU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xyXG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcclxuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcclxuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XHJcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhIHx8IGJsZW5kRXF1YXRpb247XHJcblx0XHRcdFx0YmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGEgfHwgYmxlbmRTcmM7XHJcblx0XHRcdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XHJcblxyXG5cdFx0XHRcdGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xyXG5cclxuXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggdXRpbHMuY29udmVydCggYmxlbmRFcXVhdGlvbiApLCB1dGlscy5jb252ZXJ0KCBibGVuZEVxdWF0aW9uQWxwaGEgKSApO1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcclxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIHV0aWxzLmNvbnZlcnQoIGJsZW5kU3JjICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kRHN0ICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kU3JjQWxwaGEgKSwgdXRpbHMuY29udmVydCggYmxlbmREc3RBbHBoYSApICk7XHJcblxyXG5cdFx0XHRcdFx0Y3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XHJcblx0XHRcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcclxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcclxuXHRcdFx0XHRcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XHJcblx0XHRcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmcm9udEZhY2VDVyApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGVcclxuXHRcdFx0XHQ/IGRpc2FibGUoIGdsLkNVTExfRkFDRSApXHJcblx0XHRcdFx0OiBlbmFibGUoIGdsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdFx0dmFyIGZsaXBTaWRlZCA9ICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKTtcclxuXHRcdFx0aWYgKCBmcm9udEZhY2VDVyApIGZsaXBTaWRlZCA9ICEgZmxpcFNpZGVkO1xyXG5cclxuXHRcdFx0c2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKTtcclxuXHJcblx0XHRcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlXHJcblx0XHRcdFx0PyBzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhLCBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgKVxyXG5cdFx0XHRcdDogc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcclxuXHJcblx0XHRcdGRlcHRoQnVmZmVyLnNldEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xyXG5cdFx0XHRkZXB0aEJ1ZmZlci5zZXRUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdFx0ZGVwdGhCdWZmZXIuc2V0TWFzayggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRjb2xvckJ1ZmZlci5zZXRNYXNrKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XHJcblxyXG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcclxuXHJcblx0XHRcdFx0XHRnbC5mcm9udEZhY2UoIGdsLkNXICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gZmxpcFNpZGVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzZXRDdWxsRmFjZSggY3VsbEZhY2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUgKSB7XHJcblxyXG5cdFx0XHRcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0XHRcdGlmICggY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGdsLmN1bGxGYWNlKCBnbC5GUk9OVF9BTkRfQkFDSyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjdXJyZW50Q3VsbEZhY2UgPSBjdWxsRmFjZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKCB3aWR0aCApIHtcclxuXHJcblx0XHRcdGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGluZVdpZHRoQXZhaWxhYmxlICkgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xyXG5cclxuXHRcdFx0XHRjdXJyZW50TGluZVdpZHRoID0gd2lkdGg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNldFBvbHlnb25PZmZzZXQoIHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdGVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xyXG5cdFx0XHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KCBzY2lzc29yVGVzdCApIHtcclxuXHJcblx0XHRcdGlmICggc2Npc3NvclRlc3QgKSB7XHJcblxyXG5cdFx0XHRcdGVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRkaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGV4dHVyZVxyXG5cclxuXHRcdGZ1bmN0aW9uIGFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApIHtcclxuXHJcblx0XHRcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApO1xyXG5cdFx0XHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGFjdGl2ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XHJcblxyXG5cdFx0XHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRib3VuZFRleHR1cmUgPSB7IHR5cGU6IHVuZGVmaW5lZCwgdGV4dHVyZTogdW5kZWZpbmVkIH07XHJcblx0XHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdID0gYm91bmRUZXh0dXJlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzWyB3ZWJnbFR5cGUgXSApO1xyXG5cclxuXHRcdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcclxuXHRcdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlMkQoKSB7XHJcblxyXG5cdFx0XHR0cnkge1xyXG5cclxuXHRcdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB0ZXhJbWFnZTJEKCkge1xyXG5cclxuXHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xyXG5cclxuXHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNjaXNzb3IoIHNjaXNzb3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0Z2wuc2Npc3Nvciggc2Npc3Nvci54LCBzY2lzc29yLnksIHNjaXNzb3Iueiwgc2Npc3Nvci53ICk7XHJcblx0XHRcdFx0Y3VycmVudFNjaXNzb3IuY29weSggc2Npc3NvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB2aWV3cG9ydCggdmlld3BvcnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGN1cnJlbnRWaWV3cG9ydC5lcXVhbHMoIHZpZXdwb3J0ICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRnbC52aWV3cG9ydCggdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyApO1xyXG5cdFx0XHRcdGN1cnJlbnRWaWV3cG9ydC5jb3B5KCB2aWV3cG9ydCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlc2V0KCkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XHJcblx0XHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y2FwYWJpbGl0aWVzID0ge307XHJcblxyXG5cdFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xyXG5cclxuXHRcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcclxuXHJcblx0XHRcdGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHJcblx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XHJcblxyXG5cdFx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcclxuXHRcdFx0Y3VycmVudEN1bGxGYWNlID0gbnVsbDtcclxuXHJcblx0XHRcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XHJcblx0XHRcdGRlcHRoQnVmZmVyLnJlc2V0KCk7XHJcblx0XHRcdHN0ZW5jaWxCdWZmZXIucmVzZXQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdGJ1ZmZlcnM6IHtcclxuXHRcdFx0XHRjb2xvcjogY29sb3JCdWZmZXIsXHJcblx0XHRcdFx0ZGVwdGg6IGRlcHRoQnVmZmVyLFxyXG5cdFx0XHRcdHN0ZW5jaWw6IHN0ZW5jaWxCdWZmZXJcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGluaXRBdHRyaWJ1dGVzOiBpbml0QXR0cmlidXRlcyxcclxuXHRcdFx0ZW5hYmxlQXR0cmlidXRlOiBlbmFibGVBdHRyaWJ1dGUsXHJcblx0XHRcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3I6IGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IsXHJcblx0XHRcdGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzOiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcyxcclxuXHRcdFx0ZW5hYmxlOiBlbmFibGUsXHJcblx0XHRcdGRpc2FibGU6IGRpc2FibGUsXHJcblx0XHRcdGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0czogZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLFxyXG5cclxuXHRcdFx0dXNlUHJvZ3JhbTogdXNlUHJvZ3JhbSxcclxuXHJcblx0XHRcdHNldEJsZW5kaW5nOiBzZXRCbGVuZGluZyxcclxuXHRcdFx0c2V0TWF0ZXJpYWw6IHNldE1hdGVyaWFsLFxyXG5cclxuXHRcdFx0c2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXHJcblx0XHRcdHNldEN1bGxGYWNlOiBzZXRDdWxsRmFjZSxcclxuXHJcblx0XHRcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxyXG5cdFx0XHRzZXRQb2x5Z29uT2Zmc2V0OiBzZXRQb2x5Z29uT2Zmc2V0LFxyXG5cclxuXHRcdFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxyXG5cclxuXHRcdFx0YWN0aXZlVGV4dHVyZTogYWN0aXZlVGV4dHVyZSxcclxuXHRcdFx0YmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxyXG5cdFx0XHRjb21wcmVzc2VkVGV4SW1hZ2UyRDogY29tcHJlc3NlZFRleEltYWdlMkQsXHJcblx0XHRcdHRleEltYWdlMkQ6IHRleEltYWdlMkQsXHJcblxyXG5cdFx0XHRzY2lzc29yOiBzY2lzc29yLFxyXG5cdFx0XHR2aWV3cG9ydDogdmlld3BvcnQsXHJcblxyXG5cdFx0XHRyZXNldDogcmVzZXRcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFdlYkdMQ2FwYWJpbGl0aWVzKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHR2YXIgbWF4QW5pc290cm9weTtcclxuXHJcblx0XHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXhBbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gbWF4QW5pc290cm9weTtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcclxuXHJcblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYXhBbmlzb3Ryb3B5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApIHtcclxuXHJcblx0XHRcdGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcclxuXHRcdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gJ2hpZ2hwJztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwcmVjaXNpb24gPSAnbWVkaXVtcCc7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHByZWNpc2lvbiA9PT0gJ21lZGl1bXAnICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxyXG5cdFx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuICdtZWRpdW1wJztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuICdsb3dwJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCc7XHJcblx0XHR2YXIgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKTtcclxuXHJcblx0XHRpZiAoIG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCBwcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIG1heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xyXG5cdFx0XHRwcmVjaXNpb24gPSBtYXhQcmVjaXNpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID09PSB0cnVlO1xyXG5cclxuXHRcdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHRcdHZhciBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XHJcblx0XHR2YXIgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX1NJWkUgKTtcclxuXHRcdHZhciBtYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xyXG5cclxuXHRcdHZhciBtYXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX0FUVFJJQlMgKTtcclxuXHRcdHZhciBtYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuXHRcdHZhciBtYXhWYXJ5aW5ncyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUyApO1xyXG5cdFx0dmFyIG1heEZyYWdtZW50VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuXHJcblx0XHR2YXIgdmVydGV4VGV4dHVyZXMgPSBtYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XHJcblx0XHR2YXIgZmxvYXRGcmFnbWVudFRleHR1cmVzID0gISEgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuXHRcdHZhciBmbG9hdFZlcnRleFRleHR1cmVzID0gdmVydGV4VGV4dHVyZXMgJiYgZmxvYXRGcmFnbWVudFRleHR1cmVzO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRnZXRNYXhBbmlzb3Ryb3B5OiBnZXRNYXhBbmlzb3Ryb3B5LFxyXG5cdFx0XHRnZXRNYXhQcmVjaXNpb246IGdldE1heFByZWNpc2lvbixcclxuXHJcblx0XHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxyXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxyXG5cclxuXHRcdFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxyXG5cdFx0XHRtYXhWZXJ0ZXhUZXh0dXJlczogbWF4VmVydGV4VGV4dHVyZXMsXHJcblx0XHRcdG1heFRleHR1cmVTaXplOiBtYXhUZXh0dXJlU2l6ZSxcclxuXHRcdFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxyXG5cclxuXHRcdFx0bWF4QXR0cmlidXRlczogbWF4QXR0cmlidXRlcyxcclxuXHRcdFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxyXG5cdFx0XHRtYXhWYXJ5aW5nczogbWF4VmFyeWluZ3MsXHJcblx0XHRcdG1heEZyYWdtZW50VW5pZm9ybXM6IG1heEZyYWdtZW50VW5pZm9ybXMsXHJcblxyXG5cdFx0XHR2ZXJ0ZXhUZXh0dXJlczogdmVydGV4VGV4dHVyZXMsXHJcblx0XHRcdGZsb2F0RnJhZ21lbnRUZXh0dXJlczogZmxvYXRGcmFnbWVudFRleHR1cmVzLFxyXG5cdFx0XHRmbG9hdFZlcnRleFRleHR1cmVzOiBmbG9hdFZlcnRleFRleHR1cmVzXHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xyXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xyXG5cclxuXHRcdENhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcclxuXHJcblx0XHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XHJcblx0XHR0aGlzLnpvb20gPSAxO1xyXG5cclxuXHRcdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XHJcblx0XHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcclxuXHRcdHRoaXMuZm9jdXMgPSAxMDtcclxuXHJcblx0XHR0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcclxuXHRcdHRoaXMudmlldyA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5maWxtR2F1Z2UgPSAzNTtcdC8vIHdpZHRoIG9mIHRoZSBmaWxtIChkZWZhdWx0IGluIG1pbGxpbWV0ZXJzKVxyXG5cdFx0dGhpcy5maWxtT2Zmc2V0ID0gMDtcdC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcclxuXHJcblx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcblx0fVxyXG5cclxuXHRQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDYW1lcmEucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogUGVyc3BlY3RpdmVDYW1lcmEsXHJcblxyXG5cdFx0aXNQZXJzcGVjdGl2ZUNhbWVyYTogdHJ1ZSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdFx0Q2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XHJcblx0XHRcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xyXG5cclxuXHRcdFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XHJcblx0XHRcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcclxuXHRcdFx0dGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcclxuXHJcblx0XHRcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcclxuXHRcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XHJcblxyXG5cdFx0XHR0aGlzLmZpbG1HYXVnZSA9IHNvdXJjZS5maWxtR2F1Z2U7XHJcblx0XHRcdHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIFRoZSBkZWZhdWx0IGZpbG0gZ2F1Z2UgaXMgMzUsIHNvIHRoYXQgdGhlIGZvY2FsIGxlbmd0aCBjYW4gYmUgc3BlY2lmaWVkIGZvclxyXG5cdFx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXHJcblx0XHQgKlxyXG5cdFx0ICogVmFsdWVzIGZvciBmb2NhbCBsZW5ndGggYW5kIGZpbG0gZ2F1Z2UgbXVzdCBoYXZlIHRoZSBzYW1lIHVuaXQuXHJcblx0XHQgKi9cclxuXHRcdHNldEZvY2FsTGVuZ3RoOiBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0Ly8gc2VlIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXHJcblx0XHRcdHZhciB2RXh0ZW50U2xvcGUgPSAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIGZvY2FsTGVuZ3RoO1xyXG5cclxuXHRcdFx0dGhpcy5mb3YgPSBfTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbiggdkV4dGVudFNsb3BlICk7XHJcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDYWxjdWxhdGVzIHRoZSBmb2NhbCBsZW5ndGggZnJvbSB0aGUgY3VycmVudCAuZm92IGFuZCAuZmlsbUdhdWdlLlxyXG5cdFx0ICovXHJcblx0XHRnZXRGb2NhbExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKCBfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKTtcclxuXHJcblx0XHRcdHJldHVybiAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIHZFeHRlbnRTbG9wZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldEVmZmVjdGl2ZUZPVjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIF9NYXRoLlJBRDJERUcgKiAyICogTWF0aC5hdGFuKFxyXG5cdFx0XHRcdE1hdGgudGFuKCBfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKSAvIHRoaXMuem9vbSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0RmlsbVdpZHRoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gcG9ydHJhaXQgZm9ybWF0IChhc3BlY3QgPCAxKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbiggdGhpcy5hc3BlY3QsIDEgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldEZpbG1IZWlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCggdGhpcy5hc3BlY3QsIDEgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxyXG5cdFx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cclxuXHRcdCAqXHJcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxyXG5cdFx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xyXG5cdFx0ICpcclxuXHRcdCAqICAgKy0tLSstLS0rLS0tK1xyXG5cdFx0ICogICB8IEEgfCBCIHwgQyB8XHJcblx0XHQgKiAgICstLS0rLS0tKy0tLStcclxuXHRcdCAqICAgfCBEIHwgRSB8IEYgfFxyXG5cdFx0ICogICArLS0tKy0tLSstLS0rXHJcblx0XHQgKlxyXG5cdFx0ICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xyXG5cdFx0ICpcclxuXHRcdCAqICAgdmFyIHcgPSAxOTIwO1xyXG5cdFx0ICogICB2YXIgaCA9IDEwODA7XHJcblx0XHQgKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcclxuXHRcdCAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcclxuXHRcdCAqXHJcblx0XHQgKiAgIC0tQS0tXHJcblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XHJcblx0XHQgKiAgIC0tQi0tXHJcblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XHJcblx0XHQgKiAgIC0tQy0tXHJcblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XHJcblx0XHQgKiAgIC0tRC0tXHJcblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XHJcblx0XHQgKiAgIC0tRS0tXHJcblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XHJcblx0XHQgKiAgIC0tRi0tXHJcblx0XHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XHJcblx0XHQgKlxyXG5cdFx0ICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxyXG5cdFx0ICovXHJcblx0XHRzZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRcdHRoaXMuYXNwZWN0ID0gZnVsbFdpZHRoIC8gZnVsbEhlaWdodDtcclxuXHJcblx0XHRcdGlmICggdGhpcy52aWV3ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnZpZXcgPSB7XHJcblx0XHRcdFx0XHRlbmFibGVkOiB0cnVlLFxyXG5cdFx0XHRcdFx0ZnVsbFdpZHRoOiAxLFxyXG5cdFx0XHRcdFx0ZnVsbEhlaWdodDogMSxcclxuXHRcdFx0XHRcdG9mZnNldFg6IDAsXHJcblx0XHRcdFx0XHRvZmZzZXRZOiAwLFxyXG5cdFx0XHRcdFx0d2lkdGg6IDEsXHJcblx0XHRcdFx0XHRoZWlnaHQ6IDFcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xyXG5cdFx0XHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XHJcblx0XHRcdHRoaXMudmlldy5vZmZzZXRYID0geDtcclxuXHRcdFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xyXG5cdFx0XHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIG5lYXIgPSB0aGlzLm5lYXIsXHJcblx0XHRcdFx0dG9wID0gbmVhciAqIE1hdGgudGFuKFxyXG5cdFx0XHRcdFx0X01hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20sXHJcblx0XHRcdFx0aGVpZ2h0ID0gMiAqIHRvcCxcclxuXHRcdFx0XHR3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0LFxyXG5cdFx0XHRcdGxlZnQgPSAtIDAuNSAqIHdpZHRoLFxyXG5cdFx0XHRcdHZpZXcgPSB0aGlzLnZpZXc7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxyXG5cdFx0XHRcdFx0ZnVsbEhlaWdodCA9IHZpZXcuZnVsbEhlaWdodDtcclxuXHJcblx0XHRcdFx0bGVmdCArPSB2aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcclxuXHRcdFx0XHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcclxuXHRcdFx0XHR3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xyXG5cdFx0XHRcdGhlaWdodCAqPSB2aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcclxuXHRcdFx0aWYgKCBza2V3ICE9PSAwICkgbGVmdCArPSBuZWFyICogc2tldyAvIHRoaXMuZ2V0RmlsbVdpZHRoKCk7XHJcblxyXG5cdFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCwgdG9wIC0gaGVpZ2h0LCBuZWFyLCB0aGlzLmZhciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuXHRcdFx0ZGF0YS5vYmplY3QuZm92ID0gdGhpcy5mb3Y7XHJcblx0XHRcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XHJcblxyXG5cdFx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xyXG5cdFx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcclxuXHRcdFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xyXG5cclxuXHRcdFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgdGhpcy52aWV3ICk7XHJcblxyXG5cdFx0XHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcclxuXHRcdFx0ZGF0YS5vYmplY3QuZmlsbU9mZnNldCA9IHRoaXMuZmlsbU9mZnNldDtcclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBBcnJheUNhbWVyYSggYXJyYXkgKSB7XHJcblxyXG5cdFx0UGVyc3BlY3RpdmVDYW1lcmEuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMuY2FtZXJhcyA9IGFycmF5IHx8IFtdO1xyXG5cclxuXHR9XHJcblxyXG5cdEFycmF5Q2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IEFycmF5Q2FtZXJhLFxyXG5cclxuXHRcdGlzQXJyYXlDYW1lcmE6IHRydWVcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJWUk1hbmFnZXIoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGRldmljZSA9IG51bGw7XHJcblx0XHR2YXIgZnJhbWVEYXRhID0gbnVsbDtcclxuXHJcblx0XHR2YXIgcG9zZVRhcmdldCA9IG51bGw7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnVlJGcmFtZURhdGEnIGluIHdpbmRvdyApIHtcclxuXHJcblx0XHRcdGZyYW1lRGF0YSA9IG5ldyB3aW5kb3cuVlJGcmFtZURhdGEoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0dmFyIGNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHRcdGNhbWVyYUwuYm91bmRzID0gbmV3IFZlY3RvcjQoIDAuMCwgMC4wLCAwLjUsIDEuMCApO1xyXG5cdFx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XHJcblxyXG5cdFx0dmFyIGNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHRcdGNhbWVyYVIuYm91bmRzID0gbmV3IFZlY3RvcjQoIDAuNSwgMC4wLCAwLjUsIDEuMCApO1xyXG5cdFx0Y2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XHJcblxyXG5cdFx0dmFyIGNhbWVyYVZSID0gbmV3IEFycmF5Q2FtZXJhKCBbIGNhbWVyYUwsIGNhbWVyYVIgXSApO1xyXG5cdFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSggMSApO1xyXG5cdFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSggMiApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIGN1cnJlbnRTaXplLCBjdXJyZW50UGl4ZWxSYXRpbztcclxuXHJcblx0XHRmdW5jdGlvbiBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UoKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRldmljZSAhPT0gbnVsbCAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZXllUGFyYW1ldGVycyA9IGRldmljZS5nZXRFeWVQYXJhbWV0ZXJzKCAnbGVmdCcgKTtcclxuXHRcdFx0XHR2YXIgcmVuZGVyV2lkdGggPSBleWVQYXJhbWV0ZXJzLnJlbmRlcldpZHRoO1xyXG5cdFx0XHRcdHZhciByZW5kZXJIZWlnaHQgPSBleWVQYXJhbWV0ZXJzLnJlbmRlckhlaWdodDtcclxuXHJcblx0XHRcdFx0Y3VycmVudFBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XHJcblx0XHRcdFx0Y3VycmVudFNpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XHJcblxyXG5cdFx0XHRcdHJlbmRlcmVyLnNldERyYXdpbmdCdWZmZXJTaXplKCByZW5kZXJXaWR0aCAqIDIsIHJlbmRlckhlaWdodCwgMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggc2NvcGUuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0RHJhd2luZ0J1ZmZlclNpemUoIGN1cnJlbnRTaXplLndpZHRoLCBjdXJyZW50U2l6ZS5oZWlnaHQsIGN1cnJlbnRQaXhlbFJhdGlvICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblxyXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3ZyZGlzcGxheXByZXNlbnRjaGFuZ2UnLCBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UsIGZhbHNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGV2aWNlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXREZXZpY2UgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgZGV2aWNlID0gdmFsdWU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFBvc2VUYXJnZXQgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSBwb3NlVGFyZ2V0ID0gb2JqZWN0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRDYW1lcmEgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGlmICggZGV2aWNlID09PSBudWxsICkgcmV0dXJuIGNhbWVyYTtcclxuXHJcblx0XHRcdGRldmljZS5kZXB0aE5lYXIgPSBjYW1lcmEubmVhcjtcclxuXHRcdFx0ZGV2aWNlLmRlcHRoRmFyID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRcdGRldmljZS5nZXRGcmFtZURhdGEoIGZyYW1lRGF0YSApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBwb3NlID0gZnJhbWVEYXRhLnBvc2U7XHJcblx0XHRcdHZhciBwb3NlT2JqZWN0ID0gcG9zZVRhcmdldCAhPT0gbnVsbCA/IHBvc2VUYXJnZXQgOiBjYW1lcmE7XHJcblxyXG5cdFx0XHRpZiAoIHBvc2UucG9zaXRpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHBvc2VPYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBwb3NlLnBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRwb3NlT2JqZWN0LnBvc2l0aW9uLnNldCggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwb3NlLm9yaWVudGF0aW9uICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRwb3NlT2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBwb3NlLm9yaWVudGF0aW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb3NlT2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0XHRpZiAoIGRldmljZS5pc1ByZXNlbnRpbmcgPT09IGZhbHNlICkgcmV0dXJuIGNhbWVyYTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRjYW1lcmFMLm5lYXIgPSBjYW1lcmEubmVhcjtcclxuXHRcdFx0Y2FtZXJhUi5uZWFyID0gY2FtZXJhLm5lYXI7XHJcblxyXG5cdFx0XHRjYW1lcmFMLmZhciA9IGNhbWVyYS5mYXI7XHJcblx0XHRcdGNhbWVyYVIuZmFyID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRcdGNhbWVyYVZSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRjYW1lcmFWUi5tYXRyaXhXb3JsZEludmVyc2UuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdFx0Y2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UuZnJvbUFycmF5KCBmcmFtZURhdGEubGVmdFZpZXdNYXRyaXggKTtcclxuXHRcdFx0Y2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UuZnJvbUFycmF5KCBmcmFtZURhdGEucmlnaHRWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHR2YXIgcGFyZW50ID0gcG9zZU9iamVjdC5wYXJlbnQ7XHJcblxyXG5cdFx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0bWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRjYW1lcmFMLm1hdHJpeFdvcmxkSW52ZXJzZS5tdWx0aXBseSggbWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRcdFx0Y2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UubXVsdGlwbHkoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZW52TWFwIGFuZCBNaXJyb3IgbmVlZHMgY2FtZXJhLm1hdHJpeFdvcmxkXHJcblxyXG5cdFx0XHRjYW1lcmFMLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIGNhbWVyYUwubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblx0XHRcdGNhbWVyYVIubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggY2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHJcblx0XHRcdGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5mcm9tQXJyYXkoIGZyYW1lRGF0YS5sZWZ0UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRjYW1lcmFSLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KCBmcmFtZURhdGEucmlnaHRQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHQvLyBIQUNLIEBtcmRvb2JcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2ci9pc3N1ZXMvMjAzXHJcblxyXG5cdFx0XHRjYW1lcmFWUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBsYXllcnMgPSBkZXZpY2UuZ2V0TGF5ZXJzKCk7XHJcblxyXG5cdFx0XHRpZiAoIGxheWVycy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsYXllciA9IGxheWVyc1sgMCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxheWVyLmxlZnRCb3VuZHMgIT09IG51bGwgJiYgbGF5ZXIubGVmdEJvdW5kcy5sZW5ndGggPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FtZXJhTC5ib3VuZHMuZnJvbUFycmF5KCBsYXllci5sZWZ0Qm91bmRzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBsYXllci5yaWdodEJvdW5kcyAhPT0gbnVsbCAmJiBsYXllci5yaWdodEJvdW5kcy5sZW5ndGggPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FtZXJhUi5ib3VuZHMuZnJvbUFycmF5KCBsYXllci5yaWdodEJvdW5kcyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FtZXJhVlI7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnN1Ym1pdEZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCBkZXZpY2UgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIGRldmljZS5zdWJtaXRGcmFtZSgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyApIHtcclxuXHJcblx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd2cmRpc3BsYXlwcmVzZW50Y2hhbmdlJywgb25WUkRpc3BsYXlQcmVzZW50Q2hhbmdlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoIGdsICkge1xyXG5cclxuXHRcdHZhciBleHRlbnNpb25zID0ge307XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbnNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGV4dGVuc2lvbjtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggbmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcclxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJzpcclxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxyXG5cdFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxyXG5cdFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnOlxyXG5cdFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRleHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XHJcblxyXG5cdFx0XHRcdHJldHVybiBleHRlbnNpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFdlYkdMQ2xpcHBpbmcoKSB7XHJcblxyXG5cdFx0dmFyIHNjb3BlID0gdGhpcyxcclxuXHJcblx0XHRcdGdsb2JhbFN0YXRlID0gbnVsbCxcclxuXHRcdFx0bnVtR2xvYmFsUGxhbmVzID0gMCxcclxuXHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcclxuXHRcdFx0cmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlLFxyXG5cclxuXHRcdFx0cGxhbmUgPSBuZXcgUGxhbmUoKSxcclxuXHRcdFx0dmlld05vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCksXHJcblxyXG5cdFx0XHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XHJcblxyXG5cdFx0dGhpcy51bmlmb3JtID0gdW5pZm9ybTtcclxuXHRcdHRoaXMubnVtUGxhbmVzID0gMDtcclxuXHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gMDtcclxuXHJcblx0XHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0dmFyIGVuYWJsZWQgPVxyXG5cdFx0XHRcdHBsYW5lcy5sZW5ndGggIT09IDAgfHxcclxuXHRcdFx0XHRlbmFibGVMb2NhbENsaXBwaW5nIHx8XHJcblx0XHRcdFx0Ly8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXHJcblx0XHRcdFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxyXG5cdFx0XHRcdG51bUdsb2JhbFBsYW5lcyAhPT0gMCB8fFxyXG5cdFx0XHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkO1xyXG5cclxuXHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xyXG5cclxuXHRcdFx0Z2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgMCApO1xyXG5cdFx0XHRudW1HbG9iYWxQbGFuZXMgPSBwbGFuZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0cmV0dXJuIGVuYWJsZWQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmJlZ2luU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xyXG5cdFx0XHRwcm9qZWN0UGxhbmVzKCBudWxsICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2U7XHJcblx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoIHBsYW5lcywgY2xpcEludGVyc2VjdGlvbiwgY2xpcFNoYWRvd3MsIGNhbWVyYSwgY2FjaGUsIGZyb21DYWNoZSApIHtcclxuXHJcblx0XHRcdGlmICggISBsb2NhbENsaXBwaW5nRW5hYmxlZCB8fCBwbGFuZXMgPT09IG51bGwgfHwgcGxhbmVzLmxlbmd0aCA9PT0gMCB8fCByZW5kZXJpbmdTaGFkb3dzICYmICEgY2xpcFNoYWRvd3MgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoZXJlJ3Mgbm8gbG9jYWwgY2xpcHBpbmdcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJpbmdTaGFkb3dzICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXHJcblxyXG5cdFx0XHRcdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dmFyIG5HbG9iYWwgPSByZW5kZXJpbmdTaGFkb3dzID8gMCA6IG51bUdsb2JhbFBsYW5lcyxcclxuXHRcdFx0XHRcdGxHbG9iYWwgPSBuR2xvYmFsICogNCxcclxuXHJcblx0XHRcdFx0XHRkc3RBcnJheSA9IGNhY2hlLmNsaXBwaW5nU3RhdGUgfHwgbnVsbDtcclxuXHJcblx0XHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5OyAvLyBlbnN1cmUgdW5pcXVlIHN0YXRlXHJcblxyXG5cdFx0XHRcdGRzdEFycmF5ID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGxHbG9iYWwsIGZyb21DYWNoZSApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IGxHbG9iYWw7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZHN0QXJyYXlbIGkgXSA9IGdsb2JhbFN0YXRlWyBpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FjaGUuY2xpcHBpbmdTdGF0ZSA9IGRzdEFycmF5O1xyXG5cdFx0XHRcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcclxuXHRcdFx0XHR0aGlzLm51bVBsYW5lcyArPSBuR2xvYmFsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHVuaWZvcm0udmFsdWUgIT09IGdsb2JhbFN0YXRlICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XHJcblx0XHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XHJcblx0XHRcdHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBkc3RPZmZzZXQsIHNraXBUcmFuc2Zvcm0gKSB7XHJcblxyXG5cdFx0XHR2YXIgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwLFxyXG5cdFx0XHRcdGRzdEFycmF5ID0gbnVsbDtcclxuXHJcblx0XHRcdGlmICggblBsYW5lcyAhPT0gMCApIHtcclxuXHJcblx0XHRcdFx0ZHN0QXJyYXkgPSB1bmlmb3JtLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNraXBUcmFuc2Zvcm0gIT09IHRydWUgfHwgZHN0QXJyYXkgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXHJcblx0XHRcdFx0XHRcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xyXG5cclxuXHRcdFx0XHRcdHZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB2aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGRzdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggZmxhdFNpemUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpNCA9IGRzdE9mZnNldDsgaSAhPT0gblBsYW5lczsgKysgaSwgaTQgKz0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHBsYW5lLmNvcHkoIHBsYW5lc1sgaSBdICkuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4LCB2aWV3Tm9ybWFsTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRwbGFuZS5ub3JtYWwudG9BcnJheSggZHN0QXJyYXksIGk0ICk7XHJcblx0XHRcdFx0XHRcdGRzdEFycmF5WyBpNCArIDMgXSA9IHBsYW5lLmNvbnN0YW50O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7XHJcblx0XHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xyXG5cclxuXHRcdFx0cmV0dXJuIGRzdEFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHRoZXNwaXRlIC8gaHR0cDovL3d3dy50d2l0dGVyLmNvbS90aGVzcGl0ZVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFV0aWxzKCBnbCwgZXh0ZW5zaW9ucyApIHtcclxuXHJcblx0XHRmdW5jdGlvbiBjb252ZXJ0KCBwICkge1xyXG5cclxuXHRcdFx0dmFyIGV4dGVuc2lvbjtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gZ2wuUkVQRUFUO1xyXG5cdFx0XHRpZiAoIHAgPT09IENsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gZ2wuQ0xBTVBfVE9fRURHRTtcclxuXHRcdFx0aWYgKCBwID09PSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIGdsLk1JUlJPUkVEX1JFUEVBVDtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gTmVhcmVzdEZpbHRlciApIHJldHVybiBnbC5ORUFSRVNUO1xyXG5cdFx0XHRpZiAoIHAgPT09IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XHJcblx0XHRcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IExpbmVhckZpbHRlciApIHJldHVybiBnbC5MSU5FQVI7XHJcblx0XHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XHJcblx0XHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBVbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XHJcblx0XHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XHJcblx0XHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XHJcblx0XHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IEJ5dGVUeXBlICkgcmV0dXJuIGdsLkJZVEU7XHJcblx0XHRcdGlmICggcCA9PT0gU2hvcnRUeXBlICkgcmV0dXJuIGdsLlNIT1JUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUO1xyXG5cdFx0XHRpZiAoIHAgPT09IEludFR5cGUgKSByZXR1cm4gZ2wuSU5UO1xyXG5cdFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9JTlQ7XHJcblx0XHRcdGlmICggcCA9PT0gRmxvYXRUeXBlICkgcmV0dXJuIGdsLkZMT0FUO1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkge1xyXG5cclxuXHRcdFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XHJcblxyXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuQUxQSEE7XHJcblx0XHRcdGlmICggcCA9PT0gUkdCRm9ybWF0ICkgcmV0dXJuIGdsLlJHQjtcclxuXHRcdFx0aWYgKCBwID09PSBSR0JBRm9ybWF0ICkgcmV0dXJuIGdsLlJHQkE7XHJcblx0XHRcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRTtcclxuXHRcdFx0aWYgKCBwID09PSBMdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XHJcblx0XHRcdGlmICggcCA9PT0gRGVwdGhGb3JtYXQgKSByZXR1cm4gZ2wuREVQVEhfQ09NUE9ORU5UO1xyXG5cdFx0XHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9TVEVOQ0lMO1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBBZGRFcXVhdGlvbiApIHJldHVybiBnbC5GVU5DX0FERDtcclxuXHRcdFx0aWYgKCBwID09PSBTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIGdsLkZVTkNfU1VCVFJBQ1Q7XHJcblx0XHRcdGlmICggcCA9PT0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xyXG5cclxuXHRcdFx0aWYgKCBwID09PSBaZXJvRmFjdG9yICkgcmV0dXJuIGdsLlpFUk87XHJcblx0XHRcdGlmICggcCA9PT0gT25lRmFjdG9yICkgcmV0dXJuIGdsLk9ORTtcclxuXHRcdFx0aWYgKCBwID09PSBTcmNDb2xvckZhY3RvciApIHJldHVybiBnbC5TUkNfQ09MT1I7XHJcblx0XHRcdGlmICggcCA9PT0gT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xyXG5cdFx0XHRpZiAoIHAgPT09IFNyY0FscGhhRmFjdG9yICkgcmV0dXJuIGdsLlNSQ19BTFBIQTtcclxuXHRcdFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIGdsLk9ORV9NSU5VU19TUkNfQUxQSEE7XHJcblx0XHRcdGlmICggcCA9PT0gRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuRFNUX0FMUEhBO1xyXG5cdFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuRFNUX0NPTE9SO1xyXG5cdFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcclxuXHRcdFx0aWYgKCBwID09PSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIGdsLlNSQ19BTFBIQV9TQVRVUkFURTtcclxuXHJcblx0XHRcdGlmICggcCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8XHJcblx0XHRcdFx0cCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fFxyXG5cdFx0XHRcdHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHAgPT09IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcclxuXHRcdFx0XHRcdGlmICggcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgKSB7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XHJcblxyXG5cdFx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwID09PSBNaW5FcXVhdGlvbiB8fCBwID09PSBNYXhFcXVhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHAgPT09IE1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xyXG5cdFx0XHRcdFx0aWYgKCBwID09PSBNYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBwID09PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSByZXR1cm4gZXh0ZW5zaW9uLlVOU0lHTkVEX0lOVF8yNF84X1dFQkdMO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIDA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7IGNvbnZlcnQ6IGNvbnZlcnQgfTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXHJcblx0ICogQGF1dGhvciB0c2Nod1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXZWJHTFJlbmRlcmVyKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcicsIFJFVklTSU9OICk7XHJcblxyXG5cdFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XHJcblxyXG5cdFx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKSxcclxuXHRcdFx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXHJcblxyXG5cdFx0XHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXHJcblx0XHRcdF9kZXB0aCA9IHBhcmFtZXRlcnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGggOiB0cnVlLFxyXG5cdFx0XHRfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcclxuXHRcdFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG5cdFx0XHRfcHJlbXVsdGlwbGllZEFscGhhID0gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIDogdHJ1ZSxcclxuXHRcdFx0X3ByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6IGZhbHNlLFxyXG5cdFx0XHRfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnO1xyXG5cclxuXHRcdHZhciBsaWdodHNBcnJheSA9IFtdO1xyXG5cdFx0dmFyIHNoYWRvd3NBcnJheSA9IFtdO1xyXG5cclxuXHRcdHZhciBjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XHJcblxyXG5cdFx0dmFyIHNwcml0ZXNBcnJheSA9IFtdO1xyXG5cdFx0dmFyIGZsYXJlc0FycmF5ID0gW107XHJcblxyXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcclxuXHJcblx0XHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xyXG5cdFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHJcblx0XHQvLyBjbGVhcmluZ1xyXG5cclxuXHRcdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcclxuXHRcdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xyXG5cdFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XHJcblx0XHR0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xyXG5cclxuXHRcdC8vIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XHJcblxyXG5cdFx0Ly8gdXNlci1kZWZpbmVkIGNsaXBwaW5nXHJcblxyXG5cdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IFtdO1xyXG5cdFx0dGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xyXG5cclxuXHRcdHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7XHQvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHRcdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIHBoeXNpY2FsIGxpZ2h0c1xyXG5cclxuXHRcdHRoaXMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHQvLyB0b25lIG1hcHBpbmdcclxuXHJcblx0XHR0aGlzLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmc7XHJcblx0XHR0aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLjA7XHJcblx0XHR0aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCA9IDEuMDtcclxuXHJcblx0XHQvLyBtb3JwaHNcclxuXHJcblx0XHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XHJcblx0XHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XHJcblxyXG5cdFx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xyXG5cclxuXHRcdHZhciBfdGhpcyA9IHRoaXMsXHJcblxyXG5cdFx0XHRfaXNDb250ZXh0TG9zdCA9IGZhbHNlLFxyXG5cclxuXHRcdFx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcclxuXHJcblx0XHRcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbCxcclxuXHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXHJcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMSxcclxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcclxuXHJcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcclxuXHRcdFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IG51bGwsXHJcblxyXG5cdFx0XHRfY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKSxcclxuXHRcdFx0X2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKSxcclxuXHRcdFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IG51bGwsXHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdF93aWR0aCA9IF9jYW52YXMud2lkdGgsXHJcblx0XHRcdF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcclxuXHJcblx0XHRcdF9waXhlbFJhdGlvID0gMSxcclxuXHJcblx0XHRcdF92aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcclxuXHRcdFx0X3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXHJcblx0XHRcdF9zY2lzc29yVGVzdCA9IGZhbHNlLFxyXG5cclxuXHRcdFx0Ly8gZnJ1c3R1bVxyXG5cclxuXHRcdFx0X2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpLFxyXG5cclxuXHRcdFx0Ly8gY2xpcHBpbmdcclxuXHJcblx0XHRcdF9jbGlwcGluZyA9IG5ldyBXZWJHTENsaXBwaW5nKCksXHJcblx0XHRcdF9jbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcclxuXHRcdFx0X2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXHJcblxyXG5cdFx0XHQvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcclxuXHJcblx0XHRcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcclxuXHJcblx0XHRcdF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKSxcclxuXHJcblx0XHRcdC8vIGluZm9cclxuXHJcblx0XHRcdF9pbmZvTWVtb3J5ID0ge1xyXG5cdFx0XHRcdGdlb21ldHJpZXM6IDAsXHJcblx0XHRcdFx0dGV4dHVyZXM6IDBcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdF9pbmZvUmVuZGVyID0ge1xyXG5cclxuXHRcdFx0XHRmcmFtZTogMCxcclxuXHRcdFx0XHRjYWxsczogMCxcclxuXHRcdFx0XHR2ZXJ0aWNlczogMCxcclxuXHRcdFx0XHRmYWNlczogMCxcclxuXHRcdFx0XHRwb2ludHM6IDBcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0dGhpcy5pbmZvID0ge1xyXG5cclxuXHRcdFx0cmVuZGVyOiBfaW5mb1JlbmRlcixcclxuXHRcdFx0bWVtb3J5OiBfaW5mb01lbW9yeSxcclxuXHRcdFx0cHJvZ3JhbXM6IG51bGxcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFRhcmdldFBpeGVsUmF0aW8oKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgPyBfcGl4ZWxSYXRpbyA6IDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluaXRpYWxpemVcclxuXHJcblx0XHR2YXIgX2dsO1xyXG5cclxuXHRcdHRyeSB7XHJcblxyXG5cdFx0XHR2YXIgY29udGV4dEF0dHJpYnV0ZXMgPSB7XHJcblx0XHRcdFx0YWxwaGE6IF9hbHBoYSxcclxuXHRcdFx0XHRkZXB0aDogX2RlcHRoLFxyXG5cdFx0XHRcdHN0ZW5jaWw6IF9zdGVuY2lsLFxyXG5cdFx0XHRcdGFudGlhbGlhczogX2FudGlhbGlhcyxcclxuXHRcdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsXHJcblx0XHRcdFx0cHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyLFxyXG5cdFx0XHRcdHBvd2VyUHJlZmVyZW5jZTogX3Bvd2VyUHJlZmVyZW5jZVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Ly8gZXZlbnQgbGlzdGVuZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgV2ViR0wgY29udGV4dCBpcyBjcmVhdGVkLCBzZWUgIzEyNzUzXHJcblxyXG5cdFx0XHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcclxuXHRcdFx0X2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0X2dsID0gX2NvbnRleHQgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnLCBjb250ZXh0QXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNvbnRleHRBdHRyaWJ1dGVzICk7XHJcblxyXG5cdFx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLicgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0LicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxyXG5cclxuXHRcdFx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHsgJ3JhbmdlTWluJzogMSwgJ3JhbmdlTWF4JzogMSwgJ3ByZWNpc2lvbic6IDEgfTtcclxuXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yLm1lc3NhZ2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGU7XHJcblx0XHR2YXIgcHJvcGVydGllcywgdGV4dHVyZXMsIGF0dHJpYnV0ZXMsIGdlb21ldHJpZXMsIG9iamVjdHMsIGxpZ2h0cztcclxuXHRcdHZhciBwcm9ncmFtQ2FjaGUsIHJlbmRlckxpc3RzO1xyXG5cclxuXHRcdHZhciBiYWNrZ3JvdW5kLCBtb3JwaHRhcmdldHMsIGJ1ZmZlclJlbmRlcmVyLCBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XHJcblx0XHR2YXIgZmxhcmVSZW5kZXJlciwgc3ByaXRlUmVuZGVyZXI7XHJcblxyXG5cdFx0dmFyIHV0aWxzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGluaXRHTENvbnRleHQoKSB7XHJcblxyXG5cdFx0XHRleHRlbnNpb25zID0gbmV3IFdlYkdMRXh0ZW5zaW9ucyggX2dsICk7XHJcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICk7XHJcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKTtcclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XHJcblx0XHRcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKTtcclxuXHRcdFx0ZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdFx0dXRpbHMgPSBuZXcgV2ViR0xVdGlscyggX2dsLCBleHRlbnNpb25zICk7XHJcblxyXG5cdFx0XHRjYXBhYmlsaXRpZXMgPSBuZXcgV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdFx0c3RhdGUgPSBuZXcgV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCB1dGlscyApO1xyXG5cdFx0XHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xyXG5cdFx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xyXG5cclxuXHRcdFx0cHJvcGVydGllcyA9IG5ldyBXZWJHTFByb3BlcnRpZXMoKTtcclxuXHRcdFx0dGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgX2luZm9NZW1vcnkgKTtcclxuXHRcdFx0YXR0cmlidXRlcyA9IG5ldyBXZWJHTEF0dHJpYnV0ZXMoIF9nbCApO1xyXG5cdFx0XHRnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyggX2dsLCBhdHRyaWJ1dGVzLCBfaW5mb01lbW9yeSApO1xyXG5cdFx0XHRvYmplY3RzID0gbmV3IFdlYkdMT2JqZWN0cyggZ2VvbWV0cmllcywgX2luZm9SZW5kZXIgKTtcclxuXHRcdFx0bW9ycGh0YXJnZXRzID0gbmV3IFdlYkdMTW9ycGh0YXJnZXRzKCBfZ2wgKTtcclxuXHRcdFx0cHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIF90aGlzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKTtcclxuXHRcdFx0bGlnaHRzID0gbmV3IFdlYkdMTGlnaHRzKCk7XHJcblx0XHRcdHJlbmRlckxpc3RzID0gbmV3IFdlYkdMUmVuZGVyTGlzdHMoKTtcclxuXHJcblx0XHRcdGJhY2tncm91bmQgPSBuZXcgV2ViR0xCYWNrZ3JvdW5kKCBfdGhpcywgc3RhdGUsIGdlb21ldHJpZXMsIF9wcmVtdWx0aXBsaWVkQWxwaGEgKTtcclxuXHJcblx0XHRcdGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKTtcclxuXHRcdFx0aW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XHJcblxyXG5cdFx0XHRmbGFyZVJlbmRlcmVyID0gbmV3IFdlYkdMRmxhcmVSZW5kZXJlciggX3RoaXMsIF9nbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKTtcclxuXHRcdFx0c3ByaXRlUmVuZGVyZXIgPSBuZXcgV2ViR0xTcHJpdGVSZW5kZXJlciggX3RoaXMsIF9nbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucHJvZ3JhbXMgPSBwcm9ncmFtQ2FjaGUucHJvZ3JhbXM7XHJcblxyXG5cdFx0XHRfdGhpcy5jb250ZXh0ID0gX2dsO1xyXG5cdFx0XHRfdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XHJcblx0XHRcdF90aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG5cdFx0XHRfdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHRcdFx0X3RoaXMucmVuZGVyTGlzdHMgPSByZW5kZXJMaXN0cztcclxuXHRcdFx0X3RoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aW5pdEdMQ29udGV4dCgpO1xyXG5cclxuXHRcdC8vIHZyXHJcblxyXG5cdFx0dmFyIHZyID0gbmV3IFdlYlZSTWFuYWdlciggX3RoaXMgKTtcclxuXHJcblx0XHR0aGlzLnZyID0gdnI7XHJcblxyXG5cdFx0Ly8gc2hhZG93IG1hcFxyXG5cclxuXHRcdHZhciBzaGFkb3dNYXAgPSBuZXcgV2ViR0xTaGFkb3dNYXAoIF90aGlzLCBvYmplY3RzLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcclxuXHJcblx0XHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcclxuXHJcblx0XHQvLyBBUElcclxuXHJcblx0XHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2dsO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5nZXRDb250ZXh0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcclxuXHRcdFx0aWYgKCBleHRlbnNpb24gKSBleHRlbnNpb24ubG9zZUNvbnRleHQoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcclxuXHRcdFx0aWYgKCBleHRlbnNpb24gKSBleHRlbnNpb24ucmVzdG9yZUNvbnRleHQoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBfcGl4ZWxSYXRpbztcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdFx0XHRfcGl4ZWxSYXRpbyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRTaXplKCBfd2lkdGgsIF9oZWlnaHQsIGZhbHNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHdpZHRoOiBfd2lkdGgsXHJcblx0XHRcdFx0aGVpZ2h0OiBfaGVpZ2h0XHJcblx0XHRcdH07XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xyXG5cclxuXHRcdFx0dmFyIGRldmljZSA9IHZyLmdldERldmljZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBkZXZpY2UgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ2FuXFwndCBjaGFuZ2Ugc2l6ZSB3aGlsZSBWUiBkZXZpY2UgaXMgcHJlc2VudGluZy4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3dpZHRoID0gd2lkdGg7XHJcblx0XHRcdF9oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdFx0XHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBfcGl4ZWxSYXRpbztcclxuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBfcGl4ZWxSYXRpbztcclxuXHJcblx0XHRcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRfY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xyXG5cdFx0XHRcdF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHdpZHRoOiBfd2lkdGggKiBfcGl4ZWxSYXRpbyxcclxuXHRcdFx0XHRoZWlnaHQ6IF9oZWlnaHQgKiBfcGl4ZWxSYXRpb1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyApIHtcclxuXHJcblx0XHRcdF93aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRfaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRcdFx0X3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xyXG5cclxuXHRcdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcclxuXHRcdFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRcdF92aWV3cG9ydC5zZXQoIHgsIF9oZWlnaHQgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblx0XHRcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0XHRfc2Npc3Nvci5zZXQoIHgsIF9oZWlnaHQgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblx0XHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xyXG5cclxuXHRcdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9zY2lzc29yVGVzdCA9IGJvb2xlYW4gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIENsZWFyaW5nXHJcblxyXG5cdFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGJhY2tncm91bmQuZ2V0Q2xlYXJDb2xvcigpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0YmFja2dyb3VuZC5zZXRDbGVhckNvbG9yLmFwcGx5KCBiYWNrZ3JvdW5kLCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBiYWNrZ3JvdW5kLmdldENsZWFyQWxwaGEoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGJhY2tncm91bmQuc2V0Q2xlYXJBbHBoYS5hcHBseSggYmFja2dyb3VuZCwgYXJndW1lbnRzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgYml0cyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xyXG5cdFx0XHRpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xyXG5cdFx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdFx0X2dsLmNsZWFyKCBiaXRzICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuY2xlYXIoIGZhbHNlLCB0cnVlLCBmYWxzZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xyXG5cclxuXHRcdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cdFx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XHJcblx0XHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRcdHZyLmRpc3Bvc2UoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEV2ZW50c1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uQ29udGV4dExvc3QoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LicgKTtcclxuXHJcblx0XHRcdF9pc0NvbnRleHRMb3N0ID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Db250ZXh0UmVzdG9yZSggLyogZXZlbnQgKi8gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgUmVzdG9yZWQuJyApO1xyXG5cclxuXHRcdFx0X2lzQ29udGV4dExvc3QgPSBmYWxzZTtcclxuXHJcblx0XHRcdGluaXRHTENvbnRleHQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXHJcblxyXG5cdFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRwcm9wZXJ0aWVzLnJlbW92ZSggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcclxuXHJcblx0XHRcdG1hdGVyaWFsLnByb2dyYW0gPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdEltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0dmFyIGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIGJ1ZmZlcnMubm9ybWFsICkgYnVmZmVycy5ub3JtYWwgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiAhIGJ1ZmZlcnMudXYgKSBidWZmZXJzLnV2ID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgJiZcclxuXHRcdFx0XHRcdCEgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCAmJlxyXG5cdFx0XHRcdFx0ISBtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCAmJlxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuZmxhdFNoYWRpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNvdW50ICogMzsgaSA8IGw7IGkgKz0gOSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBueCA9ICggYXJyYXlbIGkgKyAwIF0gKyBhcnJheVsgaSArIDMgXSArIGFycmF5WyBpICsgNiBdICkgLyAzO1xyXG5cdFx0XHRcdFx0XHR2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcclxuXHRcdFx0XHRcdFx0dmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XHJcblxyXG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDAgXSA9IG54O1xyXG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDEgXSA9IG55O1xyXG5cdFx0XHRcdFx0XHRhcnJheVsgaSArIDIgXSA9IG56O1xyXG5cclxuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyAzIF0gPSBueDtcclxuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyA0IF0gPSBueTtcclxuXHRcdFx0XHRcdFx0YXJyYXlbIGkgKyA1IF0gPSBuejtcclxuXHJcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgNiBdID0gbng7XHJcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgNyBdID0gbnk7XHJcblx0XHRcdFx0XHRcdGFycmF5WyBpICsgOCBdID0gbno7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy51diApO1xyXG5cclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IE5vQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcclxuXHJcblx0XHRcdG9iamVjdC5jb3VudCA9IDA7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcclxuXHJcblx0XHRcdHZhciBmcm9udEZhY2VDVyA9ICggb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAgKTtcclxuXHJcblx0XHRcdHN0YXRlLnNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKTtcclxuXHJcblx0XHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHRcdFx0dmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICk7XHJcblxyXG5cdFx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xyXG5cclxuXHRcdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcclxuXHRcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcclxuXHJcblx0XHRcdFx0bW9ycGh0YXJnZXRzLnVwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XHJcblx0XHRcdHZhciByYW5nZUZhY3RvciA9IDE7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBnZW9tZXRyaWVzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcclxuXHRcdFx0XHRyYW5nZUZhY3RvciA9IDI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlO1xyXG5cdFx0XHR2YXIgcmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcclxuXHJcblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KCBpbmRleCApO1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlciA9IGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcclxuXHRcdFx0XHRyZW5kZXJlci5zZXRJbmRleCggYXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYXR0cmlidXRlLmJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0dmFyIGRhdGFDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRkYXRhQ291bnQgPSBpbmRleC5jb3VudDtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGFDb3VudCA9IHBvc2l0aW9uLmNvdW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKiByYW5nZUZhY3RvcjtcclxuXHRcdFx0dmFyIHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgKiByYW5nZUZhY3RvcjtcclxuXHJcblx0XHRcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCAqIHJhbmdlRmFjdG9yIDogMDtcclxuXHRcdFx0dmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50ICogcmFuZ2VGYWN0b3IgOiBJbmZpbml0eTtcclxuXHJcblx0XHRcdHZhciBkcmF3U3RhcnQgPSBNYXRoLm1heCggcmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApO1xyXG5cdFx0XHR2YXIgZHJhd0VuZCA9IE1hdGgubWluKCBkYXRhQ291bnQsIHJhbmdlU3RhcnQgKyByYW5nZUNvdW50LCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCApIC0gMTtcclxuXHJcblx0XHRcdHZhciBkcmF3Q291bnQgPSBNYXRoLm1heCggMCwgZHJhd0VuZCAtIGRyYXdTdGFydCArIDEgKTtcclxuXHJcblx0XHRcdGlmICggZHJhd0NvdW50ID09PSAwICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcclxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIG9iamVjdC5kcmF3TW9kZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgVHJpYW5nbGVzRHJhd01vZGU6XHJcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSBUcmlhbmdsZVN0cmlwRHJhd01vZGU6XHJcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX1NUUklQICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlIFRyaWFuZ2xlRmFuRHJhd01vZGU6XHJcblx0XHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0xpbmUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XHJcblxyXG5cdFx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxyXG5cclxuXHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIGxpbmVXaWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0xpbmVTZWdtZW50cyApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZUxvb3AgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfTE9PUCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FX1NUUklQICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1BvaW50cyApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJlci5yZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICkgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkICkgc3RhcnRJbmRleCA9IDA7XHJcblxyXG5cdFx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlID0gcHJvZ3JhbUF0dHJpYnV0ZXNbIG5hbWUgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbGl6ZWQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5ub3JtYWxpemVkO1xyXG5cdFx0XHRcdFx0XHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KCBnZW9tZXRyeUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gVE9ETyBBdHRyaWJ1dGUgbWF5IG5vdCBiZSBhdmFpbGFibGUgb24gY29udGV4dCByZXN0b3JlXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcclxuXHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcclxuXHRcdFx0XHRcdFx0dmFyIGJ5dGVzUGVyRWxlbWVudCA9IGF0dHJpYnV0ZS5ieXRlc1BlckVsZW1lbnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3RyaWRlID0gZGF0YS5zdHJpZGU7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhICYmIGRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBkYXRhLm1lc2hQZXJBdHRyaWJ1dGUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlICogYnl0ZXNQZXJFbGVtZW50LCAoIHN0YXJ0SW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKSAqIGJ5dGVzUGVyRWxlbWVudCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiBieXRlc1BlckVsZW1lbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMmZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjFmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29tcGlsZVxyXG5cclxuXHRcdHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGxpZ2h0c0FycmF5Lmxlbmd0aCA9IDA7XHJcblx0XHRcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xyXG5cclxuXHRcdFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdGxpZ2h0c0FycmF5LnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzaGFkb3dzQXJyYXkucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRsaWdodHMuc2V0dXAoIGxpZ2h0c0FycmF5LCBzaGFkb3dzQXJyYXksIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC5tYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdC5tYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm1hdGVyaWFsLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW5pdE1hdGVyaWFsKCBvYmplY3QubWF0ZXJpYWxbIGkgXSwgc2NlbmUuZm9nLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0aW5pdE1hdGVyaWFsKCBvYmplY3QubWF0ZXJpYWwsIHNjZW5lLmZvZywgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBBbmltYXRpb24gTG9vcFxyXG5cclxuXHRcdHZhciBpc0FuaW1hdGluZyA9IGZhbHNlO1xyXG5cdFx0dmFyIG9uQW5pbWF0aW9uRnJhbWUgPSBudWxsO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHN0YXJ0KCkge1xyXG5cclxuXHRcdFx0aWYgKCBpc0FuaW1hdGluZyApIHJldHVybjtcclxuXHJcblx0XHRcdHZhciBkZXZpY2UgPSB2ci5nZXREZXZpY2UoKTtcclxuXHJcblx0XHRcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGRldmljZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlzQW5pbWF0aW5nID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbG9vcCggdGltZSApIHtcclxuXHJcblx0XHRcdGlmICggb25BbmltYXRpb25GcmFtZSAhPT0gbnVsbCApIG9uQW5pbWF0aW9uRnJhbWUoIHRpbWUgKTtcclxuXHJcblx0XHRcdHZhciBkZXZpY2UgPSB2ci5nZXREZXZpY2UoKTtcclxuXHJcblx0XHRcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdGRldmljZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hbmltYXRlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRcdG9uQW5pbWF0aW9uRnJhbWUgPSBjYWxsYmFjaztcclxuXHRcdFx0c3RhcnQoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFJlbmRlcmluZ1xyXG5cclxuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgKCBjYW1lcmEgJiYgY2FtZXJhLmlzQ2FtZXJhICkgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggX2lzQ29udGV4dExvc3QgKSByZXR1cm47XHJcblxyXG5cdFx0XHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXHJcblxyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xyXG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XHJcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxyXG5cclxuXHRcdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cclxuXHJcblx0XHRcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gbnVsbCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdFx0aWYgKCB2ci5lbmFibGVkICkge1xyXG5cclxuXHRcdFx0XHRjYW1lcmEgPSB2ci5nZXRDYW1lcmEoIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdGxpZ2h0c0FycmF5Lmxlbmd0aCA9IDA7XHJcblx0XHRcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xyXG5cclxuXHRcdFx0c3ByaXRlc0FycmF5Lmxlbmd0aCA9IDA7XHJcblx0XHRcdGZsYXJlc0FycmF5Lmxlbmd0aCA9IDA7XHJcblxyXG5cdFx0XHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xyXG5cdFx0XHRfY2xpcHBpbmdFbmFibGVkID0gX2NsaXBwaW5nLmluaXQoIHRoaXMuY2xpcHBpbmdQbGFuZXMsIF9sb2NhbENsaXBwaW5nRW5hYmxlZCwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdCA9IHJlbmRlckxpc3RzLmdldCggc2NlbmUsIGNhbWVyYSApO1xyXG5cdFx0XHRjdXJyZW50UmVuZGVyTGlzdC5pbml0KCk7XHJcblxyXG5cdFx0XHRwcm9qZWN0T2JqZWN0KCBzY2VuZSwgY2FtZXJhLCBfdGhpcy5zb3J0T2JqZWN0cyApO1xyXG5cclxuXHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3Quc29ydCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHRleHR1cmVzLnVwZGF0ZVZpZGVvVGV4dHVyZXMoKTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuYmVnaW5TaGFkb3dzKCk7XHJcblxyXG5cdFx0XHRzaGFkb3dNYXAucmVuZGVyKCBzaGFkb3dzQXJyYXksIHNjZW5lLCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdGxpZ2h0cy5zZXR1cCggbGlnaHRzQXJyYXksIHNoYWRvd3NBcnJheSwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuZW5kU2hhZG93cygpO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdF9pbmZvUmVuZGVyLmZyYW1lICsrO1xyXG5cdFx0XHRfaW5mb1JlbmRlci5jYWxscyA9IDA7XHJcblx0XHRcdF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdFx0X2luZm9SZW5kZXIuZmFjZXMgPSAwO1xyXG5cdFx0XHRfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdC8vXHJcblxyXG5cdFx0XHRiYWNrZ3JvdW5kLnJlbmRlciggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIGZvcmNlQ2xlYXIgKTtcclxuXHJcblx0XHRcdC8vIHJlbmRlciBzY2VuZVxyXG5cclxuXHRcdFx0dmFyIG9wYXF1ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC5vcGFxdWU7XHJcblx0XHRcdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc3BhcmVudDtcclxuXHJcblx0XHRcdGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9wYXF1ZU9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApO1xyXG5cdFx0XHRcdGlmICggdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCApIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXHJcblxyXG5cdFx0XHRcdGlmICggb3BhcXVlT2JqZWN0cy5sZW5ndGggKSByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXHJcblxyXG5cdFx0XHRcdGlmICggdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCApIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY3VzdG9tIHJlbmRlcmVyc1xyXG5cclxuXHRcdFx0c3ByaXRlUmVuZGVyZXIucmVuZGVyKCBzcHJpdGVzQXJyYXksIHNjZW5lLCBjYW1lcmEgKTtcclxuXHRcdFx0ZmxhcmVSZW5kZXJlci5yZW5kZXIoIGZsYXJlc0FycmF5LCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFZpZXdwb3J0ICk7XHJcblxyXG5cdFx0XHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxyXG5cclxuXHRcdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XHJcblx0XHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggdHJ1ZSApO1xyXG5cdFx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2soIHRydWUgKTtcclxuXHJcblx0XHRcdHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIGZhbHNlICk7XHJcblxyXG5cdFx0XHRpZiAoIHZyLmVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZyLnN1Ym1pdEZyYW1lKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBfZ2wuZmluaXNoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHQvKlxyXG5cdFx0Ly8gVE9ETyBEdXBsaWNhdGVkIGNvZGUgKEZydXN0dW0pXHJcblxyXG5cdFx0dmFyIF9zcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gaXNPYmplY3RWaWV3YWJsZSggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXHJcblx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRfc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICkuXHJcblx0XHRcdGFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpc1Nwcml0ZVZpZXdhYmxlKCBzcHJpdGUgKSB7XHJcblxyXG5cdFx0XHRfc3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcclxuXHRcdFx0X3NwaGVyZS5yYWRpdXMgPSAwLjcwNzEwNjc4MTE4NjU0NzY7XHJcblx0XHRcdF9zcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHJldHVybiBpc1NwaGVyZVZpZXdhYmxlKCBfc3BoZXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGlzU3BoZXJlVmlld2FibGUoIHNwaGVyZSApIHtcclxuXHJcblx0XHRcdGlmICggISBfZnJ1c3R1bS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdHZhciBudW1QbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xyXG5cclxuXHRcdFx0aWYgKCBudW1QbGFuZXMgPT09IDAgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHRcdHZhciBwbGFuZXMgPSBfdGhpcy5jbGlwcGluZ1BsYW5lcyxcclxuXHJcblx0XHRcdFx0Y2VudGVyID0gc3BoZXJlLmNlbnRlcixcclxuXHRcdFx0XHRuZWdSYWQgPSAtIHNwaGVyZS5yYWRpdXMsXHJcblx0XHRcdFx0aSA9IDA7XHJcblxyXG5cdFx0XHRkbyB7XHJcblxyXG5cdFx0XHRcdC8vIG91dCB3aGVuIGRlZXBlciB0aGFuIHJhZGl1cyBpbiB0aGUgbmVnYXRpdmUgaGFsZnNwYWNlXHJcblx0XHRcdFx0aWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApIDwgbmVnUmFkICkgcmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fSB3aGlsZSAoICsrIGkgIT09IG51bVBsYW5lcyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cdFx0Ki9cclxuXHJcblx0XHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc29ydE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdHZhciB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XHJcblxyXG5cdFx0XHRpZiAoIHZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmlzTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlnaHRzQXJyYXkucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNoYWRvd3NBcnJheS5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1Nwcml0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c1Nwcml0ZSggb2JqZWN0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzcHJpdGVzQXJyYXkucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMZW5zRmxhcmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmVzQXJyYXkucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHNvcnRPYmplY3RzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKVxyXG5cdFx0XHRcdFx0XHRcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgbnVsbCwgb2JqZWN0Lm1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHtcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBzb3J0T2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKVxyXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcclxuXHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIHNvcnRPYmplY3RzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcclxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHRcdFx0XHR2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xyXG5cclxuXHRcdFx0XHRpZiAoIGNhbWVyYS5pc0FycmF5Q2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRcdF9jdXJyZW50QXJyYXlDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNhbWVyYXMgPSBjYW1lcmEuY2FtZXJhcztcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gY2FtZXJhcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBjYW1lcmEyID0gY2FtZXJhc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYTIubGF5ZXJzICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBib3VuZHMgPSBjYW1lcmEyLmJvdW5kcztcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHggPSBib3VuZHMueCAqIF93aWR0aDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgeSA9IGJvdW5kcy55ICogX2hlaWdodDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBib3VuZHMueiAqIF93aWR0aDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaGVpZ2h0ID0gYm91bmRzLncgKiBfaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYTIsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApIHtcclxuXHJcblx0XHRcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZyb250RmFjZUNXID0gKCBvYmplY3QuaXNNZXNoICYmIG9iamVjdC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5zZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICk7XHJcblxyXG5cdFx0XHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBzY2VuZS5mb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcclxuXHJcblx0XHRcdFx0cmVuZGVyT2JqZWN0SW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgc2NlbmUuZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5vbkFmdGVyUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gcHJvZ3JhbUNhY2hlLmdldFBhcmFtZXRlcnMoXHJcblx0XHRcdFx0bWF0ZXJpYWwsIGxpZ2h0cy5zdGF0ZSwgc2hhZG93c0FycmF5LCBmb2csIF9jbGlwcGluZy5udW1QbGFuZXMsIF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb24sIG9iamVjdCApO1xyXG5cclxuXHRcdFx0dmFyIGNvZGUgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNvZGUoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xyXG5cdFx0XHR2YXIgcHJvZ3JhbUNoYW5nZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gbmV3IG1hdGVyaWFsXHJcblx0XHRcdFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xyXG5cclxuXHRcdFx0XHQvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xyXG5cdFx0XHRcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gb25seSByZWJ1aWxkIHVuaWZvcm0gbGlzdFxyXG5cdFx0XHRcdHByb2dyYW1DaGFuZ2UgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzaGFkZXIgPSBTaGFkZXJMaWJbIHBhcmFtZXRlcnMuc2hhZGVySUQgXTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyID0ge1xyXG5cdFx0XHRcdFx0XHRuYW1lOiBtYXRlcmlhbC50eXBlLFxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXHJcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcclxuXHRcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyID0ge1xyXG5cdFx0XHRcdFx0XHRuYW1lOiBtYXRlcmlhbC50eXBlLFxyXG5cdFx0XHRcdFx0XHR1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXHJcblx0XHRcdFx0XHRcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxyXG5cdFx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwub25CZWZvcmVDb21waWxlKCBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyICk7XHJcblxyXG5cdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyLCBwYXJhbWV0ZXJzLCBjb2RlICk7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHRcdFx0XHRtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKys7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhOb3JtYWxzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIudW5pZm9ybXM7XHJcblxyXG5cdFx0XHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJlxyXG5cdFx0XHRcdCEgbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdG1hdGVyaWFsLmNsaXBwaW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xyXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gPSBfY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmNsaXBwaW5nUGxhbmVzID0gX2NsaXBwaW5nLnVuaWZvcm07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuZm9nID0gZm9nO1xyXG5cclxuXHRcdFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxyXG5cclxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggPSBsaWdodHMuc3RhdGUuaGFzaDtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubGlnaHRzICkge1xyXG5cclxuXHRcdFx0XHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3RhdGUuYW1iaWVudDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XHJcblx0XHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWE7XHJcblx0XHRcdFx0dW5pZm9ybXMucG9pbnRMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnQ7XHJcblx0XHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5oZW1pO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90U2hhZG93TWF0cml4O1xyXG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4O1xyXG5cdFx0XHRcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBhZGQgYXJlYSBsaWdodHMgc2hhZG93IGluZm8gdG8gdW5pZm9ybXNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwcm9nVW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxyXG5cdFx0XHRcdHVuaWZvcm1zTGlzdCA9XHJcblx0XHRcdFx0XHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSggcHJvZ1VuaWZvcm1zLnNlcSwgdW5pZm9ybXMgKTtcclxuXHJcblx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSB1bmlmb3Jtc0xpc3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwO1xyXG5cclxuXHRcdFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIF9sb2NhbENsaXBwaW5nRW5hYmxlZCB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB1c2VDYWNoZSA9XHJcblx0XHRcdFx0XHRcdGNhbWVyYSA9PT0gX2N1cnJlbnRDYW1lcmEgJiZcclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuaWQgPT09IF9jdXJyZW50TWF0ZXJpYWxJZDtcclxuXHJcblx0XHRcdFx0XHQvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxyXG5cdFx0XHRcdFx0Ly8gb2JqZWN0IGluc3RlYWQgb2YgdGhlIG1hdGVyaWFsLCBvbmNlIGl0IGJlY29tZXMgZmVhc2libGVcclxuXHRcdFx0XHRcdC8vICgjODQ2NSwgIzgzNzkpXHJcblx0XHRcdFx0XHRfY2xpcHBpbmcuc2V0U3RhdGUoXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLCBtYXRlcmlhbC5jbGlwSW50ZXJzZWN0aW9uLCBtYXRlcmlhbC5jbGlwU2hhZG93cyxcclxuXHRcdFx0XHRcdFx0Y2FtZXJhLCBtYXRlcmlhbFByb3BlcnRpZXMsIHVzZUNhY2hlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5mb2cgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyAhPT0gZm9nICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubGlnaHRzICYmIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoICE9PSBsaWdodHMuc3RhdGUuaGFzaCApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gdW5kZWZpbmVkICYmXHJcblx0XHRcdFx0XHQoIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gX2NsaXBwaW5nLm51bVBsYW5lcyB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiAhPT0gX2NsaXBwaW5nLm51bUludGVyc2VjdGlvbiApICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0aW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKTtcclxuXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJlZnJlc2hQcm9ncmFtID0gZmFsc2U7XHJcblx0XHRcdHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcclxuXHRcdFx0dmFyIHJlZnJlc2hMaWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0sXHJcblx0XHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcclxuXHRcdFx0XHRtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlci51bmlmb3JtcztcclxuXHJcblx0XHRcdGlmICggc3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICkgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcclxuXHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xyXG5cclxuXHRcdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcclxuXHJcblx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAncHJvamVjdGlvbk1hdHJpeCcsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbG9nRGVwdGhCdWZGQycsXHJcblx0XHRcdFx0XHRcdDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBBdm9pZCB1bm5lZWRlZCB1bmlmb3JtIHVwZGF0ZXMgcGVyIEFycmF5Q2FtZXJhJ3Mgc3ViLWNhbWVyYVxyXG5cclxuXHRcdFx0XHRpZiAoIF9jdXJyZW50Q2FtZXJhICE9PSAoIF9jdXJyZW50QXJyYXlDYW1lcmEgfHwgY2FtZXJhICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2N1cnJlbnRDYW1lcmEgPSAoIF9jdXJyZW50QXJyYXlDYW1lcmEgfHwgY2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbGlnaHRpbmcgdW5pZm9ybXMgZGVwZW5kIG9uIHRoZSBjYW1lcmEgc28gZW5mb3JjZSBhbiB1cGRhdGVcclxuXHRcdFx0XHRcdC8vIG5vdywgaW4gY2FzZSB0aGlzIG1hdGVyaWFsIHN1cHBvcnRzIGxpZ2h0cyAtIG9yIGxhdGVyLCB3aGVuXHJcblx0XHRcdFx0XHQvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcdFx0Ly8gc2V0IHRvIHRydWUgb24gbWF0ZXJpYWwgY2hhbmdlXHJcblx0XHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcdFx0Ly8gcmVtYWlucyBzZXQgdW50aWwgdXBkYXRlIGRvbmVcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXHJcblx0XHRcdFx0Ly8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5lbnZNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHVDYW1Qb3MgPSBwX3VuaWZvcm1zLm1hcC5jYW1lcmFQb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVDYW1Qb3MgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHVDYW1Qb3Muc2V0VmFsdWUoIF9nbCxcclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0XHRtYXRlcmlhbC5za2lubmluZyApIHtcclxuXHJcblx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICd2aWV3TWF0cml4JywgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2VcclxuXHRcdFx0Ly8gYXV0by1zZXR0aW5nIG9mIHRleHR1cmUgdW5pdCBmb3IgYm9uZSB0ZXh0dXJlIG11c3QgZ28gYmVmb3JlIG90aGVyIHRleHR1cmVzXHJcblx0XHRcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xyXG5cclxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXgnICk7XHJcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcclxuXHJcblx0XHRcdFx0dmFyIHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNrZWxldG9uICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHNrZWxldG9uLmJvbmVUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcclxuXHRcdFx0XHRcdFx0XHQvLyAgICAgIFJHQkEgUkdCQSBSR0JBIFJHQkEgKD0+IGNvbHVtbjEsIGNvbHVtbjIsIGNvbHVtbjMsIGNvbHVtbjQpXHJcblx0XHRcdFx0XHRcdFx0Ly8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBib25lcyAqIDQgcGl4ZWxzID0gICg4ICogOClcclxuXHRcdFx0XHRcdFx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcclxuXHRcdFx0XHRcdFx0XHQvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICogNCBwaXhlbHMgPSAoMzIgKiAzMilcclxuXHRcdFx0XHRcdFx0XHQvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcclxuXHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBzaXplID0gTWF0aC5zcXJ0KCBib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcclxuXHRcdFx0XHRcdFx0XHRzaXplID0gX01hdGguY2VpbFBvd2VyT2ZUd28oIHNpemUgKTtcclxuXHRcdFx0XHRcdFx0XHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHNpemUgKiBzaXplICogNCApOyAvLyA0IGZsb2F0cyBwZXIgUkdCQSBwaXhlbFxyXG5cdFx0XHRcdFx0XHRcdGJvbmVNYXRyaWNlcy5zZXQoIHNrZWxldG9uLmJvbmVNYXRyaWNlcyApOyAvLyBjb3B5IGN1cnJlbnQgdmFsdWVzXHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0c2tlbGV0b24uYm9uZU1hdHJpY2VzID0gYm9uZU1hdHJpY2VzO1xyXG5cdFx0XHRcdFx0XHRcdHNrZWxldG9uLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XHJcblx0XHRcdFx0XHRcdFx0c2tlbGV0b24uYm9uZVRleHR1cmVTaXplID0gc2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2JvbmVUZXh0dXJlJywgc2tlbGV0b24uYm9uZVRleHR1cmUgKTtcclxuXHRcdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYm9uZVRleHR1cmVTaXplJywgc2tlbGV0b24uYm9uZVRleHR1cmVTaXplICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgc2tlbGV0b24sICdib25lTWF0cmljZXMnICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndG9uZU1hcHBpbmdFeHBvc3VyZScsIF90aGlzLnRvbmVNYXBwaW5nRXhwb3N1cmUgKTtcclxuXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICd0b25lTWFwcGluZ1doaXRlUG9pbnQnLCBfdGhpcy50b25lTWFwcGluZ1doaXRlUG9pbnQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5saWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xyXG5cclxuXHRcdFx0XHRcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcclxuXHRcdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcclxuXHRcdFx0XHRcdC8vIHZhbHVlc1xyXG5cdFx0XHRcdFx0Ly9cclxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcclxuXHRcdFx0XHRcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXHJcblxyXG5cdFx0XHRcdFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHJlZnJlc2hMaWdodHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xyXG5cclxuXHRcdFx0XHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNUb29uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGVwdGgoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc05vcm1hbCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNMaW5lQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNQb2ludHNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQb2ludHMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0bV91bmlmb3Jtcy5jb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cdFx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBSZWN0QXJlYUxpZ2h0IFRleHR1cmVcclxuXHRcdFx0XHQvLyBUT0RPIChtcmRvb2IpOiBGaW5kIGEgbmljZXIgaW1wbGVtZW50YXRpb25cclxuXHJcblx0XHRcdFx0aWYgKCBtX3VuaWZvcm1zLmx0Y01hdCAhPT0gdW5kZWZpbmVkICkgbV91bmlmb3Jtcy5sdGNNYXQudmFsdWUgPSBVbmlmb3Jtc0xpYi5MVENfTUFUX1RFWFRVUkU7XHJcblx0XHRcdFx0aWYgKCBtX3VuaWZvcm1zLmx0Y01hZyAhPT0gdW5kZWZpbmVkICkgbV91bmlmb3Jtcy5sdGNNYWcudmFsdWUgPSBVbmlmb3Jtc0xpYi5MVENfTUFHX1RFWFRVUkU7XHJcblxyXG5cdFx0XHRcdFdlYkdMVW5pZm9ybXMudXBsb2FkKFxyXG5cdFx0XHRcdFx0X2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCBfdGhpcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIGNvbW1vbiBtYXRyaWNlc1xyXG5cclxuXHRcdFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xyXG5cdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdub3JtYWxNYXRyaXgnLCBvYmplY3Qubm9ybWFsTWF0cml4ICk7XHJcblx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVW5pZm9ybXMgKHJlZnJlc2ggdW5pZm9ybXMgb2JqZWN0cylcclxuXHJcblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5jb2xvciApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKS5tdWx0aXBseVNjYWxhciggbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XHJcblxyXG5cdFx0XHRcdC8vIGRvbid0IGZsaXAgQ3ViZVRleHR1cmUgZW52TWFwcywgZmxpcCBldmVyeXRoaW5nIGVsc2U6XHJcblx0XHRcdFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSB3aWxsIGJlIGZsaXBwZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0Ly8gIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS50ZXh0dXJlIHdpbGwgYmUgZmxpcHBlZCBiZWNhdXNlIGl0J3MgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxyXG5cdFx0XHRcdC8vIHRoaXMgY2hlY2sgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5LCBvciByZW1vdmVkIGVudGlyZWx5LCBpZiBXZWJHTFJlbmRlclRhcmdldEN1YmUgdXNlcyBhIEN1YmVUZXh0dXJlIGluIHRoZSBmdXR1cmVcclxuXHRcdFx0XHR1bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gKCAhICggbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5pc0N1YmVUZXh0dXJlICkgKSA/IDEgOiAtIDE7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcclxuXHRcdFx0Ly8gMS4gY29sb3IgbWFwXHJcblx0XHRcdC8vIDIuIHNwZWN1bGFyIG1hcFxyXG5cdFx0XHQvLyAzLiBub3JtYWwgbWFwXHJcblx0XHRcdC8vIDQuIGJ1bXAgbWFwXHJcblx0XHRcdC8vIDUuIGFscGhhIG1hcFxyXG5cdFx0XHQvLyA2LiBlbWlzc2l2ZSBtYXBcclxuXHJcblx0XHRcdHZhciB1dlNjYWxlTWFwO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XHJcblxyXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcclxuXHJcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcclxuXHJcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcclxuXHJcblx0XHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRcdGlmICggdXZTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xyXG5cdFx0XHRcdFx0dmFyIHJlcGVhdCA9IHV2U2NhbGVNYXAucmVwZWF0O1xyXG5cdFx0XHRcdFx0dmFyIHJvdGF0aW9uID0gdXZTY2FsZU1hcC5yb3RhdGlvbjtcclxuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSB1dlNjYWxlTWFwLmNlbnRlcjtcclxuXHJcblx0XHRcdFx0XHR1dlNjYWxlTWFwLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnksIHJvdGF0aW9uLCBjZW50ZXIueCwgY2VudGVyLnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCB1dlNjYWxlTWFwLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xyXG5cdFx0XHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XHJcblx0XHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xyXG5cdFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHRcdFx0dW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemUgKiBfcGl4ZWxSYXRpbztcclxuXHRcdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfaGVpZ2h0ICogMC41O1xyXG5cclxuXHRcdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIG9mZnNldCA9IG1hdGVyaWFsLm1hcC5vZmZzZXQ7XHJcblx0XHRcdFx0XHR2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcclxuXHRcdFx0XHRcdHZhciByb3RhdGlvbiA9IG1hdGVyaWFsLm1hcC5yb3RhdGlvbjtcclxuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBtYXRlcmlhbC5tYXAuY2VudGVyO1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLm1hcC5tYXRyaXguc2V0VXZUcmFuc2Zvcm0oIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55LCByb3RhdGlvbiwgY2VudGVyLngsIGNlbnRlci55ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSggbWF0ZXJpYWwubWFwLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2coIHVuaWZvcm1zLCBmb2cgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcclxuXHJcblx0XHRcdGlmICggZm9nLmlzRm9nICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XHJcblx0XHRcdFx0dW5pZm9ybXMuZm9nRmFyLnZhbHVlID0gZm9nLmZhcjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZvZy5pc0ZvZ0V4cDIgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XHJcblx0XHRcdHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IE1hdGgubWF4KCBtYXRlcmlhbC5zaGluaW5lc3MsIDFlLTQgKTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zVG9vbiggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5ncmFkaWVudE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZ3JhZGllbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5ncmFkaWVudE1hcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLnJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzcztcclxuXHRcdFx0dW5pZm9ybXMubWV0YWxuZXNzLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLnJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5tZXRhbG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmVudk1hcCApIHtcclxuXHJcblx0XHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXHJcblx0XHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuY2xlYXJDb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0O1xyXG5cdFx0XHR1bmlmb3Jtcy5jbGVhckNvYXRSb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3M7XHJcblxyXG5cdFx0XHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0RlcHRoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5yZWZlcmVuY2VQb3NpdGlvbi52YWx1ZS5jb3B5KCBtYXRlcmlhbC5yZWZlcmVuY2VQb3NpdGlvbiApO1xyXG5cdFx0XHR1bmlmb3Jtcy5uZWFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5uZWFyRGlzdGFuY2U7XHJcblx0XHRcdHVuaWZvcm1zLmZhckRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwuZmFyRGlzdGFuY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc05vcm1hbCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XHJcblx0XHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cclxuXHJcblx0XHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggdW5pZm9ybXMsIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XHJcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcclxuXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBHTCBzdGF0ZSBzZXR0aW5nXHJcblxyXG5cdFx0dGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcclxuXHJcblx0XHRcdHN0YXRlLnNldEN1bGxGYWNlKCBjdWxsRmFjZSApO1xyXG5cdFx0XHRzdGF0ZS5zZXRGbGlwU2lkZWQoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFRleHR1cmVzXHJcblxyXG5cdFx0ZnVuY3Rpb24gYWxsb2NUZXh0dXJlVW5pdCgpIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlVW5pdCA+PSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hbGxvY1RleHR1cmVVbml0ID0gYWxsb2NUZXh0dXJlVW5pdDtcclxuXHJcblx0XHQvLyB0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcclxuXHRcdHRoaXMuc2V0VGV4dHVyZTJEID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgd2FybmVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogcGVlbCB0ZXh0dXJlLnRleHR1cmVcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgd2FybmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZTJEOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlwiICk7XHJcblx0XHRcdFx0XHRcdHdhcm5lZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSApO1xyXG5cclxuXHRcdHRoaXMuc2V0VGV4dHVyZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISB3YXJuZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRUZXh0dXJlMkQgaW5zdGVhZC5cIiApO1xyXG5cdFx0XHRcdFx0d2FybmVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpICk7XHJcblxyXG5cdFx0dGhpcy5zZXRUZXh0dXJlQ3ViZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogcGVlbCB0ZXh0dXJlLnRleHR1cmVcclxuXHRcdFx0XHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgd2FybmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZUN1YmU6IGRvbid0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiApO1xyXG5cdFx0XHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGN1cnJlbnRseSByZWx5aW5nIG9uIHRoZSBmYWN0IHRoYXQgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnRleHR1cmUgaXMgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxyXG5cdFx0XHRcdC8vIFRPRE86IHVuaWZ5IHRoZXNlIGNvZGUgcGF0aHNcclxuXHRcdFx0XHRpZiAoICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB8fFxyXG5cdFx0XHRcdFx0KCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xyXG5cclxuXHRcdFx0XHRcdC8vIHRoaXMgZnVuY3Rpb24gYWxvbmUgc2hvdWxkIHRha2UgY2FyZSBvZiBjdWJlIHRleHR1cmVzXHJcblx0XHRcdFx0XHR0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIGFzc3VtZWQ6IHRleHR1cmUgcHJvcGVydHkgb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlXHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpICk7XHJcblxyXG5cdFx0dGhpcy5nZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmVzLnNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBmcmFtZWJ1ZmZlciA9IG51bGw7XHJcblx0XHRcdHZhciBpc0N1YmUgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgX193ZWJnbEZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xyXG5cdFx0XHRcdFx0aXNDdWJlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIHJlbmRlclRhcmdldC52aWV3cG9ydCApO1xyXG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xyXG5cdFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xyXG5cdFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xyXG5cdFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBfc2Npc3NvclRlc3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIF9jdXJyZW50RnJhbWVidWZmZXIgIT09IGZyYW1lYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRcdFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcclxuXHRcdFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yICk7XHJcblx0XHRcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfY3VycmVudFNjaXNzb3JUZXN0ICk7XHJcblxyXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcblx0XHRcdFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUsIHJlbmRlclRhcmdldC5hY3RpdmVNaXBNYXBMZXZlbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciApIHtcclxuXHJcblx0XHRcdGlmICggISAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCApICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlc3RvcmUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0cmVzdG9yZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xyXG5cdFx0XHRcdFx0dmFyIHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcclxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleHR1cmVGb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIGZvcm1hdC4nICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFICkgJiYgLy8gSUUxMSwgRWRnZSBhbmQgQ2hyb21lIE1hYyA8IDUyICgjOTUxMylcclxuXHRcdFx0XHRcdFx0ISAoIHRleHR1cmVUeXBlID09PSBGbG9hdFR5cGUgJiYgKCBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApIHx8IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyApICkgKSAmJiAvLyBDaHJvbWUgTWFjID49IDUyIGFuZCBGaXJlZm94XHJcblx0XHRcdFx0XHRcdCEgKCB0ZXh0dXJlVHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcgKSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50IGVuc3VyZXMgdmFsaWQgcmVhZCByZXF1ZXN0cyAobm8gb3V0LW9mLWJvdW5kcyBwaXhlbHMsIHNlZSAjODYwNClcclxuXHJcblx0XHRcdFx0XHRcdGlmICggKCB4ID49IDAgJiYgeCA8PSAoIHJlbmRlclRhcmdldC53aWR0aCAtIHdpZHRoICkgKSAmJiAoIHkgPj0gMCAmJiB5IDw9ICggcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCApICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlRm9ybWF0ICksIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVUeXBlICksIGJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZmluYWxseSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEZvZ0V4cDIoIGNvbG9yLCBkZW5zaXR5ICkge1xyXG5cclxuXHRcdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XHJcblx0XHR0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XHJcblxyXG5cdH1cclxuXHJcblx0Rm9nRXhwMi5wcm90b3R5cGUuaXNGb2dFeHAyID0gdHJ1ZTtcclxuXHJcblx0Rm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Rm9nRXhwMi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCAvKiBtZXRhICovICkge1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGb2dFeHAyJyxcclxuXHRcdFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXHJcblx0XHRcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxyXG5cdFx0fTtcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBGb2coIGNvbG9yLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XHJcblx0XHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XHJcblxyXG5cdH1cclxuXHJcblx0Rm9nLnByb3RvdHlwZS5pc0ZvZyA9IHRydWU7XHJcblxyXG5cdEZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBGb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Rm9nLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIC8qIG1ldGEgKi8gKSB7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dHlwZTogJ0ZvZycsXHJcblx0XHRcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxyXG5cdFx0XHRuZWFyOiB0aGlzLm5lYXIsXHJcblx0XHRcdGZhcjogdGhpcy5mYXJcclxuXHRcdH07XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFNjZW5lKCkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xyXG5cclxuXHRcdHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XHJcblx0XHR0aGlzLmZvZyA9IG51bGw7XHJcblx0XHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXHJcblxyXG5cdH1cclxuXHJcblx0U2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogU2NlbmUsXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XHJcblxyXG5cdFx0XHRpZiAoIHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsICkgdGhpcy5iYWNrZ3JvdW5kID0gc291cmNlLmJhY2tncm91bmQuY2xvbmUoKTtcclxuXHRcdFx0aWYgKCBzb3VyY2UuZm9nICE9PSBudWxsICkgdGhpcy5mb2cgPSBzb3VyY2UuZm9nLmNsb25lKCk7XHJcblx0XHRcdGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XHJcblx0XHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcclxuXHJcblx0XHRcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCBtZXRhICk7XHJcblx0XHRcdGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIExlbnNGbGFyZSggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy5sZW5zRmxhcmVzID0gW107XHJcblxyXG5cdFx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0TGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IExlbnNGbGFyZSxcclxuXHJcblx0XHRpc0xlbnNGbGFyZTogdHJ1ZSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KCBzb3VyY2UucG9zaXRpb25TY3JlZW4gKTtcclxuXHRcdFx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHNvdXJjZS5jdXN0b21VcGRhdGVDYWxsYmFjaztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubGVuc0ZsYXJlcy5wdXNoKCBzb3VyY2UubGVuc0ZsYXJlc1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFkZDogZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xyXG5cclxuXHRcdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLSAxO1xyXG5cdFx0XHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblx0XHRcdGlmICggb3BhY2l0eSA9PT0gdW5kZWZpbmVkICkgb3BhY2l0eSA9IDE7XHJcblx0XHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xyXG5cdFx0XHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRcdFx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XHJcblxyXG5cdFx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xyXG5cdFx0XHRcdHRleHR1cmU6IHRleHR1cmUsXHQvLyBUSFJFRS5UZXh0dXJlXHJcblx0XHRcdFx0c2l6ZTogc2l6ZSwgXHRcdC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxyXG5cdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSwgXHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXHJcblx0XHRcdFx0eDogMCwgeTogMCwgejogMCxcdC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgaW4gZnJvbnQgeiA9IDEgaXMgYmFja1xyXG5cdFx0XHRcdHNjYWxlOiAxLCBcdFx0Ly8gc2NhbGVcclxuXHRcdFx0XHRyb3RhdGlvbjogMCwgXHRcdC8vIHJvdGF0aW9uXHJcblx0XHRcdFx0b3BhY2l0eTogb3BhY2l0eSxcdC8vIG9wYWNpdHlcclxuXHRcdFx0XHRjb2xvcjogY29sb3IsXHRcdC8vIGNvbG9yXHJcblx0XHRcdFx0YmxlbmRpbmc6IGJsZW5kaW5nXHQvLyBibGVuZGluZ1xyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXHJcblx0XHQgKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dXBkYXRlTGVuc0ZsYXJlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcclxuXHRcdFx0dmFyIGZsYXJlO1xyXG5cdFx0XHR2YXIgdmVjWCA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICogMjtcclxuXHRcdFx0dmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRmbGFyZS54ID0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICsgdmVjWCAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cdFx0XHRcdGZsYXJlLnkgPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKyB2ZWNZICogZmxhcmUuZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xyXG5cdFx0XHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKlxyXG5cdCAqIHBhcmFtZXRlcnMgPSB7XHJcblx0ICogIGNvbG9yOiA8aGV4PixcclxuXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcclxuXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG5cdCAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBTcHJpdGVNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xyXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMucm90YXRpb24gPSAwO1xyXG5cclxuXHRcdHRoaXMuZm9nID0gZmFsc2U7XHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlTWF0ZXJpYWw7XHJcblx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmlzU3ByaXRlTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBTcHJpdGUoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU3ByaXRlJztcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsID0gKCBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbCA6IG5ldyBTcHJpdGVNYXRlcmlhbCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdFNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBTcHJpdGUsXHJcblxyXG5cdFx0aXNTcHJpdGU6IHRydWUsXHJcblxyXG5cdFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciB3b3JsZFNjYWxlID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG5cdFx0XHRcdHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0cmF5Y2FzdGVyLnJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCB3b3JsZFBvc2l0aW9uLCBpbnRlcnNlY3RQb2ludCApO1xyXG5cclxuXHRcdFx0XHR3b3JsZFNjYWxlLnNldEZyb21NYXRyaXhTY2FsZSggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHZhciBndWVzc1NpemVTcSA9IHdvcmxkU2NhbGUueCAqIHdvcmxkU2NhbGUueSAvIDQ7XHJcblxyXG5cdFx0XHRcdGlmICggd29ybGRQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggaW50ZXJzZWN0UG9pbnQgKSA+IGd1ZXNzU2l6ZVNxICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCkgKSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTE9EKCkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTE9EJztcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xyXG5cdFx0XHRsZXZlbHM6IHtcclxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRcdHZhbHVlOiBbXVxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0TE9ELnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IExPRCxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xyXG5cclxuXHRcdFx0XHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWRkTGV2ZWw6IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcclxuXHJcblx0XHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XHJcblxyXG5cdFx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XHJcblxyXG5cdFx0XHR0aGlzLmFkZCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRPYmplY3RGb3JEaXN0YW5jZTogZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBsZXZlbHNbIGkgLSAxIF0ub2JqZWN0O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRcdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIG1hdHJpeFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSApLFxyXG5cclxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuXHRcdFx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xyXG5cclxuXHRcdFx0XHRcdGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0XHRcdGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xyXG5cclxuXHRcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xyXG5cdFx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBtaWNoYWVsIGd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cclxuXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKSB7XHJcblxyXG5cdFx0Ly8gY29weSB0aGUgYm9uZSBhcnJheVxyXG5cclxuXHRcdGJvbmVzID0gYm9uZXMgfHwgW107XHJcblxyXG5cdFx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XHJcblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZXMubGVuZ3RoICogMTYgKTtcclxuXHJcblx0XHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xyXG5cclxuXHRcdGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25lSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBNYXRyaXg0KCkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBTa2VsZXRvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjYWxjdWxhdGVJbnZlcnNlczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5ib25lc1sgaSBdICkge1xyXG5cclxuXHRcdFx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgaSBdLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGJvbmUsIGksIGlsO1xyXG5cclxuXHRcdFx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRib25lID0gdGhpcy5ib25lc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJvbmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ym9uZS5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCB0aGlzLmJvbmVJbnZlcnNlc1sgaSBdICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRib25lID0gdGhpcy5ib25lc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJvbmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdFx0dmFyIGlkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcblx0XHRcdFx0dmFyIGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xyXG5cdFx0XHRcdHZhciBib25lTWF0cmljZXMgPSB0aGlzLmJvbmVNYXRyaWNlcztcclxuXHRcdFx0XHR2YXIgYm9uZVRleHR1cmUgPSB0aGlzLmJvbmVUZXh0dXJlO1xyXG5cclxuXHRcdFx0XHQvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXHJcblxyXG5cdFx0XHRcdFx0dmFyIG1hdHJpeCA9IGJvbmVzWyBpIF0gPyBib25lc1sgaSBdLm1hdHJpeFdvcmxkIDogaWRlbnRpdHlNYXRyaXg7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgYm9uZUludmVyc2VzWyBpIF0gKTtcclxuXHRcdFx0XHRcdG9mZnNldE1hdHJpeC50b0FycmF5KCBib25lTWF0cmljZXMsIGkgKiAxNiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYm9uZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSApKCksXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQm9uZSgpIHtcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0JvbmUnO1xyXG5cclxuXHR9XHJcblxyXG5cdEJvbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogQm9uZSxcclxuXHJcblx0XHRpc0JvbmU6IHRydWVcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xyXG5cclxuXHRcdHRoaXMuYmluZE1vZGUgPSAnYXR0YWNoZWQnO1xyXG5cdFx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdHZhciBib25lcyA9IHRoaXMuaW5pdEJvbmVzKCk7XHJcblx0XHR2YXIgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oIGJvbmVzICk7XHJcblxyXG5cdFx0dGhpcy5iaW5kKCBza2VsZXRvbiwgdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRTa2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFNraW5uZWRNZXNoLFxyXG5cclxuXHRcdGlzU2tpbm5lZE1lc2g6IHRydWUsXHJcblxyXG5cdFx0aW5pdEJvbmVzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgYm9uZXMgPSBbXSwgYm9uZSwgZ2JvbmU7XHJcblx0XHRcdHZhciBpLCBpbDtcclxuXHJcblx0XHRcdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmJvbmVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGZpcnN0LCBjcmVhdGUgYXJyYXkgb2YgJ0JvbmUnIG9iamVjdHMgZnJvbSBnZW9tZXRyeSBkYXRhXHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIG5ldyAnQm9uZScgb2JqZWN0XHJcblxyXG5cdFx0XHRcdFx0Ym9uZSA9IG5ldyBCb25lKCk7XHJcblx0XHRcdFx0XHRib25lcy5wdXNoKCBib25lICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gYXBwbHkgdmFsdWVzXHJcblxyXG5cdFx0XHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcclxuXHRcdFx0XHRcdGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcclxuXHRcdFx0XHRcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcclxuXHRcdFx0XHRcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc2Vjb25kLCBjcmVhdGUgYm9uZSBoaWVyYXJjaHlcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggZ2JvbmUucGFyZW50ICE9PSAtIDEgKSAmJiAoIGdib25lLnBhcmVudCAhPT0gbnVsbCApICYmICggYm9uZXNbIGdib25lLnBhcmVudCBdICE9PSB1bmRlZmluZWQgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgYm9uZXMgaW4gdGhlIGhpZXJhcmNoeVxyXG5cclxuXHRcdFx0XHRcdFx0Ym9uZXNbIGdib25lLnBhcmVudCBdLmFkZCggYm9uZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB0b3Btb3N0IGJvbmUsIGltbWVkaWF0ZSBjaGlsZCBvZiB0aGUgc2tpbm5lZCBtZXNoXHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLmFkZCggYm9uZXNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbm93IHRoZSBib25lcyBhcmUgcGFydCBvZiB0aGUgc2NlbmUgZ3JhcGggYW5kIGNoaWxkcmVuIG9mIHRoZSBza2lubmVkIG1lc2guXHJcblx0XHRcdC8vIGxldCdzIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBtYXRyaWNlc1xyXG5cclxuXHRcdFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGJvbmVzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YmluZDogZnVuY3Rpb24gKCBza2VsZXRvbiwgYmluZE1hdHJpeCApIHtcclxuXHJcblx0XHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcclxuXHJcblx0XHRcdGlmICggYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcclxuXHJcblx0XHRcdFx0YmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xyXG5cdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHBvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuc2tlbGV0b24ucG9zZSgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bm9ybWFsaXplU2tpbldlaWdodHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBzY2FsZSwgaTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHN3ID0gdGhpcy5nZW9tZXRyeS5za2luV2VpZ2h0c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlID0gMS4wIC8gc3cubWFuaGF0dGFuTGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0c3cuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlYyA9IG5ldyBWZWN0b3I0KCk7XHJcblxyXG5cdFx0XHRcdHZhciBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgc2tpbldlaWdodC5jb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWMueCA9IHNraW5XZWlnaHQuZ2V0WCggaSApO1xyXG5cdFx0XHRcdFx0dmVjLnkgPSBza2luV2VpZ2h0LmdldFkoIGkgKTtcclxuXHRcdFx0XHRcdHZlYy56ID0gc2tpbldlaWdodC5nZXRaKCBpICk7XHJcblx0XHRcdFx0XHR2ZWMudyA9IHNraW5XZWlnaHQuZ2V0VyggaSApO1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlID0gMS4wIC8gdmVjLm1hbmhhdHRhbkxlbmd0aCgpO1xyXG5cclxuXHRcdFx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmVjLm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2ZWMuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjLngsIHZlYy55LCB2ZWMueiwgdmVjLncgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdFx0XHRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSAnYXR0YWNoZWQnICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuYmluZE1vZGUgPT09ICdkZXRhY2hlZCcgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaDogVW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKiAgY29sb3I6IDxoZXg+LFxyXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIGxpbmV3aWR0aDogPGZsb2F0PixcclxuXHQgKiAgbGluZWNhcDogXCJyb3VuZFwiLFxyXG5cdCAqICBsaW5lam9pbjogXCJyb3VuZFwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBMaW5lQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVCYXNpY01hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHRcdHRoaXMubGluZXdpZHRoID0gMTtcclxuXHRcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XHJcblx0XHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0XHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUJhc2ljTWF0ZXJpYWw7XHJcblxyXG5cdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5pc0xpbmVCYXNpY01hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cclxuXHRcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcclxuXHRcdHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xyXG5cdFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsLCBtb2RlICkge1xyXG5cclxuXHRcdGlmICggbW9kZSA9PT0gMSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmU6IHBhcmFtZXRlciBUSFJFRS5MaW5lUGllY2VzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIENyZWF0ZWQgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTGluZSc7XHJcblxyXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRMaW5lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IExpbmUsXHJcblxyXG5cdFx0aXNMaW5lOiB0cnVlLFxyXG5cclxuXHRcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0XHR2YXIgcmF5ID0gbmV3IFJheSgpO1xyXG5cdFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xyXG5cdFx0XHRcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHRcdFx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdFx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcclxuXHRcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dmFyIHZTdGFydCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdFx0dmFyIHZFbmQgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRcdHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRcdHZhciBpbnRlclJheSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdFx0dmFyIHN0ZXAgPSAoIHRoaXMgJiYgdGhpcy5pc0xpbmVTZWdtZW50cyApID8gMiA6IDE7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHRcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgYSA9IGluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgYiA9IGluZGljZXNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcclxuXHRcdFx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuXHRcdFx0XHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxyXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XHJcblx0XHRcdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdlN0YXJ0LCB2RW5kLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcblx0XHRcdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcclxuXHJcblx0XHRcdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcclxuXHRcdFx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCBpbnRlclJheSwgaW50ZXJTZWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cclxuXHRcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcclxuXHRcdFx0XHRcdFx0XHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXHJcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRmYWNlSW5kZXg6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXHJcblxyXG5cdFx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0oKSApLFxyXG5cclxuXHRcdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVTZWdtZW50cyc7XHJcblxyXG5cdH1cclxuXHJcblx0TGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpbmUucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogTGluZVNlZ21lbnRzLFxyXG5cclxuXHRcdGlzTGluZVNlZ21lbnRzOiB0cnVlXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtZ3JldGVyIC8gaHR0cDovL2dpdGh1Yi5jb20vbWdyZXRlclxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBMaW5lTG9vcCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xpbmVMb29wJztcclxuXHJcblx0fVxyXG5cclxuXHRMaW5lTG9vcC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaW5lLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IExpbmVMb29wLFxyXG5cclxuXHRcdGlzTGluZUxvb3A6IHRydWUsXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKiAgY29sb3I6IDxoZXg+LFxyXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgc2l6ZTogPGZsb2F0PixcclxuXHQgKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD5cclxuXHQgKiB9XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2l6ZSA9IDE7XHJcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50c01hdGVyaWFsO1xyXG5cclxuXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuaXNQb2ludHNNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XHJcblxyXG5cdFx0dGhpcy5zaXplID0gc291cmNlLnNpemU7XHJcblx0XHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRzJztcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxuXHR9XHJcblxyXG5cdFBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBQb2ludHMsXHJcblxyXG5cdFx0aXNQb2ludHM6IHRydWUsXHJcblxyXG5cdFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblx0XHRcdHZhciByYXkgPSBuZXcgUmF5KCk7XHJcblx0XHRcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gdGhpcztcclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XHJcblx0XHRcdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcclxuXHJcblx0XHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XHJcblx0XHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRzcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcclxuXHJcblx0XHRcdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICggKCB0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnogKSAvIDMgKTtcclxuXHRcdFx0XHR2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XHJcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcclxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxyXG5cdFx0XHRcdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXHJcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxyXG5cdFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0OiBvYmplY3RcclxuXHJcblx0XHRcdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9KCkgKSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBHcm91cCgpIHtcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0dyb3VwJztcclxuXHJcblx0fVxyXG5cclxuXHRHcm91cC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBHcm91cCxcclxuXHJcblx0XHRpc0dyb3VwOiB0cnVlXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gVmlkZW9UZXh0dXJlKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xyXG5cclxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gU2V0IG5lZWRzVXBkYXRlIHdoZW4gZmlyc3QgZnJhbWUgaXMgcmVhZHlcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xyXG5cclxuXHRcdFx0dmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWRlZGRhdGEnLCBvbkxvYWRlZCwgZmFsc2UgKTtcclxuXHRcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2aWRlby5hZGRFdmVudExpc3RlbmVyKCAnbG9hZGVkZGF0YScsIG9uTG9hZGVkLCBmYWxzZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdFZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFZpZGVvVGV4dHVyZSxcclxuXHJcblx0XHRpc1ZpZGVvVGV4dHVyZTogdHJ1ZSxcclxuXHJcblx0XHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2aWRlbyA9IHRoaXMuaW1hZ2U7XHJcblxyXG5cdFx0XHRpZiAoIHZpZGVvLnJlYWR5U3RhdGUgPj0gdmlkZW8uSEFWRV9DVVJSRU5UX0RBVEEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBDb21wcmVzc2VkVGV4dHVyZSggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcclxuXHJcblx0XHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcclxuXHJcblx0XHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XHJcblx0XHR0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xyXG5cclxuXHRcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXHJcblx0XHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxyXG5cclxuXHRcdHRoaXMuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXHJcblx0XHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXHJcblxyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbXByZXNzZWRUZXh0dXJlO1xyXG5cclxuXHRDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuaXNDb21wcmVzc2VkVGV4dHVyZSA9IHRydWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgTWF0dCBEZXNMYXVyaWVycyAvIEBtYXR0ZGVzbFxyXG5cdCAqIEBhdXRob3IgYXRpeCAvIGFydGh1cnNpbGJlci5kZVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBEZXB0aFRleHR1cmUoIHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCApIHtcclxuXHJcblx0XHRmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xyXG5cclxuXHRcdGlmICggZm9ybWF0ICE9PSBEZXB0aEZvcm1hdCAmJiBmb3JtYXQgIT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlcHRoVGV4dHVyZSBmb3JtYXQgbXVzdCBiZSBlaXRoZXIgVEhSRUUuRGVwdGhGb3JtYXQgb3IgVEhSRUUuRGVwdGhTdGVuY2lsRm9ybWF0JyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoRm9ybWF0ICkgdHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xyXG5cdFx0aWYgKCB0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB0eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xyXG5cclxuXHRcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XHJcblxyXG5cdFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cclxuXHRcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xyXG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XHJcblxyXG5cdFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHNcdD0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0RGVwdGhUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XHJcblx0RGVwdGhUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlcHRoVGV4dHVyZTtcclxuXHREZXB0aFRleHR1cmUucHJvdG90eXBlLmlzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBXaXJlZnJhbWVHZW9tZXRyeSggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdXaXJlZnJhbWVHZW9tZXRyeSc7XHJcblxyXG5cdFx0Ly8gYnVmZmVyXHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblxyXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xyXG5cclxuXHRcdHZhciBpLCBqLCBsLCBvLCBvbDtcclxuXHRcdHZhciBlZGdlID0gWyAwLCAwIF0sIGVkZ2VzID0ge30sIGUsIGVkZ2UxLCBlZGdlMjtcclxuXHRcdHZhciBrZXksIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcclxuXHRcdHZhciB2ZXJ0ZXg7XHJcblxyXG5cdFx0Ly8gZGlmZmVyZW50IGxvZ2ljIGZvciBHZW9tZXRyeSBhbmQgQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZGdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcclxuXHJcblx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRlZGdlMSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRcdFx0ZWRnZTIgPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcclxuXHRcdFx0XHRcdGVkZ2VbIDAgXSA9IE1hdGgubWluKCBlZGdlMSwgZWRnZTIgKTsgLy8gc29ydGluZyBwcmV2ZW50cyBkdXBsaWNhdGVzXHJcblx0XHRcdFx0XHRlZGdlWyAxIF0gPSBNYXRoLm1heCggZWRnZTEsIGVkZ2UyICk7XHJcblxyXG5cdFx0XHRcdFx0a2V5ID0gZWRnZVsgMCBdICsgJywnICsgZWRnZVsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSB9O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXNcclxuXHJcblx0XHRcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcclxuXHJcblx0XHRcdFx0ZSA9IGVkZ2VzWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0dmVydGV4ID0gZ2VvbWV0cnkudmVydGljZXNbIGUuaW5kZXgxIF07XHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZS5pbmRleDIgXTtcclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiwgaW5kaWNlcywgZ3JvdXBzO1xyXG5cdFx0XHR2YXIgZ3JvdXAsIHN0YXJ0LCBjb3VudDtcclxuXHRcdFx0dmFyIGluZGV4MSwgaW5kZXgyO1xyXG5cclxuXHRcdFx0dmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0XHRcdFx0cG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cdFx0XHRcdGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcclxuXHRcdFx0XHRncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XHJcblxyXG5cdFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRncm91cHMgPSBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmNvdW50LCBtYXRlcmlhbEluZGV4OiAwIH0gXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xyXG5cclxuXHRcdFx0XHRmb3IgKCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XHJcblxyXG5cdFx0XHRcdFx0Z3JvdXAgPSBncm91cHNbIG8gXTtcclxuXHJcblx0XHRcdFx0XHRzdGFydCA9IGdyb3VwLnN0YXJ0O1xyXG5cdFx0XHRcdFx0Y291bnQgPSBncm91cC5jb3VudDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gc3RhcnQsIGwgPSAoIHN0YXJ0ICsgY291bnQgKTsgaSA8IGw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZWRnZTEgPSBpbmRpY2VzLmdldFgoIGkgKyBqICk7XHJcblx0XHRcdFx0XHRcdFx0ZWRnZTIgPSBpbmRpY2VzLmdldFgoIGkgKyAoIGogKyAxICkgJSAzICk7XHJcblx0XHRcdFx0XHRcdFx0ZWRnZVsgMCBdID0gTWF0aC5taW4oIGVkZ2UxLCBlZGdlMiApOyAvLyBzb3J0aW5nIHByZXZlbnRzIGR1cGxpY2F0ZXNcclxuXHRcdFx0XHRcdFx0XHRlZGdlWyAxIF0gPSBNYXRoLm1heCggZWRnZTEsIGVkZ2UyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGtleSA9IGVkZ2VbIDAgXSArICcsJyArIGVkZ2VbIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcclxuXHJcblx0XHRcdFx0XHRlID0gZWRnZXNbIGtleSBdO1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgZS5pbmRleDEgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGUuaW5kZXgyICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIEJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSAoIHBvc2l0aW9uLmNvdW50IC8gMyApOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxyXG5cdFx0XHRcdFx0XHQvLyBlLmcuIHRoZSBmaXJzdCB0cmlhbmdsZSBoYXMgdGhlIGZvbGxvd2luZyBlZGdlczogKDAsMSksKDEsMiksKDIsMClcclxuXHJcblx0XHRcdFx0XHRcdGluZGV4MSA9IDMgKiBpICsgajtcclxuXHRcdFx0XHRcdFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDEgKTtcclxuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0XHRcdFx0aW5kZXgyID0gMyAqIGkgKyAoICggaiArIDEgKSAlIDMgKTtcclxuXHRcdFx0XHRcdFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDIgKTtcclxuXHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdFdpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFdpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdpcmVmcmFtZUdlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICpcclxuXHQgKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XHJcblx0ICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcclxuXHQgKi9cclxuXHJcblx0Ly8gUGFyYW1ldHJpY0dlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFBhcmFtZXRyaWNHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0ZnVuYzogZnVuYyxcclxuXHRcdFx0c2xpY2VzOiBzbGljZXMsXHJcblx0XHRcdHN0YWNrczogc3RhY2tzXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRQYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0UGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcclxuXHJcblx0Ly8gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0ZnVuYzogZnVuYyxcclxuXHRcdFx0c2xpY2VzOiBzbGljZXMsXHJcblx0XHRcdHN0YWNrczogc3RhY2tzXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xyXG5cdFx0dmFyIHV2cyA9IFtdO1xyXG5cclxuXHRcdHZhciBFUFMgPSAwLjAwMDAxO1xyXG5cclxuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBwMCA9IG5ldyBWZWN0b3IzKCksIHAxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBwdSA9IG5ldyBWZWN0b3IzKCksIHB2ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgaSwgajtcclxuXHJcblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXHJcblxyXG5cdFx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ID0gaSAvIHN0YWNrcztcclxuXHJcblx0XHRcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHUgPSBqIC8gc2xpY2VzO1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0cDAgPSBmdW5jKCB1LCB2LCBwMCApO1xyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHAwLngsIHAwLnksIHAwLnogKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdC8vIGFwcHJveGltYXRlIHRhbmdlbnQgdmVjdG9ycyB2aWEgZmluaXRlIGRpZmZlcmVuY2VzXHJcblxyXG5cdFx0XHRcdGlmICggdSAtIEVQUyA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHAxID0gZnVuYyggdSAtIEVQUywgdiwgcDEgKTtcclxuXHRcdFx0XHRcdHB1LnN1YlZlY3RvcnMoIHAwLCBwMSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHAxID0gZnVuYyggdSArIEVQUywgdiwgcDEgKTtcclxuXHRcdFx0XHRcdHB1LnN1YlZlY3RvcnMoIHAxLCBwMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggdiAtIEVQUyA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHAxID0gZnVuYyggdSwgdiAtIEVQUywgcDEgKTtcclxuXHRcdFx0XHRcdHB2LnN1YlZlY3RvcnMoIHAwLCBwMSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHAxID0gZnVuYyggdSwgdiArIEVQUywgcDEgKTtcclxuXHRcdFx0XHRcdHB2LnN1YlZlY3RvcnMoIHAxLCBwMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGNyb3NzIHByb2R1Y3Qgb2YgdGFuZ2VudCB2ZWN0b3JzIHJldHVybnMgc3VyZmFjZSBub3JtYWxcclxuXHJcblx0XHRcdFx0bm9ybWFsLmNyb3NzVmVjdG9ycyggcHUsIHB2ICkubm9ybWFsaXplKCk7XHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XHJcblxyXG5cdFx0XHRcdC8vIHV2XHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCB1LCB2ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGkgKiBzbGljZUNvdW50ICsgajtcclxuXHRcdFx0XHR2YXIgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdFx0dmFyIGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblx0XHRcdFx0dmFyIGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcclxuXHJcblx0XHRcdFx0Ly8gZmFjZXMgb25lIGFuZCB0d29cclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0UGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcclxuXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0Ly8gUG9seWhlZHJvbkdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFBvbHloZWRyb25HZW9tZXRyeSggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHZlcnRpY2VzOiB2ZXJ0aWNlcyxcclxuXHRcdFx0aW5kaWNlczogaW5kaWNlcyxcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSApO1xyXG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0UG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5aGVkcm9uR2VvbWV0cnk7XHJcblxyXG5cdC8vIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25CdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXHJcblx0XHRcdGluZGljZXM6IGluZGljZXMsXHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxyXG5cdFx0fTtcclxuXHJcblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuXHRcdGRldGFpbCA9IGRldGFpbCB8fCAwO1xyXG5cclxuXHRcdC8vIGRlZmF1bHQgYnVmZmVyIGRhdGFcclxuXHJcblx0XHR2YXIgdmVydGV4QnVmZmVyID0gW107XHJcblx0XHR2YXIgdXZCdWZmZXIgPSBbXTtcclxuXHJcblx0XHQvLyB0aGUgc3ViZGl2aXNpb24gY3JlYXRlcyB0aGUgdmVydGV4IGJ1ZmZlciBkYXRhXHJcblxyXG5cdFx0c3ViZGl2aWRlKCBkZXRhaWwgKTtcclxuXHJcblx0XHQvLyBhbGwgdmVydGljZXMgc2hvdWxkIGxpZSBvbiBhIGNvbmNlcHR1YWwgc3BoZXJlIHdpdGggYSBnaXZlbiByYWRpdXNcclxuXHJcblx0XHRhcHBwbHlSYWRpdXMoIHJhZGl1cyApO1xyXG5cclxuXHRcdC8vIGZpbmFsbHksIGNyZWF0ZSB0aGUgdXYgZGF0YVxyXG5cclxuXHRcdGdlbmVyYXRlVVZzKCk7XHJcblxyXG5cdFx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlciwgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QnVmZmVyLCAyICkgKTtcclxuXHJcblx0XHRpZiAoIGRldGFpbCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gZmxhdCBub3JtYWxzXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25zXHJcblxyXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBkZXRhaWwgKSB7XHJcblxyXG5cdFx0XHR2YXIgYSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBiID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIGMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc29uIHdpdGggdGhlIGdpdmVuIGRldGFpbCB2YWx1ZVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0Ly8gZ2V0IHRoZSB2ZXJ0aWNlcyBvZiB0aGUgZmFjZVxyXG5cclxuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMCBdLCBhICk7XHJcblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDEgXSwgYiApO1xyXG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAyIF0sIGMgKTtcclxuXHJcblx0XHRcdFx0Ly8gcGVyZm9ybSBzdWJkaXZpc2lvblxyXG5cclxuXHRcdFx0XHRzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbHMgPSBNYXRoLnBvdyggMiwgZGV0YWlsICk7XHJcblxyXG5cdFx0XHQvLyB3ZSB1c2UgdGhpcyBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IGFzIGEgZGF0YSBzdHJ1Y3R1cmUgZm9yIGNyZWF0aW5nIHRoZSBzdWJkaXZpc2lvblxyXG5cclxuXHRcdFx0dmFyIHYgPSBbXTtcclxuXHJcblx0XHRcdHZhciBpLCBqO1xyXG5cclxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb25cclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZbIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHR2YXIgYWogPSBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcclxuXHRcdFx0XHR2YXIgYmogPSBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcclxuXHJcblx0XHRcdFx0dmFyIHJvd3MgPSBjb2xzIC0gaTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNvbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcclxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XHJcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayBdICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xyXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrICsgMSBdICk7XHJcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhcHBwbHlSYWRpdXMoIHJhZGl1cyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xyXG5cdFx0XHRcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xyXG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0gPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0gPSB2ZXJ0ZXgueTtcclxuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XHJcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XHJcblx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdHZhciB1ID0gYXppbXV0aCggdmVydGV4ICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcclxuXHRcdFx0XHR2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZXJ0ZXggKSAvIE1hdGguUEkgKyAwLjU7XHJcblx0XHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvcnJlY3RVVnMoKTtcclxuXHJcblx0XHRcdGNvcnJlY3RTZWFtKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RTZWFtKCkge1xyXG5cclxuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB1dkJ1ZmZlci5sZW5ndGg7IGkgKz0gNiApIHtcclxuXHJcblx0XHRcdFx0Ly8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXHJcblxyXG5cdFx0XHRcdHZhciB4MCA9IHV2QnVmZmVyWyBpICsgMCBdO1xyXG5cdFx0XHRcdHZhciB4MSA9IHV2QnVmZmVyWyBpICsgMiBdO1xyXG5cdFx0XHRcdHZhciB4MiA9IHV2QnVmZmVyWyBpICsgNCBdO1xyXG5cclxuXHRcdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcclxuXHRcdFx0XHR2YXIgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcclxuXHJcblx0XHRcdFx0Ly8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxyXG5cclxuXHRcdFx0XHRpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB4MCA8IDAuMiApIHV2QnVmZmVyWyBpICsgMCBdICs9IDE7XHJcblx0XHRcdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAyIF0gKz0gMTtcclxuXHRcdFx0XHRcdGlmICggeDIgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDQgXSArPSAxO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHB1c2hWZXJ0ZXgoIHZlcnRleCApIHtcclxuXHJcblx0XHRcdHZlcnRleEJ1ZmZlci5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldFZlcnRleEJ5SW5kZXgoIGluZGV4LCB2ZXJ0ZXggKSB7XHJcblxyXG5cdFx0XHR2YXIgc3RyaWRlID0gaW5kZXggKiAzO1xyXG5cclxuXHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMCBdO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBzdHJpZGUgKyAxIF07XHJcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWcygpIHtcclxuXHJcblx0XHRcdHZhciBhID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0dmFyIGIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgYyA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XHJcblx0XHRcdHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHR2YXIgdXZDID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNiApIHtcclxuXHJcblx0XHRcdFx0YS5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDAgXSwgdmVydGV4QnVmZmVyWyBpICsgMSBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gKTtcclxuXHRcdFx0XHRiLnNldCggdmVydGV4QnVmZmVyWyBpICsgMyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA0IF0sIHZlcnRleEJ1ZmZlclsgaSArIDUgXSApO1xyXG5cdFx0XHRcdGMuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyA2IF0sIHZlcnRleEJ1ZmZlclsgaSArIDcgXSwgdmVydGV4QnVmZmVyWyBpICsgOCBdICk7XHJcblxyXG5cdFx0XHRcdHV2QS5zZXQoIHV2QnVmZmVyWyBqICsgMCBdLCB1dkJ1ZmZlclsgaiArIDEgXSApO1xyXG5cdFx0XHRcdHV2Qi5zZXQoIHV2QnVmZmVyWyBqICsgMiBdLCB1dkJ1ZmZlclsgaiArIDMgXSApO1xyXG5cdFx0XHRcdHV2Qy5zZXQoIHV2QnVmZmVyWyBqICsgNCBdLCB1dkJ1ZmZlclsgaiArIDUgXSApO1xyXG5cclxuXHRcdFx0XHRjZW50cm9pZC5jb3B5KCBhICkuYWRkKCBiICkuYWRkKCBjICkuZGl2aWRlU2NhbGFyKCAzICk7XHJcblxyXG5cdFx0XHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xyXG5cclxuXHRcdFx0XHRjb3JyZWN0VVYoIHV2QSwgaiArIDAsIGEsIGF6aSApO1xyXG5cdFx0XHRcdGNvcnJlY3RVViggdXZCLCBqICsgMiwgYiwgYXppICk7XHJcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkMsIGogKyA0LCBjLCBhemkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgc3RyaWRlLCB2ZWN0b3IsIGF6aW11dGggKSB7XHJcblxyXG5cdFx0XHRpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHtcclxuXHJcblx0XHRcdFx0dXZCdWZmZXJbIHN0cmlkZSBdID0gdXYueCAtIDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB7XHJcblxyXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxyXG5cclxuXHRcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKCB2ZWN0b3IueiwgLSB2ZWN0b3IueCApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxyXG5cclxuXHRcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqL1xyXG5cclxuXHQvLyBUZXRyYWhlZHJvbkdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFRldHJhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcclxuXHJcblx0Ly8gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBbXHJcblx0XHRcdDEsIDEsIDEsIFx0LSAxLCAtIDEsIDEsIFx0LSAxLCAxLCAtIDEsIFx0MSwgLSAxLCAtIDFcclxuXHRcdF07XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBbXHJcblx0XHRcdDIsIDEsIDAsIFx0MCwgMywgMixcdDEsIDMsIDAsXHQyLCAzLCAxXHJcblx0XHRdO1xyXG5cclxuXHRcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0Ly8gT2N0YWhlZHJvbkdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIE9jdGFoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRPY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0T2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9jdGFoZWRyb25HZW9tZXRyeTtcclxuXHJcblx0Ly8gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW1xyXG5cdFx0XHQxLCAwLCAwLCBcdC0gMSwgMCwgMCxcdDAsIDEsIDAsXHJcblx0XHRcdDAsIC0gMSwgMCwgXHQwLCAwLCAxLFx0MCwgMCwgLSAxXHJcblx0XHRdO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW1xyXG5cdFx0XHQwLCAyLCA0LFx0MCwgNCwgMyxcdDAsIDMsIDUsXHJcblx0XHRcdDAsIDUsIDIsXHQxLCAyLCA1LFx0MSwgNSwgMyxcclxuXHRcdFx0MSwgMywgNCxcdDEsIDQsIDJcclxuXHRcdF07XHJcblxyXG5cdFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0T2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICovXHJcblxyXG5cdC8vIEljb3NhaGVkcm9uR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gSWNvc2FoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdEljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0SWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJY29zYWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuXHQvLyBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHRcdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW1xyXG5cdFx0XHQtIDEsIHQsIDAsIFx0MSwgdCwgMCwgXHQtIDEsIC0gdCwgMCwgXHQxLCAtIHQsIDAsXHJcblx0XHRcdCAwLCAtIDEsIHQsIFx0MCwgMSwgdCxcdDAsIC0gMSwgLSB0LCBcdDAsIDEsIC0gdCxcclxuXHRcdFx0IHQsIDAsIC0gMSwgXHR0LCAwLCAxLCBcdC0gdCwgMCwgLSAxLCBcdC0gdCwgMCwgMVxyXG5cdFx0XTtcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFtcclxuXHRcdFx0IDAsIDExLCA1LCBcdDAsIDUsIDEsIFx0MCwgMSwgNywgXHQwLCA3LCAxMCwgXHQwLCAxMCwgMTEsXHJcblx0XHRcdCAxLCA1LCA5LCBcdDUsIDExLCA0LFx0MTEsIDEwLCAyLFx0MTAsIDcsIDYsXHQ3LCAxLCA4LFxyXG5cdFx0XHQgMywgOSwgNCwgXHQzLCA0LCAyLFx0MywgMiwgNixcdDMsIDYsIDgsXHQzLCA4LCA5LFxyXG5cdFx0XHQgNCwgOSwgNSwgXHQyLCA0LCAxMSxcdDYsIDIsIDEwLFx0OCwgNiwgNyxcdDksIDgsIDFcclxuXHRcdF07XHJcblxyXG5cdFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0Ly8gRG9kZWNhaGVkcm9uR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gRG9kZWNhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdGRldGFpbDogZGV0YWlsXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdERvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdERvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvZGVjYWhlZHJvbkdlb21ldHJ5O1xyXG5cclxuXHQvLyBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdFx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcclxuXHRcdHZhciByID0gMSAvIHQ7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW1xyXG5cclxuXHRcdFx0Ly8gKMKxMSwgwrExLCDCsTEpXHJcblx0XHRcdC0gMSwgLSAxLCAtIDEsXHQtIDEsIC0gMSwgMSxcclxuXHRcdFx0LSAxLCAxLCAtIDEsIC0gMSwgMSwgMSxcclxuXHRcdFx0MSwgLSAxLCAtIDEsIDEsIC0gMSwgMSxcclxuXHRcdFx0MSwgMSwgLSAxLCAxLCAxLCAxLFxyXG5cclxuXHRcdFx0Ly8gKDAsIMKxMS/PhiwgwrHPhilcclxuXHRcdFx0IDAsIC0gciwgLSB0LCAwLCAtIHIsIHQsXHJcblx0XHRcdCAwLCByLCAtIHQsIDAsIHIsIHQsXHJcblxyXG5cdFx0XHQvLyAowrExL8+GLCDCsc+GLCAwKVxyXG5cdFx0XHQtIHIsIC0gdCwgMCwgLSByLCB0LCAwLFxyXG5cdFx0XHQgciwgLSB0LCAwLCByLCB0LCAwLFxyXG5cclxuXHRcdFx0Ly8gKMKxz4YsIDAsIMKxMS/PhilcclxuXHRcdFx0LSB0LCAwLCAtIHIsIHQsIDAsIC0gcixcclxuXHRcdFx0LSB0LCAwLCByLCB0LCAwLCByXHJcblx0XHRdO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW1xyXG5cdFx0XHQzLCAxMSwgNywgXHQzLCA3LCAxNSwgXHQzLCAxNSwgMTMsXHJcblx0XHRcdDcsIDE5LCAxNywgXHQ3LCAxNywgNiwgXHQ3LCA2LCAxNSxcclxuXHRcdFx0MTcsIDQsIDgsIFx0MTcsIDgsIDEwLCBcdDE3LCAxMCwgNixcclxuXHRcdFx0OCwgMCwgMTYsIFx0OCwgMTYsIDIsIFx0OCwgMiwgMTAsXHJcblx0XHRcdDAsIDEyLCAxLCBcdDAsIDEsIDE4LCBcdDAsIDE4LCAxNixcclxuXHRcdFx0NiwgMTAsIDIsIFx0NiwgMiwgMTMsIFx0NiwgMTMsIDE1LFxyXG5cdFx0XHQyLCAxNiwgMTgsIFx0MiwgMTgsIDMsIFx0MiwgMywgMTMsXHJcblx0XHRcdDE4LCAxLCA5LCBcdDE4LCA5LCAxMSwgXHQxOCwgMTEsIDMsXHJcblx0XHRcdDQsIDE0LCAxMiwgXHQ0LCAxMiwgMCwgXHQ0LCAwLCA4LFxyXG5cdFx0XHQxMSwgOSwgNSwgXHQxMSwgNSwgMTksIFx0MTEsIDE5LCA3LFxyXG5cdFx0XHQxOSwgNSwgMTQsIFx0MTksIDE0LCA0LCBcdDE5LCA0LCAxNyxcclxuXHRcdFx0MSwgMTIsIDE0LCBcdDEsIDE0LCA1LCBcdDEsIDUsIDlcclxuXHRcdF07XHJcblxyXG5cdFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0ZGV0YWlsOiBkZXRhaWxcclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG9vc21veGllY29kZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9vb3Ntb3hpZWNvZGVcclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcclxuXHQgKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcclxuXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICpcclxuXHQgKi9cclxuXHJcblx0Ly8gVHViZUdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFR1YmVHZW9tZXRyeSggcGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHBhdGg6IHBhdGgsXHJcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRjbG9zZWQ6IGNsb3NlZFxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoIHRhcGVyICE9PSB1bmRlZmluZWQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5UdWJlR2VvbWV0cnk6IHRhcGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdHZhciBidWZmZXJHZW9tZXRyeSA9IG5ldyBUdWJlQnVmZmVyR2VvbWV0cnkoIHBhdGgsIHR1YnVsYXJTZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkICk7XHJcblxyXG5cdFx0Ly8gZXhwb3NlIGludGVybmFsc1xyXG5cclxuXHRcdHRoaXMudGFuZ2VudHMgPSBidWZmZXJHZW9tZXRyeS50YW5nZW50cztcclxuXHRcdHRoaXMubm9ybWFscyA9IGJ1ZmZlckdlb21ldHJ5Lm5vcm1hbHM7XHJcblx0XHR0aGlzLmJpbm9ybWFscyA9IGJ1ZmZlckdlb21ldHJ5LmJpbm9ybWFscztcclxuXHJcblx0XHQvLyBjcmVhdGUgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggYnVmZmVyR2VvbWV0cnkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdFR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRUdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUdlb21ldHJ5O1xyXG5cclxuXHQvLyBUdWJlQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gVHViZUJ1ZmZlckdlb21ldHJ5KCBwYXRoLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCApIHtcclxuXHJcblx0XHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1R1YmVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRwYXRoOiBwYXRoLFxyXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0Y2xvc2VkOiBjbG9zZWRcclxuXHRcdH07XHJcblxyXG5cdFx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY0O1xyXG5cdFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblx0XHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XHJcblx0XHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcblxyXG5cdFx0dmFyIGZyYW1lcyA9IHBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggdHVidWxhclNlZ21lbnRzLCBjbG9zZWQgKTtcclxuXHJcblx0XHQvLyBleHBvc2UgaW50ZXJuYWxzXHJcblxyXG5cdFx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcclxuXHRcdHRoaXMubm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzO1xyXG5cdFx0dGhpcy5iaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdHZhciBQID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgaSwgajtcclxuXHJcblx0XHQvLyBidWZmZXJcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgdXZzID0gW107XHJcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSBidWZmZXIgZGF0YVxyXG5cclxuXHRcdGdlbmVyYXRlQnVmZmVyRGF0YSgpO1xyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0XHQvLyBmdW5jdGlvbnNcclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlckRhdGEoKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VuZXJhdGVTZWdtZW50KCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXHJcblx0XHRcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXHJcblx0XHRcdC8vXHJcblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXHJcblxyXG5cdFx0XHRnZW5lcmF0ZVNlZ21lbnQoICggY2xvc2VkID09PSBmYWxzZSApID8gdHVidWxhclNlZ21lbnRzIDogMCApO1xyXG5cclxuXHRcdFx0Ly8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cclxuXHRcdFx0Ly8gdGhpcyBtYWtlcyBpdCBlYXN5IGNvbXB1dGUgY29ycmVjdCB2YWx1ZXMgZm9yIGNsb3NlZCBnZW9tZXRyaWVzXHJcblxyXG5cdFx0XHRnZW5lcmF0ZVVWcygpO1xyXG5cclxuXHRcdFx0Ly8gZmluYWxseSBjcmVhdGUgZmFjZXNcclxuXHJcblx0XHRcdGdlbmVyYXRlSW5kaWNlcygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoIGkgKSB7XHJcblxyXG5cdFx0XHQvLyB3ZSB1c2UgZ2V0UG9pbnRBdCB0byBzYW1wbGUgZXZlbmx5IGRpc3RyaWJ1dGVkIHBvaW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoXHJcblxyXG5cdFx0XHRQID0gcGF0aC5nZXRQb2ludEF0KCBpIC8gdHVidWxhclNlZ21lbnRzLCBQICk7XHJcblxyXG5cdFx0XHQvLyByZXRyaWV2ZSBjb3JyZXNwb25kaW5nIG5vcm1hbCBhbmQgYmlub3JtYWxcclxuXHJcblx0XHRcdHZhciBOID0gZnJhbWVzLm5vcm1hbHNbIGkgXTtcclxuXHRcdFx0dmFyIEIgPSBmcmFtZXMuYmlub3JtYWxzWyBpIF07XHJcblxyXG5cdFx0XHQvLyBnZW5lcmF0ZSBub3JtYWxzIGFuZCB2ZXJ0aWNlcyBmb3IgdGhlIGN1cnJlbnQgc2VnbWVudFxyXG5cclxuXHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdiApO1xyXG5cdFx0XHRcdHZhciBjb3MgPSAtIE1hdGguY29zKCB2ICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vcm1hbFxyXG5cclxuXHRcdFx0XHRub3JtYWwueCA9ICggY29zICogTi54ICsgc2luICogQi54ICk7XHJcblx0XHRcdFx0bm9ybWFsLnkgPSAoIGNvcyAqIE4ueSArIHNpbiAqIEIueSApO1xyXG5cdFx0XHRcdG5vcm1hbC56ID0gKCBjb3MgKiBOLnogKyBzaW4gKiBCLnogKTtcclxuXHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IFAueSArIHJhZGl1cyAqIG5vcm1hbC55O1xyXG5cdFx0XHRcdHZlcnRleC56ID0gUC56ICsgcmFkaXVzICogbm9ybWFsLno7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpY2VzKCkge1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XHJcblx0XHRcdFx0XHR2YXIgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XHJcblx0XHRcdFx0XHR2YXIgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXYueCA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XHJcblx0XHRcdFx0XHR1di55ID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0VHViZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFR1YmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUdWJlQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3Igb29zbW94aWVjb2RlXHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKlxyXG5cdCAqIGJhc2VkIG9uIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wcXRvcnVzL1xyXG5cdCAqL1xyXG5cclxuXHQvLyBUb3J1c0tub3RHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBUb3J1c0tub3RHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHR0dWJlOiB0dWJlLFxyXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcclxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRwOiBwLFxyXG5cdFx0XHRxOiBxXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICggaGVpZ2h0U2NhbGUgIT09IHVuZGVmaW5lZCApIGNvbnNvbGUud2FybiggJ1RIUkVFLlRvcnVzS25vdEdlb21ldHJ5OiBoZWlnaHRTY2FsZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnNjYWxlKCB4LCB5LCB6ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdFRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEdlb21ldHJ5O1xyXG5cclxuXHQvLyBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxICkge1xyXG5cclxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90QnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdHR1YmU6IHR1YmUsXHJcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdHA6IHAsXHJcblx0XHRcdHE6IHFcclxuXHRcdH07XHJcblxyXG5cdFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblx0XHR0dWJlID0gdHViZSB8fCAwLjQ7XHJcblx0XHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2NDtcclxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xyXG5cdFx0cCA9IHAgfHwgMjtcclxuXHRcdHEgPSBxIHx8IDM7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW107XHJcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgdXZzID0gW107XHJcblxyXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xyXG5cclxuXHRcdHZhciBpLCBqO1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIFAxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBQMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIEIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIFQgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIE4gPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHQvLyB0aGUgcmFkaWFuIFwidVwiIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmUgb2YgdGhlIGN1cnJlbnQgdHVidWxhciBzZWdlbWVudFxyXG5cclxuXHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdFx0Ly8gbm93IHdlIGNhbGN1bGF0ZSB0d28gcG9pbnRzLiBQMSBpcyBvdXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmUsIFAyIGlzIGEgbGl0dGxlIGZhcnRoZXIgYWhlYWQuXHJcblx0XHRcdC8vIHRoZXNlIHBvaW50cyBhcmUgdXNlZCB0byBjcmVhdGUgYSBzcGVjaWFsIFwiY29vcmRpbmF0ZSBzcGFjZVwiLCB3aGljaCBpcyBuZWNlc3NhcnkgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHZlcnRleCBwb3NpdGlvbnNcclxuXHJcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBQMSApO1xyXG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyICk7XHJcblxyXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcclxuXHJcblx0XHRcdFQuc3ViVmVjdG9ycyggUDIsIFAxICk7XHJcblx0XHRcdE4uYWRkVmVjdG9ycyggUDIsIFAxICk7XHJcblx0XHRcdEIuY3Jvc3NWZWN0b3JzKCBULCBOICk7XHJcblx0XHRcdE4uY3Jvc3NWZWN0b3JzKCBCLCBUICk7XHJcblxyXG5cdFx0XHQvLyBub3JtYWxpemUgQiwgTi4gVCBjYW4gYmUgaWdub3JlZCwgd2UgZG9uJ3QgdXNlIGl0XHJcblxyXG5cdFx0XHRCLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHROLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxyXG5cdFx0XHRcdC8vIGJlY2F1c2Ugd2UgZXh0cnVkZSBhIHNoYXBlIGluIHRoZSB4eS1wbGFuZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgYSB6LXZhbHVlLlxyXG5cclxuXHRcdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xyXG5cdFx0XHRcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XHJcblx0XHRcdFx0dmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHRcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIGZpbmFsIHZlcnRleCBwb3NpdGlvbi5cclxuXHRcdFx0XHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3MsIHRoZW4gd2UgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZVxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAxLnggKyAoIGN4ICogTi54ICsgY3kgKiBCLnggKTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IFAxLnkgKyAoIGN4ICogTi55ICsgY3kgKiBCLnkgKTtcclxuXHRcdFx0XHR2ZXJ0ZXgueiA9IFAxLnogKyAoIGN4ICogTi56ICsgY3kgKiBCLnogKTtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0XHQvLyBub3JtYWwgKFAxIGlzIGFsd2F5cyB0aGUgY2VudGVyL29yaWdpbiBvZiB0aGUgZXh0cnVzaW9uLCB0aHVzIHdlIGNhbiB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWwpXHJcblxyXG5cdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIFAxICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cclxuXHRcdFx0XHQvLyB1dlxyXG5cclxuXHRcdFx0XHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xyXG5cclxuXHRcdGZvciAoIGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0XHRcdHZhciBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcclxuXHRcdFx0XHR2YXIgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xyXG5cdFx0XHRcdHZhciBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xyXG5cdFx0XHRcdHZhciBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XHJcblxyXG5cdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xyXG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG5cdFx0Ly8gdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBwb3NpdGlvbiApIHtcclxuXHJcblx0XHRcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XHJcblx0XHRcdHZhciBzdSA9IE1hdGguc2luKCB1ICk7XHJcblx0XHRcdHZhciBxdU92ZXJQID0gcSAvIHAgKiB1O1xyXG5cdFx0XHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xyXG5cclxuXHRcdFx0cG9zaXRpb24ueCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcclxuXHRcdFx0cG9zaXRpb24ueSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcclxuXHRcdFx0cG9zaXRpb24ueiA9IHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG9vc21veGllY29kZVxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0Ly8gVG9ydXNHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBUb3J1c0dlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcclxuXHJcblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdHR1YmU6IHR1YmUsXHJcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdGFyYzogYXJjXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVG9ydXNCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSApO1xyXG5cdFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0VG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRUb3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzR2VvbWV0cnk7XHJcblxyXG5cdC8vIFRvcnVzQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gVG9ydXNCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0J1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHR0dWJlOiB0dWJlLFxyXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRhcmM6IGFyY1xyXG5cdFx0fTtcclxuXHJcblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcclxuXHRcdHR1YmUgPSB0dWJlIHx8IDAuNDtcclxuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xyXG5cdFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICkgfHwgNjtcclxuXHRcdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHJcblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXHJcblxyXG5cdFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBqLCBpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xyXG5cdFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRleFxyXG5cclxuXHRcdFx0XHR2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XHJcblx0XHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xyXG5cdFx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcclxuXHRcdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XHJcblx0XHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgY2VudGVyICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xyXG5cclxuXHRcdFx0XHQvLyB1dlxyXG5cclxuXHRcdFx0XHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xyXG5cclxuXHRcdGZvciAoIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0XHRcdHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XHJcblx0XHRcdFx0dmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xyXG5cdFx0XHRcdHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xyXG5cdFx0XHRcdHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcclxuXHJcblx0XHRcdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRUb3J1c0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFRvcnVzQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjEuMilcclxuXHQgKi9cclxuXHJcblx0dmFyIEVhcmN1dCA9IHtcclxuXHJcblx0XHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKCBkYXRhLCBob2xlSW5kaWNlcywgZGltICkge1xyXG5cclxuXHRcdFx0ZGltID0gZGltIHx8IDI7XHJcblxyXG5cdFx0XHR2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXHJcblx0XHRcdFx0b3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWyAwIF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcclxuXHRcdFx0XHRvdXRlck5vZGUgPSBsaW5rZWRMaXN0KCBkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlICksXHJcblx0XHRcdFx0dHJpYW5nbGVzID0gW107XHJcblxyXG5cdFx0XHRpZiAoICEgb3V0ZXJOb2RlICkgcmV0dXJuIHRyaWFuZ2xlcztcclxuXHJcblx0XHRcdHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xyXG5cclxuXHRcdFx0aWYgKCBoYXNIb2xlcyApIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKTtcclxuXHJcblx0XHRcdC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxyXG5cclxuXHRcdFx0aWYgKCBkYXRhLmxlbmd0aCA+IDgwICogZGltICkge1xyXG5cclxuXHRcdFx0XHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcclxuXHRcdFx0XHRtaW5ZID0gbWF4WSA9IGRhdGFbIDEgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IGRhdGFbIGkgXTtcclxuXHRcdFx0XHRcdHkgPSBkYXRhWyBpICsgMSBdO1xyXG5cdFx0XHRcdFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xyXG5cdFx0XHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xyXG5cdFx0XHRcdFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xyXG5cdFx0XHRcdFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXHJcblxyXG5cdFx0XHRcdGludlNpemUgPSBNYXRoLm1heCggbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZICk7XHJcblx0XHRcdFx0aW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlYXJjdXRMaW5rZWQoIG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0cmlhbmdsZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcclxuXHJcblx0ZnVuY3Rpb24gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0dmFyIGksIGxhc3Q7XHJcblxyXG5cdFx0aWYgKCBjbG9ja3dpc2UgPT09ICggc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkgPiAwICkgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBsYXN0ICYmIGVxdWFscyggbGFzdCwgbGFzdC5uZXh0ICkgKSB7XHJcblxyXG5cdFx0XHRyZW1vdmVOb2RlKCBsYXN0ICk7XHJcblx0XHRcdGxhc3QgPSBsYXN0Lm5leHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYXN0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlclBvaW50cyggc3RhcnQsIGVuZCApIHtcclxuXHJcblx0XHRpZiAoICEgc3RhcnQgKSByZXR1cm4gc3RhcnQ7XHJcblx0XHRpZiAoICEgZW5kICkgZW5kID0gc3RhcnQ7XHJcblxyXG5cdFx0dmFyIHAgPSBzdGFydCwgYWdhaW47XHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0YWdhaW4gPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggISBwLnN0ZWluZXIgJiYgKCBlcXVhbHMoIHAsIHAubmV4dCApIHx8IGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPT09IDAgKSApIHtcclxuXHJcblx0XHRcdFx0cmVtb3ZlTm9kZSggcCApO1xyXG5cdFx0XHRcdHAgPSBlbmQgPSBwLnByZXY7XHJcblx0XHRcdFx0aWYgKCBwID09PSBwLm5leHQgKSBicmVhaztcclxuXHRcdFx0XHRhZ2FpbiA9IHRydWU7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gd2hpbGUgKCBhZ2FpbiB8fCBwICE9PSBlbmQgKTtcclxuXHJcblx0XHRyZXR1cm4gZW5kO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxyXG5cclxuXHRmdW5jdGlvbiBlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MgKSB7XHJcblxyXG5cdFx0aWYgKCAhIGVhciApIHJldHVybjtcclxuXHJcblx0XHQvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXHJcblxyXG5cdFx0aWYgKCAhIHBhc3MgJiYgaW52U2l6ZSApIGluZGV4Q3VydmUoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cclxuXHRcdHZhciBzdG9wID0gZWFyLCBwcmV2LCBuZXh0O1xyXG5cclxuXHRcdC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxyXG5cclxuXHRcdHdoaWxlICggZWFyLnByZXYgIT09IGVhci5uZXh0ICkge1xyXG5cclxuXHRcdFx0cHJldiA9IGVhci5wcmV2O1xyXG5cdFx0XHRuZXh0ID0gZWFyLm5leHQ7XHJcblxyXG5cdFx0XHRpZiAoIGludlNpemUgPyBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkgOiBpc0VhciggZWFyICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXHJcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goIHByZXYuaSAvIGRpbSApO1xyXG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBlYXIuaSAvIGRpbSApO1xyXG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBuZXh0LmkgLyBkaW0gKTtcclxuXHJcblx0XHRcdFx0cmVtb3ZlTm9kZSggZWFyICk7XHJcblxyXG5cdFx0XHRcdC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRpY2UgbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXHJcblx0XHRcdFx0ZWFyID0gbmV4dC5uZXh0O1xyXG5cdFx0XHRcdHN0b3AgPSBuZXh0Lm5leHQ7XHJcblxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWFyID0gbmV4dDtcclxuXHJcblx0XHRcdC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXHJcblxyXG5cdFx0XHRpZiAoIGVhciA9PT0gc3RvcCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cclxuXHJcblx0XHRcdFx0aWYgKCAhIHBhc3MgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZWFyY3V0TGlua2VkKCBmaWx0ZXJQb2ludHMoIGVhciApLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSApO1xyXG5cclxuXHRcdFx0XHRcdC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggZWFyLCB0cmlhbmdsZXMsIGRpbSApO1xyXG5cdFx0XHRcdFx0ZWFyY3V0TGlua2VkKCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyICk7XHJcblxyXG5cdFx0XHRcdC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0c3BsaXRFYXJjdXQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXHJcblxyXG5cdGZ1bmN0aW9uIGlzRWFyKCBlYXIgKSB7XHJcblxyXG5cdFx0dmFyIGEgPSBlYXIucHJldixcclxuXHRcdFx0YiA9IGVhcixcclxuXHRcdFx0YyA9IGVhci5uZXh0O1xyXG5cclxuXHRcdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXHJcblxyXG5cdFx0Ly8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcclxuXHRcdHZhciBwID0gZWFyLm5leHQubmV4dDtcclxuXHJcblx0XHR3aGlsZSAoIHAgIT09IGVhci5wcmV2ICkge1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xyXG5cclxuXHRcdHZhciBhID0gZWFyLnByZXYsXHJcblx0XHRcdGIgPSBlYXIsXHJcblx0XHRcdGMgPSBlYXIubmV4dDtcclxuXHJcblx0XHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG5cclxuXHRcdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXHJcblxyXG5cdFx0dmFyIG1pblRYID0gYS54IDwgYi54ID8gKCBhLnggPCBjLnggPyBhLnggOiBjLnggKSA6ICggYi54IDwgYy54ID8gYi54IDogYy54ICksXHJcblx0XHRcdG1pblRZID0gYS55IDwgYi55ID8gKCBhLnkgPCBjLnkgPyBhLnkgOiBjLnkgKSA6ICggYi55IDwgYy55ID8gYi55IDogYy55ICksXHJcblx0XHRcdG1heFRYID0gYS54ID4gYi54ID8gKCBhLnggPiBjLnggPyBhLnggOiBjLnggKSA6ICggYi54ID4gYy54ID8gYi54IDogYy54ICksXHJcblx0XHRcdG1heFRZID0gYS55ID4gYi55ID8gKCBhLnkgPiBjLnkgPyBhLnkgOiBjLnkgKSA6ICggYi55ID4gYy55ID8gYi55IDogYy55ICk7XHJcblxyXG5cdFx0Ly8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcclxuXHJcblx0XHR2YXIgbWluWiA9IHpPcmRlciggbWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplICksXHJcblx0XHRcdG1heFogPSB6T3JkZXIoIG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cclxuXHRcdC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxyXG5cclxuXHRcdHZhciBwID0gZWFyLm5leHRaO1xyXG5cclxuXHRcdHdoaWxlICggcCAmJiBwLnogPD0gbWF4WiApIHtcclxuXHJcblx0XHRcdGlmICggcCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuXHRcdFx0XHRcdHBvaW50SW5UcmlhbmdsZSggYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkgKSAmJlxyXG5cdFx0XHRcdFx0YXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRwID0gcC5uZXh0WjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXHJcblxyXG5cdFx0cCA9IGVhci5wcmV2WjtcclxuXHJcblx0XHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXHJcblx0XHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiZcclxuXHRcdFx0XHRcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdHAgPSBwLnByZXZaO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xyXG5cclxuXHRmdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBzdGFydCwgdHJpYW5nbGVzLCBkaW0gKSB7XHJcblxyXG5cdFx0dmFyIHAgPSBzdGFydDtcclxuXHJcblx0XHRkbyB7XHJcblxyXG5cdFx0XHR2YXIgYSA9IHAucHJldiwgYiA9IHAubmV4dC5uZXh0O1xyXG5cclxuXHRcdFx0aWYgKCAhIGVxdWFscyggYSwgYiApICYmIGludGVyc2VjdHMoIGEsIHAsIHAubmV4dCwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgKSB7XHJcblxyXG5cdFx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBhLmkgLyBkaW0gKTtcclxuXHRcdFx0XHR0cmlhbmdsZXMucHVzaCggcC5pIC8gZGltICk7XHJcblx0XHRcdFx0dHJpYW5nbGVzLnB1c2goIGIuaSAvIGRpbSApO1xyXG5cclxuXHRcdFx0XHQvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXHJcblxyXG5cdFx0XHRcdHJlbW92ZU5vZGUoIHAgKTtcclxuXHRcdFx0XHRyZW1vdmVOb2RlKCBwLm5leHQgKTtcclxuXHJcblx0XHRcdFx0cCA9IHN0YXJ0ID0gYjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHAgPSBwLm5leHQ7XHJcblxyXG5cdFx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHA7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcclxuXHJcblx0ZnVuY3Rpb24gc3BsaXRFYXJjdXQoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0XHQvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xyXG5cclxuXHRcdHZhciBhID0gc3RhcnQ7XHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0dmFyIGIgPSBhLm5leHQubmV4dDtcclxuXHJcblx0XHRcdHdoaWxlICggYiAhPT0gYS5wcmV2ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbCggYSwgYiApICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcclxuXHJcblx0XHRcdFx0XHR2YXIgYyA9IHNwbGl0UG9seWdvbiggYSwgYiApO1xyXG5cclxuXHRcdFx0XHRcdC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXHJcblxyXG5cdFx0XHRcdFx0YSA9IGZpbHRlclBvaW50cyggYSwgYS5uZXh0ICk7XHJcblx0XHRcdFx0XHRjID0gZmlsdGVyUG9pbnRzKCBjLCBjLm5leHQgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxyXG5cclxuXHRcdFx0XHRcdGVhcmN1dExpbmtlZCggYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHRcdFx0XHRcdGVhcmN1dExpbmtlZCggYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRiID0gYi5uZXh0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YSA9IGEubmV4dDtcclxuXHJcblx0XHR9IHdoaWxlICggYSAhPT0gc3RhcnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXHJcblxyXG5cdGZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKSB7XHJcblxyXG5cdFx0dmFyIHF1ZXVlID0gW10sIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0c3RhcnQgPSBob2xlSW5kaWNlc1sgaSBdICogZGltO1xyXG5cdFx0XHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzWyBpICsgMSBdICogZGltIDogZGF0YS5sZW5ndGg7XHJcblx0XHRcdGxpc3QgPSBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlICk7XHJcblx0XHRcdGlmICggbGlzdCA9PT0gbGlzdC5uZXh0ICkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcclxuXHRcdFx0cXVldWUucHVzaCggZ2V0TGVmdG1vc3QoIGxpc3QgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRxdWV1ZS5zb3J0KCBjb21wYXJlWCApO1xyXG5cclxuXHRcdC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRlbGltaW5hdGVIb2xlKCBxdWV1ZVsgaSBdLCBvdXRlck5vZGUgKTtcclxuXHRcdFx0b3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKCBvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvdXRlck5vZGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29tcGFyZVgoIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEueCAtIGIueDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcclxuXHJcblx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZSggaG9sZSwgb3V0ZXJOb2RlICkge1xyXG5cclxuXHRcdG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKTtcclxuXHJcblx0XHRpZiAoIG91dGVyTm9kZSApIHtcclxuXHJcblx0XHRcdHZhciBiID0gc3BsaXRQb2x5Z29uKCBvdXRlck5vZGUsIGhvbGUgKTtcclxuXHJcblx0XHRcdGZpbHRlclBvaW50cyggYiwgYi5uZXh0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cclxuXHJcblx0ZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApIHtcclxuXHJcblx0XHR2YXIgcCA9IG91dGVyTm9kZSxcclxuXHRcdFx0aHggPSBob2xlLngsXHJcblx0XHRcdGh5ID0gaG9sZS55LFxyXG5cdFx0XHRxeCA9IC0gSW5maW5pdHksXHJcblx0XHRcdG07XHJcblxyXG5cdFx0Ly8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xyXG5cdFx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxyXG5cclxuXHRcdGRvIHtcclxuXHJcblx0XHRcdGlmICggaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB4ID0gcC54ICsgKCBoeSAtIHAueSApICogKCBwLm5leHQueCAtIHAueCApIC8gKCBwLm5leHQueSAtIHAueSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHggPD0gaHggJiYgeCA+IHF4ICkge1xyXG5cclxuXHRcdFx0XHRcdHF4ID0geDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHggPT09IGh4ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBoeSA9PT0gcC55ICkgcmV0dXJuIHA7XHJcblx0XHRcdFx0XHRcdGlmICggaHkgPT09IHAubmV4dC55ICkgcmV0dXJuIHAubmV4dDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cCA9IHAubmV4dDtcclxuXHJcblx0XHR9IHdoaWxlICggcCAhPT0gb3V0ZXJOb2RlICk7XHJcblxyXG5cdFx0aWYgKCAhIG0gKSByZXR1cm4gbnVsbDtcclxuXHJcblx0XHRpZiAoIGh4ID09PSBxeCApIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XHJcblxyXG5cdFx0Ly8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xyXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XHJcblx0XHQvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxyXG5cclxuXHRcdHZhciBzdG9wID0gbSxcclxuXHRcdFx0bXggPSBtLngsXHJcblx0XHRcdG15ID0gbS55LFxyXG5cdFx0XHR0YW5NaW4gPSBJbmZpbml0eSxcclxuXHRcdFx0dGFuO1xyXG5cclxuXHRcdHAgPSBtLm5leHQ7XHJcblxyXG5cdFx0d2hpbGUgKCBwICE9PSBzdG9wICkge1xyXG5cclxuXHRcdFx0aWYgKCBoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcclxuXHRcdFx0XHRcdFx0XHRwb2ludEluVHJpYW5nbGUoIGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55ICkgKSB7XHJcblxyXG5cdFx0XHRcdHRhbiA9IE1hdGguYWJzKCBoeSAtIHAueSApIC8gKCBoeCAtIHAueCApOyAvLyB0YW5nZW50aWFsXHJcblxyXG5cdFx0XHRcdGlmICggKCB0YW4gPCB0YW5NaW4gfHwgKCB0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLnggKSApICYmIGxvY2FsbHlJbnNpZGUoIHAsIGhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRtID0gcDtcclxuXHRcdFx0XHRcdHRhbk1pbiA9IHRhbjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cCA9IHAubmV4dDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG07XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxyXG5cclxuXHRmdW5jdGlvbiBpbmRleEN1cnZlKCBzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0XHR2YXIgcCA9IHN0YXJ0O1xyXG5cclxuXHRcdGRvIHtcclxuXHJcblx0XHRcdGlmICggcC56ID09PSBudWxsICkgcC56ID0gek9yZGVyKCBwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xyXG5cdFx0XHRwLnByZXZaID0gcC5wcmV2O1xyXG5cdFx0XHRwLm5leHRaID0gcC5uZXh0O1xyXG5cdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xyXG5cclxuXHRcdHAucHJldloubmV4dFogPSBudWxsO1xyXG5cdFx0cC5wcmV2WiA9IG51bGw7XHJcblxyXG5cdFx0c29ydExpbmtlZCggcCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXHJcblx0Ly8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcclxuXHJcblx0ZnVuY3Rpb24gc29ydExpbmtlZCggbGlzdCApIHtcclxuXHJcblx0XHR2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsIGluU2l6ZSA9IDE7XHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0cCA9IGxpc3Q7XHJcblx0XHRcdGxpc3QgPSBudWxsO1xyXG5cdFx0XHR0YWlsID0gbnVsbDtcclxuXHRcdFx0bnVtTWVyZ2VzID0gMDtcclxuXHJcblx0XHRcdHdoaWxlICggcCApIHtcclxuXHJcblx0XHRcdFx0bnVtTWVyZ2VzICsrO1xyXG5cdFx0XHRcdHEgPSBwO1xyXG5cdFx0XHRcdHBTaXplID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBpblNpemU7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0cFNpemUgKys7XHJcblx0XHRcdFx0XHRxID0gcS5uZXh0WjtcclxuXHRcdFx0XHRcdGlmICggISBxICkgYnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cVNpemUgPSBpblNpemU7XHJcblxyXG5cdFx0XHRcdHdoaWxlICggcFNpemUgPiAwIHx8ICggcVNpemUgPiAwICYmIHEgKSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHBTaXplICE9PSAwICYmICggcVNpemUgPT09IDAgfHwgISBxIHx8IHAueiA8PSBxLnogKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGUgPSBwO1xyXG5cdFx0XHRcdFx0XHRwID0gcC5uZXh0WjtcclxuXHRcdFx0XHRcdFx0cFNpemUgLS07XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGUgPSBxO1xyXG5cdFx0XHRcdFx0XHRxID0gcS5uZXh0WjtcclxuXHRcdFx0XHRcdFx0cVNpemUgLS07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xyXG5cdFx0XHRcdFx0ZWxzZSBsaXN0ID0gZTtcclxuXHJcblx0XHRcdFx0XHRlLnByZXZaID0gdGFpbDtcclxuXHRcdFx0XHRcdHRhaWwgPSBlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHAgPSBxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGFpbC5uZXh0WiA9IG51bGw7XHJcblx0XHRcdGluU2l6ZSAqPSAyO1xyXG5cclxuXHRcdH0gd2hpbGUgKCBudW1NZXJnZXMgPiAxICk7XHJcblxyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XHJcblxyXG5cdGZ1bmN0aW9uIHpPcmRlciggeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcclxuXHJcblx0XHQvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXHJcblxyXG5cdFx0eCA9IDMyNzY3ICogKCB4IC0gbWluWCApICogaW52U2l6ZTtcclxuXHRcdHkgPSAzMjc2NyAqICggeSAtIG1pblkgKSAqIGludlNpemU7XHJcblxyXG5cdFx0eCA9ICggeCB8ICggeCA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XHJcblx0XHR4ID0gKCB4IHwgKCB4IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcclxuXHRcdHggPSAoIHggfCAoIHggPDwgMiApICkgJiAweDMzMzMzMzMzO1xyXG5cdFx0eCA9ICggeCB8ICggeCA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XHJcblxyXG5cdFx0eSA9ICggeSB8ICggeSA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XHJcblx0XHR5ID0gKCB5IHwgKCB5IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcclxuXHRcdHkgPSAoIHkgfCAoIHkgPDwgMiApICkgJiAweDMzMzMzMzMzO1xyXG5cdFx0eSA9ICggeSB8ICggeSA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XHJcblxyXG5cdFx0cmV0dXJuIHggfCAoIHkgPDwgMSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcclxuXHJcblx0ZnVuY3Rpb24gZ2V0TGVmdG1vc3QoIHN0YXJ0ICkge1xyXG5cclxuXHRcdHZhciBwID0gc3RhcnQsIGxlZnRtb3N0ID0gc3RhcnQ7XHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0aWYgKCBwLnggPCBsZWZ0bW9zdC54ICkgbGVmdG1vc3QgPSBwO1xyXG5cdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xyXG5cclxuXHRcdHJldHVybiBsZWZ0bW9zdDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXHJcblxyXG5cdGZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5ICkge1xyXG5cclxuXHRcdHJldHVybiAoIGN4IC0gcHggKSAqICggYXkgLSBweSApIC0gKCBheCAtIHB4ICkgKiAoIGN5IC0gcHkgKSA+PSAwICYmXHJcblx0XHQgKCBheCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSAtICggYnggLSBweCApICogKCBheSAtIHB5ICkgPj0gMCAmJlxyXG5cdFx0ICggYnggLSBweCApICogKCBjeSAtIHB5ICkgLSAoIGN4IC0gcHggKSAqICggYnkgLSBweSApID49IDA7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXHJcblxyXG5cdGZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbCggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICEgaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSAmJlxyXG5cdFx0XHRsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICYmIG1pZGRsZUluc2lkZSggYSwgYiApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcclxuXHJcblx0ZnVuY3Rpb24gYXJlYSggcCwgcSwgciApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxLnkgLSBwLnkgKSAqICggci54IC0gcS54ICkgLSAoIHEueCAtIHAueCApICogKCByLnkgLSBxLnkgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxyXG5cclxuXHRmdW5jdGlvbiBlcXVhbHMoIHAxLCBwMiApIHtcclxuXHJcblx0XHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJzZWN0cyggcDEsIHExLCBwMiwgcTIgKSB7XHJcblxyXG5cdFx0aWYgKCAoIGVxdWFscyggcDEsIHExICkgJiYgZXF1YWxzKCBwMiwgcTIgKSApIHx8XHJcblx0XHRcdFx0KCBlcXVhbHMoIHAxLCBxMiApICYmIGVxdWFscyggcDIsIHExICkgKSApIHJldHVybiB0cnVlO1xyXG5cclxuXHRcdHJldHVybiBhcmVhKCBwMSwgcTEsIHAyICkgPiAwICE9PSBhcmVhKCBwMSwgcTEsIHEyICkgPiAwICYmXHJcblx0XHRcdFx0XHQgYXJlYSggcDIsIHEyLCBwMSApID4gMCAhPT0gYXJlYSggcDIsIHEyLCBxMSApID4gMDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xyXG5cclxuXHRmdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgcCA9IGE7XHJcblxyXG5cdFx0ZG8ge1xyXG5cclxuXHRcdFx0aWYgKCBwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcclxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzKCBwLCBwLm5leHQsIGEsIGIgKSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdH0gd2hpbGUgKCBwICE9PSBhICk7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxyXG5cclxuXHRmdW5jdGlvbiBsb2NhbGx5SW5zaWRlKCBhLCBiICkge1xyXG5cclxuXHRcdHJldHVybiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApIDwgMCA/XHJcblx0XHRcdGFyZWEoIGEsIGIsIGEubmV4dCApID49IDAgJiYgYXJlYSggYSwgYS5wcmV2LCBiICkgPj0gMCA6XHJcblx0XHRcdGFyZWEoIGEsIGIsIGEucHJldiApIDwgMCB8fCBhcmVhKCBhLCBhLm5leHQsIGIgKSA8IDA7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXHJcblxyXG5cdGZ1bmN0aW9uIG1pZGRsZUluc2lkZSggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgcCA9IGEsXHJcblx0XHRcdGluc2lkZSA9IGZhbHNlLFxyXG5cdFx0XHRweCA9ICggYS54ICsgYi54ICkgLyAyLFxyXG5cdFx0XHRweSA9ICggYS55ICsgYi55ICkgLyAyO1xyXG5cclxuXHRcdGRvIHtcclxuXHJcblx0XHRcdGlmICggKCAoIHAueSA+IHB5ICkgIT09ICggcC5uZXh0LnkgPiBweSApICkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxyXG5cdFx0XHRcdFx0XHRcdCggcHggPCAoIHAubmV4dC54IC0gcC54ICkgKiAoIHB5IC0gcC55ICkgLyAoIHAubmV4dC55IC0gcC55ICkgKyBwLnggKSApIHtcclxuXHJcblx0XHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwID0gcC5uZXh0O1xyXG5cclxuXHRcdH0gd2hpbGUgKCBwICE9PSBhICk7XHJcblxyXG5cdFx0cmV0dXJuIGluc2lkZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBsaW5rIHR3byBwb2x5Z29uIHZlcnRpY2VzIHdpdGggYSBicmlkZ2U7IGlmIHRoZSB2ZXJ0aWNlcyBiZWxvbmcgdG8gdGhlIHNhbWUgcmluZywgaXQgc3BsaXRzIHBvbHlnb24gaW50byB0d287XHJcblx0Ly8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXHJcblxyXG5cdGZ1bmN0aW9uIHNwbGl0UG9seWdvbiggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYTIgPSBuZXcgTm9kZSggYS5pLCBhLngsIGEueSApLFxyXG5cdFx0XHRiMiA9IG5ldyBOb2RlKCBiLmksIGIueCwgYi55ICksXHJcblx0XHRcdGFuID0gYS5uZXh0LFxyXG5cdFx0XHRicCA9IGIucHJldjtcclxuXHJcblx0XHRhLm5leHQgPSBiO1xyXG5cdFx0Yi5wcmV2ID0gYTtcclxuXHJcblx0XHRhMi5uZXh0ID0gYW47XHJcblx0XHRhbi5wcmV2ID0gYTI7XHJcblxyXG5cdFx0YjIubmV4dCA9IGEyO1xyXG5cdFx0YTIucHJldiA9IGIyO1xyXG5cclxuXHRcdGJwLm5leHQgPSBiMjtcclxuXHRcdGIyLnByZXYgPSBicDtcclxuXHJcblx0XHRyZXR1cm4gYjI7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcclxuXHJcblx0ZnVuY3Rpb24gaW5zZXJ0Tm9kZSggaSwgeCwgeSwgbGFzdCApIHtcclxuXHJcblx0XHR2YXIgcCA9IG5ldyBOb2RlKCBpLCB4LCB5ICk7XHJcblxyXG5cdFx0aWYgKCAhIGxhc3QgKSB7XHJcblxyXG5cdFx0XHRwLnByZXYgPSBwO1xyXG5cdFx0XHRwLm5leHQgPSBwO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRwLm5leHQgPSBsYXN0Lm5leHQ7XHJcblx0XHRcdHAucHJldiA9IGxhc3Q7XHJcblx0XHRcdGxhc3QubmV4dC5wcmV2ID0gcDtcclxuXHRcdFx0bGFzdC5uZXh0ID0gcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHA7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSggcCApIHtcclxuXHJcblx0XHRwLm5leHQucHJldiA9IHAucHJldjtcclxuXHRcdHAucHJldi5uZXh0ID0gcC5uZXh0O1xyXG5cclxuXHRcdGlmICggcC5wcmV2WiApIHAucHJldloubmV4dFogPSBwLm5leHRaO1xyXG5cdFx0aWYgKCBwLm5leHRaICkgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gTm9kZSggaSwgeCwgeSApIHtcclxuXHJcblx0XHQvLyB2ZXJ0aWNlIGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XHJcblx0XHR0aGlzLmkgPSBpO1xyXG5cclxuXHRcdC8vIHZlcnRleCBjb29yZGluYXRlc1xyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0Ly8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xyXG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcclxuXHRcdHRoaXMubmV4dCA9IG51bGw7XHJcblxyXG5cdFx0Ly8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxyXG5cdFx0dGhpcy56ID0gbnVsbDtcclxuXHJcblx0XHQvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXHJcblx0XHR0aGlzLnByZXZaID0gbnVsbDtcclxuXHRcdHRoaXMubmV4dFogPSBudWxsO1xyXG5cclxuXHRcdC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XHJcblx0XHR0aGlzLnN0ZWluZXIgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSB7XHJcblxyXG5cdFx0dmFyIHN1bSA9IDA7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0gKSB7XHJcblxyXG5cdFx0XHRzdW0gKz0gKCBkYXRhWyBqIF0gLSBkYXRhWyBpIF0gKSAqICggZGF0YVsgaSArIDEgXSArIGRhdGFbIGogKyAxIF0gKTtcclxuXHRcdFx0aiA9IGk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqL1xyXG5cclxuXHR2YXIgU2hhcGVVdGlscyA9IHtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXHJcblxyXG5cdFx0YXJlYTogZnVuY3Rpb24gKCBjb250b3VyICkge1xyXG5cclxuXHRcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcclxuXHRcdFx0dmFyIGEgPSAwLjA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xyXG5cclxuXHRcdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGEgKiAwLjU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gU2hhcGVVdGlscy5hcmVhKCBwdHMgKSA8IDA7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0aWYgKCBsID4gMiAmJiBwb2ludHNbIGwgLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xyXG5cclxuXHRcdFx0XHRcdHBvaW50cy5wb3AoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gYWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS54ICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdmVydGljZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiB2ZXJ0aWNlcyBsaWtlIFsgeDAseTAsIHgxLHkxLCB4Mix5MiwgLi4uIF1cclxuXHRcdFx0dmFyIGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xyXG5cdFx0XHR2YXIgZmFjZXMgPSBbXTsgLy8gZmluYWwgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgbGlrZSBbIFsgYSxiLGQgXSwgWyBiLGMsZCBdIF1cclxuXHJcblx0XHRcdHJlbW92ZUR1cEVuZFB0cyggY29udG91ciApO1xyXG5cdFx0XHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcclxuXHRcdFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aG9sZUluZGljZXMucHVzaCggaG9sZUluZGV4ICk7XHJcblx0XHRcdFx0aG9sZUluZGV4ICs9IGhvbGVzWyBpIF0ubGVuZ3RoO1xyXG5cdFx0XHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0dmFyIHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSggdmVydGljZXMsIGhvbGVJbmRpY2VzICk7XHJcblxyXG5cdFx0XHQvL1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCB0cmlhbmdsZXMuc2xpY2UoIGksIGkgKyAzICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWNlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuXHQgKlxyXG5cdCAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXHJcblx0ICpcclxuXHQgKiBwYXJhbWV0ZXJzID0ge1xyXG5cdCAqXHJcblx0ICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuXHQgKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xyXG5cdCAqICBhbW91bnQ6IDxpbnQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxyXG5cdCAqXHJcblx0ICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcblx0ICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXHJcblx0ICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcclxuXHQgKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcclxuXHQgKlxyXG5cdCAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXHJcblx0ICogIGZyYW1lczogPE9iamVjdD4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xyXG5cdCAqXHJcblx0ICogIFVWR2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcblx0ICpcclxuXHQgKiB9XHJcblx0ICovXHJcblxyXG5cdC8vIEV4dHJ1ZGVHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBFeHRydWRlR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHJcblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcclxuXHRcdFx0b3B0aW9uczogb3B0aW9uc1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBvcHRpb25zICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0cnVkZUdlb21ldHJ5O1xyXG5cclxuXHQvLyBFeHRydWRlQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdFeHRydWRlQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcclxuXHJcblx0XHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XHJcblxyXG5cdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuXHRcdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXHJcblx0XHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cclxuXHRcdC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcclxuXHJcblx0XHQvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5nZXRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoIFwicG9zaXRpb25cIiApO1xyXG5cdFx0dmFyIHZlcnRpY2VzQXJyYXkgPSBwb3NpdGlvbkF0dHJpYnV0ZSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBwb3NpdGlvbkF0dHJpYnV0ZS5hcnJheSApIDogW107XHJcblxyXG5cdFx0dmFyIHV2QXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoIFwidXZcIiApO1xyXG5cdFx0dmFyIHV2QXJyYXkgPSB1dkF0dHJpYnV0ZSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCB1dkF0dHJpYnV0ZS5hcnJheSApIDogW107XHJcblxyXG5cdFx0dmFyIEluZGV4QXR0cmlidXRlID0gdGhpcy5pbmRleDtcclxuXHRcdHZhciBpbmRpY2VzQXJyYXkgPSBJbmRleEF0dHJpYnV0ZSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBJbmRleEF0dHJpYnV0ZS5hcnJheSApIDogW107XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0cG9zaXRpb246IHZlcnRpY2VzQXJyYXksXHJcblx0XHRcdHV2OiB1dkFycmF5LFxyXG5cdFx0XHRpbmRleDogaW5kaWNlc0FycmF5XHJcblx0XHR9O1xyXG5cclxuXHR9O1xyXG5cclxuXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xyXG5cclxuXHRcdHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XHJcblx0XHRvcHRpb25zLmFycmF5cyA9IHRoaXMuZ2V0QXJyYXlzKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIHMgXTtcclxuXHRcdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggb3B0aW9ucy5hcnJheXMuaW5kZXggKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggb3B0aW9ucy5hcnJheXMucG9zaXRpb24sIDMgKSApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBvcHRpb25zLmFycmF5cy51diwgMiApICk7XHJcblxyXG5cdH07XHJcblxyXG5cdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xyXG5cclxuXHRcdHZhciBhcnJheXMgPSBvcHRpb25zLmFycmF5cyA/IG9wdGlvbnMuYXJyYXlzIDogdGhpcy5nZXRBcnJheXMoKTtcclxuXHRcdHZhciB2ZXJ0aWNlc0FycmF5ID0gYXJyYXlzLnBvc2l0aW9uO1xyXG5cdFx0dmFyIGluZGljZXNBcnJheSA9IGFycmF5cy5pbmRleDtcclxuXHRcdHZhciB1dkFycmF5ID0gYXJyYXlzLnV2O1xyXG5cclxuXHRcdHZhciBwbGFjZWhvbGRlciA9IFtdO1xyXG5cclxuXHJcblx0XHR2YXIgYW1vdW50ID0gb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW1vdW50IDogMTAwO1xyXG5cclxuXHRcdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxyXG5cdFx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxyXG5cdFx0dmFyIGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XHJcblxyXG5cdFx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXHJcblxyXG5cdFx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHRcdHZhciBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlcHMgOiAxO1xyXG5cclxuXHRcdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XHJcblx0XHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxyXG5cdFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xyXG5cclxuXHRcdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblx0XHRpZiAoIGV4dHJ1ZGVQYXRoICkge1xyXG5cclxuXHRcdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcclxuXHJcblx0XHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG5cdFx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXHJcblxyXG5cdFx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXHJcblxyXG5cdFx0XHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xyXG5cclxuXHRcdFx0c3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IGV4dHJ1ZGVQYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHN0ZXBzLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XHJcblxyXG5cdFx0XHRiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxyXG5cclxuXHRcdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRiZXZlbFNlZ21lbnRzID0gMDtcclxuXHRcdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xyXG5cdFx0XHRiZXZlbFNpemUgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cclxuXHJcblx0XHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0XHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcclxuXHRcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xyXG5cclxuXHRcdHZhciByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xyXG5cclxuXHRcdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cclxuXHJcblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xyXG5cclxuXHRcdC8qIFZlcnRpY2VzICovXHJcblxyXG5cdFx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gc2NhbGVQdDIoIHB0LCB2ZWMsIHNpemUgKSB7XHJcblxyXG5cdFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmVjLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoIHNpemUgKS5hZGQoIHB0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBiLCBicywgdCwgeixcclxuXHRcdFx0dmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcclxuXHRcdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblxyXG5cdFx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRCZXZlbFZlYyggaW5QdCwgaW5QcmV2LCBpbk5leHQgKSB7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlcyBmb3IgaW5QdCB0aGUgY29ycmVzcG9uZGluZyBwb2ludCBpblB0JyBvbiBhIG5ldyBjb250b3VyXHJcblx0XHRcdC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcclxuXHRcdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXHJcblx0XHRcdC8vXHJcblx0XHRcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXHJcblx0XHRcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXHJcblxyXG5cdFx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxyXG5cclxuXHRcdFx0Ly8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxyXG5cdFx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxyXG5cclxuXHRcdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXHJcblx0XHRcdFx0dl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcclxuXHRcdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsXHJcblx0XHRcdFx0dl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcclxuXHJcblx0XHRcdHZhciB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXHJcblx0XHRcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcclxuXHJcblx0XHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXHJcblxyXG5cdFx0XHRcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcclxuXHRcdFx0XHR2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcclxuXHJcblx0XHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxyXG5cclxuXHRcdFx0XHR2YXIgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcclxuXHRcdFx0XHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcclxuXHJcblx0XHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XHJcblx0XHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XHJcblxyXG5cdFx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XHJcblxyXG5cdFx0XHRcdHZhciBzZiA9ICggKCBwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCApICogdl9uZXh0X3kgLVxyXG5cdFx0XHRcdFx0XHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cclxuXHRcdFx0XHRcdCggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcclxuXHJcblx0XHRcdFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcclxuXHJcblx0XHRcdFx0dl90cmFuc194ID0gKCBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueCApO1xyXG5cdFx0XHRcdHZfdHJhbnNfeSA9ICggcHRQcmV2U2hpZnRfeSArIHZfcHJldl95ICogc2YgLSBpblB0LnkgKTtcclxuXHJcblx0XHRcdFx0Ly8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcclxuXHRcdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXHJcblx0XHRcdFx0dmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xyXG5cdFx0XHRcdGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXHJcblxyXG5cdFx0XHRcdHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTsgLy8gYXNzdW1lczogb3Bwb3NpdGVcclxuXHRcdFx0XHRpZiAoIHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHZfbmV4dF94IDwgLSBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVwiKTtcclxuXHRcdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XHJcblx0XHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeDtcclxuXHRcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcclxuXHRcdFx0XHRcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xyXG5cdFx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XHJcblx0XHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSAvIDIgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0dmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xyXG5cclxuXHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xyXG5cdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XHJcblxyXG5cdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxyXG5cclxuXHRcdFx0Y29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sXHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcclxuXHJcblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcclxuXHRcdFx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XHJcblxyXG5cdFx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcclxuXHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cdFx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXHJcblxyXG5cdFx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cclxuXHRcdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcclxuXHRcdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XHJcblxyXG5cdFx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YnMgPSBiZXZlbFNpemU7XHJcblxyXG5cdFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XHJcblxyXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xyXG5cclxuXHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XHJcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xyXG5cclxuXHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXHJcblx0XHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXHJcblxyXG5cdFx0dmFyIHM7XHJcblxyXG5cdFx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xyXG5cdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXHJcblxyXG5cdFx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cdFx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XHJcblxyXG5cdFx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XHJcblx0XHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcclxuXHRcdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XHJcblxyXG5cdFx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50ICsgeiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZXhwYW5kIGhvbGVzXHJcblxyXG5cdFx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgKyB6ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyogRmFjZXMgKi9cclxuXHJcblx0XHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdGJ1aWxkTGlkRmFjZXMoKTtcclxuXHJcblx0XHQvLyBTaWRlcyBmYWNlc1xyXG5cclxuXHRcdGJ1aWxkU2lkZUZhY2VzKCk7XHJcblxyXG5cclxuXHRcdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcclxuXHJcblx0XHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xyXG5cclxuXHRcdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxyXG5cdFx0XHRcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0XHRmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHRcdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHRcdC8vIFRvcCBmYWNlc1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0XHRmMyggZmFjZVsgMCBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDIgXSArIG9mZnNldCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBCb3R0b20gZmFjZXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBUb3AgZmFjZXNcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgb3B0aW9ucy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXRlcmlhbCA6IDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcclxuXHJcblx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcclxuXHRcdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xyXG5cdFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcclxuXHJcblx0XHRcdFx0Ly8sIHRydWVcclxuXHRcdFx0XHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgb3B0aW9ucy5leHRydWRlTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cnVkZU1hdGVyaWFsIDogMSApO1xyXG5cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcclxuXHJcblx0XHRcdHZhciBqLCBrO1xyXG5cdFx0XHRpID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0aiA9IGk7XHJcblx0XHRcdFx0ayA9IGkgLSAxO1xyXG5cdFx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcclxuXHJcblx0XHRcdFx0dmFyIHMgPSAwLFxyXG5cdFx0XHRcdFx0c2wgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzbGVuMSA9IHZsZW4gKiBzO1xyXG5cdFx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4xLFxyXG5cdFx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXHJcblx0XHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcclxuXHRcdFx0XHRcdFx0ZCA9IGxheWVyb2Zmc2V0ICsgaiArIHNsZW4yO1xyXG5cclxuXHRcdFx0XHRcdGY0KCBhLCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHggKTtcclxuXHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeSApO1xyXG5cdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcclxuXHJcblx0XHRcdGFkZFZlcnRleCggYSApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBjICk7XHJcblxyXG5cdFx0XHR2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xyXG5cdFx0XHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcclxuXHJcblx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xyXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xyXG5cclxuXHRcdFx0YWRkVmVydGV4KCBhICk7XHJcblx0XHRcdGFkZFZlcnRleCggYiApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcclxuXHJcblx0XHRcdGFkZFZlcnRleCggYiApO1xyXG5cdFx0XHRhZGRWZXJ0ZXgoIGMgKTtcclxuXHRcdFx0YWRkVmVydGV4KCBkICk7XHJcblxyXG5cclxuXHRcdFx0dmFyIG5leHRJbmRleCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcclxuXHRcdFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDYsIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcclxuXHJcblx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xyXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMyBdICk7XHJcblxyXG5cdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcclxuXHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XHJcblx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0aW5kaWNlc0FycmF5LnB1c2goIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyApO1xyXG5cdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAwIF0gKTtcclxuXHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMSBdICk7XHJcblx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDIgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkVVYoIHZlY3RvcjIgKSB7XHJcblxyXG5cdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueCApO1xyXG5cdFx0XHR1dkFycmF5LnB1c2goIHZlY3RvcjIueSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICEgb3B0aW9ucy5hcnJheXMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzQXJyYXkgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlc0FycmF5LCAzICkgKTtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xyXG5cclxuXHRcdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuXHRcdFx0dmFyIGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XHJcblx0XHRcdHZhciBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcclxuXHRcdFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XHJcblx0XHRcdHZhciBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcclxuXHRcdFx0dmFyIGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XHJcblx0XHRcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgYV95ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeCwgYl95ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeCwgY195IClcclxuXHRcdFx0XTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcclxuXHJcblx0XHRcdHZhciBhX3ggPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyBdO1xyXG5cdFx0XHR2YXIgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XHJcblx0XHRcdHZhciBhX3ogPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDIgXTtcclxuXHRcdFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XHJcblx0XHRcdHZhciBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcclxuXHRcdFx0dmFyIGJfeiA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMiBdO1xyXG5cdFx0XHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcclxuXHRcdFx0dmFyIGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xyXG5cdFx0XHR2YXIgY196ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAyIF07XHJcblx0XHRcdHZhciBkX3ggPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyBdO1xyXG5cdFx0XHR2YXIgZF95ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAxIF07XHJcblx0XHRcdHZhciBkX3ogPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDIgXTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIGFfeSAtIGJfeSApIDwgMC4wMSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBhX3gsIDEgLSBhX3ogKSxcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBiX3gsIDEgLSBiX3ogKSxcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIDEgLSBjX3ogKSxcclxuXHRcdFx0XHRcdG5ldyBWZWN0b3IyKCBkX3gsIDEgLSBkX3ogKVxyXG5cdFx0XHRcdF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeSwgMSAtIGFfeiApLFxyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoIGJfeSwgMSAtIGJfeiApLFxyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoIGNfeSwgMSAtIGNfeiApLFxyXG5cdFx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeSwgMSAtIGRfeiApXHJcblx0XHRcdFx0XTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICpcclxuXHQgKiBUZXh0ID0gM0QgVGV4dFxyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKiAgZm9udDogPFRIUkVFLkZvbnQ+LCAvLyBmb250XHJcblx0ICpcclxuXHQgKiAgc2l6ZTogPGZsb2F0PiwgLy8gc2l6ZSBvZiB0aGUgdGV4dFxyXG5cdCAqICBoZWlnaHQ6IDxmbG9hdD4sIC8vIHRoaWNrbmVzcyB0byBleHRydWRlIHRleHRcclxuXHQgKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xyXG5cdCAqXHJcblx0ICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXHJcblx0ICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRleHQgYmV2ZWwgZ29lc1xyXG5cdCAqICBiZXZlbFNpemU6IDxmbG9hdD4gLy8gaG93IGZhciBmcm9tIHRleHQgb3V0bGluZSBpcyBiZXZlbFxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHJcblx0Ly8gVGV4dEdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFRleHRHZW9tZXRyeSggdGV4dCwgcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1RleHRHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHR0ZXh0OiB0ZXh0LFxyXG5cdFx0XHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVGV4dEJ1ZmZlckdlb21ldHJ5KCB0ZXh0LCBwYXJhbWV0ZXJzICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdFRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRUZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEdlb21ldHJ5O1xyXG5cclxuXHQvLyBUZXh0QnVmZmVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gVGV4dEJ1ZmZlckdlb21ldHJ5KCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xyXG5cclxuXHRcdHZhciBmb250ID0gcGFyYW1ldGVycy5mb250O1xyXG5cclxuXHRcdGlmICggISAoIGZvbnQgJiYgZm9udC5pc0ZvbnQgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UZXh0R2VvbWV0cnk6IGZvbnQgcGFyYW1ldGVyIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5Gb250LicgKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2hhcGVzID0gZm9udC5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycy5zaXplLCBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0XHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXHJcblxyXG5cdFx0cGFyYW1ldGVycy5hbW91bnQgPSBwYXJhbWV0ZXJzLmhlaWdodCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5oZWlnaHQgOiA1MDtcclxuXHJcblx0XHQvLyBkZWZhdWx0c1xyXG5cclxuXHRcdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcclxuXHJcblx0XHRFeHRydWRlQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgc2hhcGVzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1RleHRCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdH1cclxuXHJcblx0VGV4dEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRUZXh0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICovXHJcblxyXG5cdC8vIFNwaGVyZUdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFNwaGVyZUdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcclxuXHJcblx0XHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1czogcmFkaXVzLFxyXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXHJcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXHJcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmVHZW9tZXRyeTtcclxuXHJcblx0Ly8gU3BoZXJlQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU3BoZXJlQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXHJcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxyXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cclxuXHRcdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcclxuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xyXG5cclxuXHRcdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcclxuXHRcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG5cdFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xyXG5cclxuXHRcdHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcclxuXHJcblx0XHR2YXIgaXgsIGl5O1xyXG5cclxuXHRcdHZhciBpbmRleCA9IDA7XHJcblx0XHR2YXIgZ3JpZCA9IFtdO1xyXG5cclxuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gYnVmZmVyc1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gW107XHJcblx0XHR2YXIgdmVydGljZXMgPSBbXTtcclxuXHRcdHZhciBub3JtYWxzID0gW107XHJcblx0XHR2YXIgdXZzID0gW107XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xyXG5cclxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XHJcblxyXG5cdFx0XHR2YXIgdiA9IGl5IC8gaGVpZ2h0U2VnbWVudHM7XHJcblxyXG5cdFx0XHRmb3IgKCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdSA9IGl4IC8gd2lkdGhTZWdtZW50cztcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdG5vcm1hbC5zZXQoIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdFx0Ly8gdXZcclxuXHJcblx0XHRcdFx0dXZzLnB1c2goIHUsIDEgLSB2ICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRncmlkLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xyXG5cdFx0XHRcdHZhciBiID0gZ3JpZFsgaXkgXVsgaXggXTtcclxuXHRcdFx0XHR2YXIgYyA9IGdyaWRbIGl5ICsgMSBdWyBpeCBdO1xyXG5cdFx0XHRcdHZhciBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGl5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XHJcblxyXG5cdH1cclxuXHJcblx0U3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0U3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgS2FsZWIgTXVycGh5XHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0Ly8gUmluZ0dlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFJpbmdHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG5cdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcblx0XHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXHJcblx0XHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUmluZ0J1ZmZlckdlb21ldHJ5KCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRSaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0UmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdHZW9tZXRyeTtcclxuXHJcblx0Ly8gUmluZ0J1ZmZlckdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIFJpbmdCdWZmZXJHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdSaW5nQnVmZmVyR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxyXG5cdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXHJcblx0XHRcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXHJcblx0XHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMC41O1xyXG5cdFx0b3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCAxO1xyXG5cclxuXHRcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcclxuXHRcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0dGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xyXG5cdFx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiAxO1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xyXG5cdFx0dmFyIHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xyXG5cclxuXHRcdHZhciBzZWdtZW50O1xyXG5cdFx0dmFyIHJhZGl1cyA9IGlubmVyUmFkaXVzO1xyXG5cdFx0dmFyIHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcclxuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdHZhciBqLCBpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaiArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHZhbHVlcyBhcmUgZ2VuZXJhdGUgZnJvbSB0aGUgaW5zaWRlIG9mIHRoZSByaW5nIHRvIHRoZSBvdXRzaWRlXHJcblxyXG5cdFx0XHRcdHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcclxuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xyXG5cclxuXHRcdFx0XHQvLyB1dlxyXG5cclxuXHRcdFx0XHR1di54ID0gKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcclxuXHRcdFx0XHR1di55ID0gKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcclxuXHJcblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGluY3JlYXNlIHRoZSByYWRpdXMgZm9yIG5leHQgcm93IG9mIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdGZvciAoIGogPSAwOyBqIDwgcGhpU2VnbWVudHM7IGogKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGhldGFTZWdtZW50TGV2ZWwgPSBqICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRzZWdtZW50ID0gaSArIHRoZXRhU2VnbWVudExldmVsO1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IHNlZ21lbnQ7XHJcblx0XHRcdFx0dmFyIGIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XHJcblx0XHRcdFx0dmFyIGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XHJcblx0XHRcdFx0dmFyIGQgPSBzZWdtZW50ICsgMTtcclxuXHJcblx0XHRcdFx0Ly8gZmFjZXNcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRSaW5nQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0UmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cclxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqL1xyXG5cclxuXHQvLyBMYXRoZUdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIExhdGhlR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHBvaW50czogcG9pbnRzLFxyXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXHJcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdExhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0TGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXRoZUdlb21ldHJ5O1xyXG5cclxuXHQvLyBMYXRoZUJ1ZmZlckdlb21ldHJ5XHJcblxyXG5cdGZ1bmN0aW9uIExhdGhlQnVmZmVyR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMYXRoZUJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHBvaW50czogcG9pbnRzLFxyXG5cdFx0XHRzZWdtZW50czogc2VnbWVudHMsXHJcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcclxuXHRcdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0c2VnbWVudHMgPSBNYXRoLmZsb29yKCBzZWdtZW50cyApIHx8IDEyO1xyXG5cdFx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xyXG5cdFx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cclxuXHJcblx0XHRwaGlMZW5ndGggPSBfTWF0aC5jbGFtcCggcGhpTGVuZ3RoLCAwLCBNYXRoLlBJICogMiApO1xyXG5cclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHR2YXIgYmFzZTtcclxuXHRcdHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcclxuXHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcclxuXHRcdHZhciBpLCBqO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzIGFuZCB1dnNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XHJcblxyXG5cdFx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHBoaSApO1xyXG5cdFx0XHR2YXIgY29zID0gTWF0aC5jb3MoIHBoaSApO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDA7IGogPD0gKCBwb2ludHMubGVuZ3RoIC0gMSApOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHQvLyB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0dmVydGV4LnggPSBwb2ludHNbIGogXS54ICogc2luO1xyXG5cdFx0XHRcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcclxuXHRcdFx0XHR2ZXJ0ZXgueiA9IHBvaW50c1sgaiBdLnggKiBjb3M7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0Ly8gdXZcclxuXHJcblx0XHRcdFx0dXYueCA9IGkgLyBzZWdtZW50cztcclxuXHRcdFx0XHR1di55ID0gaiAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcclxuXHJcblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcclxuXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDA7IGogPCAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdGJhc2UgPSBqICsgaSAqIHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHZhciBhID0gYmFzZTtcclxuXHRcdFx0XHR2YXIgYiA9IGJhc2UgKyBwb2ludHMubGVuZ3RoO1xyXG5cdFx0XHRcdHZhciBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xyXG5cdFx0XHRcdHZhciBkID0gYmFzZSArIDE7XHJcblxyXG5cdFx0XHRcdC8vIGZhY2VzXHJcblxyXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xyXG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIG5vcm1hbHNcclxuXHJcblx0XHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XHJcblxyXG5cdFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgd2UgbmVlZCB0byBhdmVyYWdlIHRoZSBub3JtYWxzIGFsb25nIHRoZSBzZWFtLlxyXG5cdFx0Ly8gYmVjYXVzZSB0aGUgY29ycmVzcG9uZGluZyB2ZXJ0aWNlcyBhcmUgaWRlbnRpY2FsIChidXQgc3RpbGwgaGF2ZSBkaWZmZXJlbnQgVVZzKS5cclxuXHJcblx0XHRpZiAoIHBoaUxlbmd0aCA9PT0gTWF0aC5QSSAqIDIgKSB7XHJcblxyXG5cdFx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XHJcblx0XHRcdHZhciBuMSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBuMiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBuID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdC8vIHRoaXMgaXMgdGhlIGJ1ZmZlciBvZmZzZXQgZm9yIHRoZSBsYXN0IGxpbmUgb2YgdmVydGljZXNcclxuXHJcblx0XHRcdGJhc2UgPSBzZWdtZW50cyAqIHBvaW50cy5sZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGogPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKywgaiArPSAzICkge1xyXG5cclxuXHRcdFx0XHQvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBmaXJzdCBsaW5lXHJcblxyXG5cdFx0XHRcdG4xLnggPSBub3JtYWxzWyBqICsgMCBdO1xyXG5cdFx0XHRcdG4xLnkgPSBub3JtYWxzWyBqICsgMSBdO1xyXG5cdFx0XHRcdG4xLnogPSBub3JtYWxzWyBqICsgMiBdO1xyXG5cclxuXHRcdFx0XHQvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBsYXN0IGxpbmVcclxuXHJcblx0XHRcdFx0bjIueCA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMCBdO1xyXG5cdFx0XHRcdG4yLnkgPSBub3JtYWxzWyBiYXNlICsgaiArIDEgXTtcclxuXHRcdFx0XHRuMi56ID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF07XHJcblxyXG5cdFx0XHRcdC8vIGF2ZXJhZ2Ugbm9ybWFsc1xyXG5cclxuXHRcdFx0XHRuLmFkZFZlY3RvcnMoIG4xLCBuMiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXHJcblxyXG5cdFx0XHRcdG5vcm1hbHNbIGogKyAwIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDAgXSA9IG4ueDtcclxuXHRcdFx0XHRub3JtYWxzWyBqICsgMSBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAxIF0gPSBuLnk7XHJcblx0XHRcdFx0bm9ybWFsc1sgaiArIDIgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMiBdID0gbi56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdExhdGhlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF0aGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0Ly8gU2hhcGVHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBTaGFwZUdlb21ldHJ5KCBzaGFwZXMsIGN1cnZlU2VnbWVudHMgKSB7XHJcblxyXG5cdFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBjdXJ2ZVNlZ21lbnRzID09PSAnb2JqZWN0JyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlR2VvbWV0cnk6IE9wdGlvbnMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdFx0Y3VydmVTZWdtZW50cyA9IGN1cnZlU2VnbWVudHMuY3VydmVTZWdtZW50cztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcclxuXHRcdFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNoYXBlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgY3VydmVTZWdtZW50cyApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRTaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVHZW9tZXRyeTtcclxuXHJcblx0U2hhcGVHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XHJcblxyXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFNoYXBlQnVmZmVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gU2hhcGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBjdXJ2ZVNlZ21lbnRzICkge1xyXG5cclxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU2hhcGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRzaGFwZXM6IHNoYXBlcyxcclxuXHRcdFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xyXG5cdFx0fTtcclxuXHJcblx0XHRjdXJ2ZVNlZ21lbnRzID0gY3VydmVTZWdtZW50cyB8fCAxMjtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHJcblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXHJcblxyXG5cdFx0dmFyIGdyb3VwU3RhcnQgPSAwO1xyXG5cdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xyXG5cclxuXHRcdC8vIGFsbG93IHNpbmdsZSBhbmQgYXJyYXkgdmFsdWVzIGZvciBcInNoYXBlc1wiIHBhcmFtZXRlclxyXG5cclxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0YWRkU2hhcGUoIHNoYXBlcyApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRhZGRTaGFwZSggc2hhcGVzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgaSApOyAvLyBlbmFibGVzIE11bHRpTWF0ZXJpYWwgc3VwcG9ydFxyXG5cclxuXHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XHJcblx0XHRcdFx0Z3JvdXBDb3VudCA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblxyXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZFNoYXBlKCBzaGFwZSApIHtcclxuXHJcblx0XHRcdHZhciBpLCBsLCBzaGFwZUhvbGU7XHJcblxyXG5cdFx0XHR2YXIgaW5kZXhPZmZzZXQgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xyXG5cdFx0XHR2YXIgcG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XHJcblx0XHRcdHZhciBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlVmVydGljZXMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdFx0Ly8gYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRzaGFwZUhvbGUgPSBzaGFwZUhvbGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBzaGFwZUhvbGUgKSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNoYXBlSG9sZXNbIGkgXSA9IHNoYXBlSG9sZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHNoYXBlVmVydGljZXMsIHNoYXBlSG9sZXMgKTtcclxuXHJcblx0XHRcdC8vIGpvaW4gdmVydGljZXMgb2YgaW5uZXIgYW5kIG91dGVyIHBhdGhzIHRvIGEgc2luZ2xlIGFycmF5XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0c2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xyXG5cdFx0XHRcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLmNvbmNhdCggc2hhcGVIb2xlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB2ZXJ0aWNlcywgbm9ybWFscywgdXZzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleCA9IHNoYXBlVmVydGljZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCAwICk7XHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XHJcblx0XHRcdFx0dXZzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSApOyAvLyB3b3JsZCB1dnNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGluY2lkZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGZhY2VbIDAgXSArIGluZGV4T2Zmc2V0O1xyXG5cdFx0XHRcdHZhciBiID0gZmFjZVsgMSBdICsgaW5kZXhPZmZzZXQ7XHJcblx0XHRcdFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBpbmRleE9mZnNldDtcclxuXHJcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XHJcblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRTaGFwZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdFNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0U2hhcGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XHJcblxyXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIHRvSlNPTiggc2hhcGVzLCBkYXRhICkge1xyXG5cclxuXHRcdGRhdGEuc2hhcGVzID0gW107XHJcblxyXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBFZGdlc0dlb21ldHJ5KCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdFZGdlc0dlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxyXG5cdFx0fTtcclxuXHJcblx0XHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xyXG5cclxuXHRcdC8vIGJ1ZmZlclxyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHR2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIF9NYXRoLkRFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSApO1xyXG5cdFx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgZWRnZXMgPSB7fSwgZWRnZTEsIGVkZ2UyO1xyXG5cdFx0dmFyIGtleSwga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xyXG5cclxuXHRcdC8vIHByZXBhcmUgc291cmNlIGdlb21ldHJ5XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5MjtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeTIgPSBuZXcgR2VvbWV0cnkoKTtcclxuXHRcdFx0Z2VvbWV0cnkyLmZyb21CdWZmZXJHZW9tZXRyeSggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkuY2xvbmUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcclxuXHRcdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHJcblx0XHR2YXIgc291cmNlVmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XHJcblxyXG5cdFx0Ly8gbm93IGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHdoZXJlIGVhY2ggZW50cnkgcmVwcmVzZW50cyBhbiBlZGdlIHdpdGggaXRzIGFkam9pbmluZyBmYWNlc1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRlZGdlMSA9IGZhY2VbIGtleXNbIGogXSBdO1xyXG5cdFx0XHRcdGVkZ2UyID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XHJcblx0XHRcdFx0ZWRnZVsgMCBdID0gTWF0aC5taW4oIGVkZ2UxLCBlZGdlMiApO1xyXG5cdFx0XHRcdGVkZ2VbIDEgXSA9IE1hdGgubWF4KCBlZGdlMSwgZWRnZTIgKTtcclxuXHJcblx0XHRcdFx0a2V5ID0gZWRnZVsgMCBdICsgJywnICsgZWRnZVsgMSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGVkZ2VzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGVkZ2VzWyBrZXkgXS5mYWNlMiA9IGk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXNcclxuXHJcblx0XHRmb3IgKCBrZXkgaW4gZWRnZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgZSA9IGVkZ2VzWyBrZXkgXTtcclxuXHJcblx0XHRcdC8vIGFuIGVkZ2UgaXMgb25seSByZW5kZXJlZCBpZiB0aGUgYW5nbGUgKGluIGRlZ3JlZXMpIGJldHdlZW4gdGhlIGZhY2Ugbm9ybWFscyBvZiB0aGUgYWRqb2luaW5nIGZhY2VzIGV4Y2VlZHMgdGhpcyB2YWx1ZS4gZGVmYXVsdCA9IDEgZGVncmVlLlxyXG5cclxuXHRcdFx0aWYgKCBlLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGUuZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgZS5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHZlcnRleCA9IHNvdXJjZVZlcnRpY2VzWyBlLmluZGV4MSBdO1xyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0dmVydGV4ID0gc291cmNlVmVydGljZXNbIGUuaW5kZXgyIF07XHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBidWlsZCBnZW9tZXRyeVxyXG5cclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0RWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGdlc0dlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICovXHJcblxyXG5cdC8vIEN5bGluZGVyR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gQ3lsaW5kZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXNUb3A6IHJhZGl1c1RvcCxcclxuXHRcdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXHJcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxyXG5cdFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXHJcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXHJcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XHJcblx0XHR0aGlzLm1lcmdlVmVydGljZXMoKTtcclxuXHJcblx0fVxyXG5cclxuXHRDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3lsaW5kZXJHZW9tZXRyeTtcclxuXHJcblx0Ly8gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDeWxpbmRlckJ1ZmZlckdlb21ldHJ5JztcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XHJcblx0XHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxyXG5cdFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcclxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0cmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAxO1xyXG5cdFx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAxO1xyXG5cdFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XHJcblxyXG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XHJcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcclxuXHJcblx0XHRvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xyXG5cdFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwLjA7XHJcblx0XHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHRcdC8vIGJ1ZmZlcnNcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xyXG5cdFx0dmFyIHV2cyA9IFtdO1xyXG5cclxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcclxuXHJcblx0XHR2YXIgaW5kZXggPSAwO1xyXG5cdFx0dmFyIGluZGV4QXJyYXkgPSBbXTtcclxuXHRcdHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcclxuXHRcdHZhciBncm91cFN0YXJ0ID0gMDtcclxuXHJcblx0XHQvLyBnZW5lcmF0ZSBnZW9tZXRyeVxyXG5cclxuXHRcdGdlbmVyYXRlVG9yc28oKTtcclxuXHJcblx0XHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHJhZGl1c1RvcCA+IDAgKSBnZW5lcmF0ZUNhcCggdHJ1ZSApO1xyXG5cdFx0XHRpZiAoIHJhZGl1c0JvdHRvbSA+IDAgKSBnZW5lcmF0ZUNhcCggZmFsc2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcclxuXHJcblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XHJcblxyXG5cdFx0XHR2YXIgeCwgeTtcclxuXHRcdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xyXG5cclxuXHRcdFx0Ly8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWxcclxuXHRcdFx0dmFyIHNsb3BlID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuXHJcblx0XHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRcdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgaW5kZXhSb3cgPSBbXTtcclxuXHJcblx0XHRcdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XHJcblxyXG5cdFx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzIG9mIHRoZSBjdXJyZW50IHJvd1xyXG5cclxuXHRcdFx0XHR2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XHJcblxyXG5cdFx0XHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0XHRcdHZhciB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblx0XHRcdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcclxuXHJcblx0XHRcdFx0XHQvLyB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xyXG5cdFx0XHRcdFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoYWxmSGVpZ2h0O1xyXG5cdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0XHQvLyBub3JtYWxcclxuXHJcblx0XHRcdFx0XHRub3JtYWwuc2V0KCBzaW5UaGV0YSwgc2xvcGUsIGNvc1RoZXRhICkubm9ybWFsaXplKCk7XHJcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcclxuXHJcblx0XHRcdFx0XHQvLyB1dlxyXG5cclxuXHRcdFx0XHRcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xyXG5cclxuXHRcdFx0XHRcdC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XHJcblxyXG5cdFx0XHRcdFx0aW5kZXhSb3cucHVzaCggaW5kZXggKysgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxyXG5cclxuXHRcdFx0XHRpbmRleEFycmF5LnB1c2goIGluZGV4Um93ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXHJcblxyXG5cdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHdlIHVzZSB0aGUgaW5kZXggYXJyYXkgdG8gYWNjZXNzIHRoZSBjb3JyZWN0IGluZGljZXNcclxuXHJcblx0XHRcdFx0XHR2YXIgYSA9IGluZGV4QXJyYXlbIHkgXVsgeCBdO1xyXG5cdFx0XHRcdFx0dmFyIGIgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4IF07XHJcblx0XHRcdFx0XHR2YXIgYyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XHJcblx0XHRcdFx0XHR2YXIgZCA9IGluZGV4QXJyYXlbIHkgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdFx0XHQvLyBmYWNlc1xyXG5cclxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xyXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGdyb3VwIGNvdW50ZXJcclxuXHJcblx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XHJcblxyXG5cdFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgMCApO1xyXG5cclxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXHJcblxyXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKCB0b3AgKSB7XHJcblxyXG5cdFx0XHR2YXIgeCwgY2VudGVySW5kZXhTdGFydCwgY2VudGVySW5kZXhFbmQ7XHJcblxyXG5cdFx0XHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciBncm91cENvdW50ID0gMDtcclxuXHJcblx0XHRcdHZhciByYWRpdXMgPSAoIHRvcCA9PT0gdHJ1ZSApID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xyXG5cdFx0XHR2YXIgc2lnbiA9ICggdG9wID09PSB0cnVlICkgPyAxIDogLSAxO1xyXG5cclxuXHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcclxuXHRcdFx0Y2VudGVySW5kZXhTdGFydCA9IGluZGV4O1xyXG5cclxuXHRcdFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxyXG5cdFx0XHQvLyBiZWNhdXNlIHRoZSBnZW9tZXRyeSBuZWVkcyBvbmUgc2V0IG9mIHV2cyBwZXIgZmFjZSxcclxuXHRcdFx0Ly8gd2UgbXVzdCBnZW5lcmF0ZSBhIGNlbnRlciB2ZXJ0ZXggcGVyIGZhY2Uvc2VnbWVudFxyXG5cclxuXHRcdFx0Zm9yICggeCA9IDE7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRleFxyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCApO1xyXG5cclxuXHRcdFx0XHQvLyBub3JtYWxcclxuXHJcblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XHJcblxyXG5cdFx0XHRcdC8vIHV2XHJcblxyXG5cdFx0XHRcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xyXG5cclxuXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxyXG5cclxuXHRcdFx0XHRpbmRleCArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcclxuXHJcblx0XHRcdGNlbnRlckluZGV4RW5kID0gaW5kZXg7XHJcblxyXG5cdFx0XHQvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcclxuXHJcblx0XHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcclxuXHRcdFx0XHR2YXIgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xyXG5cclxuXHRcdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcclxuXHRcdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XHJcblx0XHRcdFx0dmVydGV4LnkgPSBoYWxmSGVpZ2h0ICogc2lnbjtcclxuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsXHJcblxyXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xyXG5cclxuXHRcdFx0XHQvLyB1dlxyXG5cclxuXHRcdFx0XHR1di54ID0gKCBjb3NUaGV0YSAqIDAuNSApICsgMC41O1xyXG5cdFx0XHRcdHV2LnkgPSAoIHNpblRoZXRhICogMC41ICogc2lnbiApICsgMC41O1xyXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XHJcblxyXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XHJcblxyXG5cdFx0XHRcdGluZGV4ICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xyXG5cclxuXHRcdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcclxuXHRcdFx0XHR2YXIgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcclxuXHJcblx0XHRcdFx0aWYgKCB0b3AgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmFjZSB0b3BcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCBjICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmFjZSBib3R0b21cclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGkgKyAxLCBpLCBjICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcclxuXHJcblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMiApO1xyXG5cclxuXHRcdFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXHJcblxyXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdEN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXHJcblx0ICovXHJcblxyXG5cdC8vIENvbmVHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBDb25lR2VvbWV0cnkoIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFx0Q3lsaW5kZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdENvbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdENvbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lR2VvbWV0cnk7XHJcblxyXG5cdC8vIENvbmVCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBDb25lQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0NvbmVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXHJcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdENvbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdENvbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lQnVmZmVyR2VvbWV0cnk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICogQGF1dGhvciBodWdoZXNcclxuXHQgKi9cclxuXHJcblx0Ly8gQ2lyY2xlR2VvbWV0cnlcclxuXHJcblx0ZnVuY3Rpb24gQ2lyY2xlR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xyXG5cclxuXHRcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xyXG5cclxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcclxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXHJcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcclxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcclxuXHRcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQ2lyY2xlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcclxuXHRcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdENpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cdENpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZUdlb21ldHJ5O1xyXG5cclxuXHQvLyBDaXJjbGVCdWZmZXJHZW9tZXRyeVxyXG5cclxuXHRmdW5jdGlvbiBDaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XHJcblxyXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xyXG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcclxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxyXG5cdFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxyXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcclxuXHRcdH07XHJcblxyXG5cdFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblx0XHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XHJcblxyXG5cdFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xyXG5cdFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBbXTtcclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdHZhciB1dnMgPSBbXTtcclxuXHJcblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXHJcblxyXG5cdFx0dmFyIGksIHM7XHJcblx0XHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0Ly8gY2VudGVyIHBvaW50XHJcblxyXG5cdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xyXG5cdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XHJcblx0XHR1dnMucHVzaCggMC41LCAwLjUgKTtcclxuXHJcblx0XHRmb3IgKCBzID0gMCwgaSA9IDM7IHMgPD0gc2VnbWVudHM7IHMgKyssIGkgKz0gMyApIHtcclxuXHJcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xyXG5cclxuXHRcdFx0Ly8gdmVydGV4XHJcblxyXG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XHJcblx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcclxuXHJcblx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcclxuXHJcblx0XHRcdC8vIG5vcm1hbFxyXG5cclxuXHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XHJcblxyXG5cdFx0XHQvLyB1dnNcclxuXHJcblx0XHRcdHV2LnggPSAoIHZlcnRpY2VzWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xyXG5cdFx0XHR1di55ID0gKCB2ZXJ0aWNlc1sgaSArIDEgXSAvIHJhZGl1cyArIDEgKSAvIDI7XHJcblxyXG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpbmRpY2VzXHJcblxyXG5cdFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xyXG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XHJcblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcclxuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRDaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHRDaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGVCdWZmZXJHZW9tZXRyeTtcclxuXHJcblxyXG5cclxuXHR2YXIgR2VvbWV0cmllcyA9IE9iamVjdC5mcmVlemUoe1xyXG5cdFx0V2lyZWZyYW1lR2VvbWV0cnk6IFdpcmVmcmFtZUdlb21ldHJ5LFxyXG5cdFx0UGFyYW1ldHJpY0dlb21ldHJ5OiBQYXJhbWV0cmljR2VvbWV0cnksXHJcblx0XHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk6IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSxcclxuXHRcdFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXHJcblx0XHRUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxyXG5cdFx0T2N0YWhlZHJvbkdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXHJcblx0XHRPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSxcclxuXHRcdEljb3NhaGVkcm9uR2VvbWV0cnk6IEljb3NhaGVkcm9uR2VvbWV0cnksXHJcblx0XHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxyXG5cdFx0RG9kZWNhaGVkcm9uR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxyXG5cdFx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxyXG5cdFx0UG9seWhlZHJvbkdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXHJcblx0XHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnk6IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSxcclxuXHRcdFR1YmVHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxyXG5cdFx0VHViZUJ1ZmZlckdlb21ldHJ5OiBUdWJlQnVmZmVyR2VvbWV0cnksXHJcblx0XHRUb3J1c0tub3RHZW9tZXRyeTogVG9ydXNLbm90R2VvbWV0cnksXHJcblx0XHRUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTogVG9ydXNLbm90QnVmZmVyR2VvbWV0cnksXHJcblx0XHRUb3J1c0dlb21ldHJ5OiBUb3J1c0dlb21ldHJ5LFxyXG5cdFx0VG9ydXNCdWZmZXJHZW9tZXRyeTogVG9ydXNCdWZmZXJHZW9tZXRyeSxcclxuXHRcdFRleHRHZW9tZXRyeTogVGV4dEdlb21ldHJ5LFxyXG5cdFx0VGV4dEJ1ZmZlckdlb21ldHJ5OiBUZXh0QnVmZmVyR2VvbWV0cnksXHJcblx0XHRTcGhlcmVHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXHJcblx0XHRTcGhlcmVCdWZmZXJHZW9tZXRyeTogU3BoZXJlQnVmZmVyR2VvbWV0cnksXHJcblx0XHRSaW5nR2VvbWV0cnk6IFJpbmdHZW9tZXRyeSxcclxuXHRcdFJpbmdCdWZmZXJHZW9tZXRyeTogUmluZ0J1ZmZlckdlb21ldHJ5LFxyXG5cdFx0UGxhbmVHZW9tZXRyeTogUGxhbmVHZW9tZXRyeSxcclxuXHRcdFBsYW5lQnVmZmVyR2VvbWV0cnk6IFBsYW5lQnVmZmVyR2VvbWV0cnksXHJcblx0XHRMYXRoZUdlb21ldHJ5OiBMYXRoZUdlb21ldHJ5LFxyXG5cdFx0TGF0aGVCdWZmZXJHZW9tZXRyeTogTGF0aGVCdWZmZXJHZW9tZXRyeSxcclxuXHRcdFNoYXBlR2VvbWV0cnk6IFNoYXBlR2VvbWV0cnksXHJcblx0XHRTaGFwZUJ1ZmZlckdlb21ldHJ5OiBTaGFwZUJ1ZmZlckdlb21ldHJ5LFxyXG5cdFx0RXh0cnVkZUdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXHJcblx0XHRFeHRydWRlQnVmZmVyR2VvbWV0cnk6IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSxcclxuXHRcdEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXHJcblx0XHRDb25lR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcclxuXHRcdENvbmVCdWZmZXJHZW9tZXRyeTogQ29uZUJ1ZmZlckdlb21ldHJ5LFxyXG5cdFx0Q3lsaW5kZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcclxuXHRcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnk6IEN5bGluZGVyQnVmZmVyR2VvbWV0cnksXHJcblx0XHRDaXJjbGVHZW9tZXRyeTogQ2lyY2xlR2VvbWV0cnksXHJcblx0XHRDaXJjbGVCdWZmZXJHZW9tZXRyeTogQ2lyY2xlQnVmZmVyR2VvbWV0cnksXHJcblx0XHRCb3hHZW9tZXRyeTogQm94R2VvbWV0cnksXHJcblx0XHRCb3hCdWZmZXJHZW9tZXRyeTogQm94QnVmZmVyR2VvbWV0cnlcclxuXHR9KTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKlxyXG5cdCAqIHBhcmFtZXRlcnMgPSB7XHJcblx0ICogIGNvbG9yOiA8VEhSRUUuQ29sb3I+LFxyXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBTaGFkb3dNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1NoYWRvd01hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xyXG5cdFx0dGhpcy5vcGFjaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMubGlnaHRzID0gdHJ1ZTtcclxuXHRcdHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZG93TWF0ZXJpYWw7XHJcblxyXG5cdFNoYWRvd01hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRvd01hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gUmF3U2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0U2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XHJcblxyXG5cdH1cclxuXHJcblx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF3U2hhZGVyTWF0ZXJpYWw7XHJcblxyXG5cdFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5pc1Jhd1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICpcclxuXHQgKiBwYXJhbWV0ZXJzID0ge1xyXG5cdCAqICBjb2xvcjogPGhleD4sXHJcblx0ICogIHJvdWdobmVzczogPGZsb2F0PixcclxuXHQgKiAgbWV0YWxuZXNzOiA8ZmxvYXQ+LFxyXG5cdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKlxyXG5cdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuXHQgKlxyXG5cdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cclxuXHQgKlxyXG5cdCAqICBlbWlzc2l2ZTogPGhleD4sXHJcblx0ICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcblx0ICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGJ1bXBTY2FsZTogPGZsb2F0PixcclxuXHQgKlxyXG5cdCAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXHJcblx0ICpcclxuXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcclxuXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcclxuXHQgKlxyXG5cdCAqICByb3VnaG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgbWV0YWxuZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICogIGVudk1hcDogbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuXHQgKiAgZW52TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcblx0ICpcclxuXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgc2tpbm5pbmc6IDxib29sPixcclxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcblx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoU3RhbmRhcmRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxyXG5cdFx0dGhpcy5yb3VnaG5lc3MgPSAwLjU7XHJcblx0XHR0aGlzLm1ldGFsbmVzcyA9IDAuNTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG5cclxuXHRcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLm1ldGFsbmVzc01hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XHJcblxyXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcclxuXHJcblx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcclxuXHJcblx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xyXG5cdFx0dGhpcy5yb3VnaG5lc3MgPSBzb3VyY2Uucm91Z2huZXNzO1xyXG5cdFx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xyXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xyXG5cclxuXHRcdHRoaXMubWV0YWxuZXNzTWFwID0gc291cmNlLm1ldGFsbmVzc01hcDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHRcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoUGh5c2ljYWxNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdNZXNoUGh5c2ljYWxNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAwLjU7IC8vIG1hcHMgdG8gRjAgPSAwLjA0XHJcblxyXG5cdFx0dGhpcy5jbGVhckNvYXQgPSAwLjA7XHJcblx0XHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IDAuMDtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xyXG5cclxuXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5kZWZpbmVzID0geyAnUEhZU0lDQUwnOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHR0aGlzLmNsZWFyQ29hdCA9IHNvdXJjZS5jbGVhckNvYXQ7XHJcblx0XHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IHNvdXJjZS5jbGVhckNvYXRSb3VnaG5lc3M7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKlxyXG5cdCAqIHBhcmFtZXRlcnMgPSB7XHJcblx0ICogIGNvbG9yOiA8aGV4PixcclxuXHQgKiAgc3BlY3VsYXI6IDxoZXg+LFxyXG5cdCAqICBzaGluaW5lc3M6IDxmbG9hdD4sXHJcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxyXG5cdCAqXHJcblx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxyXG5cdCAqXHJcblx0ICogIGVtaXNzaXZlOiA8aGV4PixcclxuXHQgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cclxuXHQgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcclxuXHQgKlxyXG5cdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxyXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG5cdCAqXHJcblx0ICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcblx0ICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcclxuXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgc2tpbm5pbmc6IDxib29sPixcclxuXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcblx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoUGhvbmdNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXHJcblx0XHR0aGlzLnNwZWN1bGFyID0gbmV3IENvbG9yKCAweDExMTExMSApO1xyXG5cdFx0dGhpcy5zaGluaW5lc3MgPSAzMDtcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYnVtcE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IDE7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xyXG5cclxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xyXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoUGhvbmdNYXRlcmlhbDtcclxuXHJcblx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBob25nTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0XHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xyXG5cdFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xyXG5cclxuXHRcdHRoaXMubWFwID0gc291cmNlLm1hcDtcclxuXHJcblx0XHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xyXG5cdFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcclxuXHRcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcclxuXHJcblx0XHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcclxuXHRcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xyXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xyXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcclxuXHJcblx0XHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xyXG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHRha2FoaXJveCAvIGh0dHA6Ly9naXRodWIuY29tL3Rha2FoaXJveFxyXG5cdCAqXHJcblx0ICogcGFyYW1ldGVycyA9IHtcclxuXHQgKiAgZ3JhZGllbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+IClcclxuXHQgKiB9XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE1lc2hUb29uTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0TWVzaFBob25nTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMuZGVmaW5lcyA9IHsgJ1RPT04nOiAnJyB9O1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLmdyYWRpZW50TWFwID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblx0TWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoVG9vbk1hdGVyaWFsO1xyXG5cclxuXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5ncmFkaWVudE1hcCA9IHNvdXJjZS5ncmFkaWVudE1hcDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKlxyXG5cdCAqIHBhcmFtZXRlcnMgPSB7XHJcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcclxuXHQgKlxyXG5cdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxyXG5cdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG5cdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cclxuXHQgKlxyXG5cdCAqICBza2lubmluZzogPGJvb2w+LFxyXG5cdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cclxuXHQgKiB9XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE1lc2hOb3JtYWxNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHRcdHRoaXMuYnVtcFNjYWxlID0gMTtcclxuXHJcblx0XHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcclxuXHRcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcclxuXHRcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0XHR0aGlzLmZvZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5saWdodHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xyXG5cclxuXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0TWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XHJcblx0XHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xyXG5cdFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XHJcblx0XHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuXHQgKlxyXG5cdCAqIHBhcmFtZXRlcnMgPSB7XHJcblx0ICogIGNvbG9yOiA8aGV4PixcclxuXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcclxuXHQgKlxyXG5cdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICpcclxuXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcblx0ICpcclxuXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcblx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XHJcblx0ICpcclxuXHQgKiAgZW1pc3NpdmU6IDxoZXg+LFxyXG5cdCAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxyXG5cdCAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKlxyXG5cdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKlxyXG5cdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuXHQgKlxyXG5cdCAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXHJcblx0ICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG5cdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcblx0ICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcclxuXHQgKlxyXG5cdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcblx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG5cdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTWVzaExhbWJlcnRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xyXG5cclxuXHRcdHRoaXMuYW9NYXAgPSBudWxsO1xyXG5cdFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcclxuXHJcblx0XHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcclxuXHRcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHRcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xyXG5cdFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHRcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHRcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaExhbWJlcnRNYXRlcmlhbDtcclxuXHJcblx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTGFtYmVydE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblxyXG5cdFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xyXG5cclxuXHRcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XHJcblx0XHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XHJcblx0XHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XHJcblx0XHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xyXG5cdFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xyXG5cclxuXHRcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xyXG5cdFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XHJcblx0XHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XHJcblx0XHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XHJcblxyXG5cdFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0XHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XHJcblx0XHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICpcclxuXHQgKiBwYXJhbWV0ZXJzID0ge1xyXG5cdCAqICBjb2xvcjogPGhleD4sXHJcblx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcblx0ICpcclxuXHQgKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG5cdCAqXHJcblx0ICogIHNjYWxlOiA8ZmxvYXQ+LFxyXG5cdCAqICBkYXNoU2l6ZTogPGZsb2F0PixcclxuXHQgKiAgZ2FwU2l6ZTogPGZsb2F0PlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTGluZURhc2hlZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdExpbmVCYXNpY01hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcclxuXHJcblx0XHR0aGlzLnNjYWxlID0gMTtcclxuXHRcdHRoaXMuZGFzaFNpemUgPSAzO1xyXG5cdFx0dGhpcy5nYXBTaXplID0gMTtcclxuXHJcblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZURhc2hlZE1hdGVyaWFsO1xyXG5cclxuXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcclxuXHJcblx0TGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcclxuXHRcdHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XHJcblx0XHR0aGlzLmdhcFNpemUgPSBzb3VyY2UuZ2FwU2l6ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblxyXG5cclxuXHR2YXIgTWF0ZXJpYWxzID0gT2JqZWN0LmZyZWV6ZSh7XHJcblx0XHRTaGFkb3dNYXRlcmlhbDogU2hhZG93TWF0ZXJpYWwsXHJcblx0XHRTcHJpdGVNYXRlcmlhbDogU3ByaXRlTWF0ZXJpYWwsXHJcblx0XHRSYXdTaGFkZXJNYXRlcmlhbDogUmF3U2hhZGVyTWF0ZXJpYWwsXHJcblx0XHRTaGFkZXJNYXRlcmlhbDogU2hhZGVyTWF0ZXJpYWwsXHJcblx0XHRQb2ludHNNYXRlcmlhbDogUG9pbnRzTWF0ZXJpYWwsXHJcblx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbDogTWVzaFBoeXNpY2FsTWF0ZXJpYWwsXHJcblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogTWVzaFN0YW5kYXJkTWF0ZXJpYWwsXHJcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogTWVzaFBob25nTWF0ZXJpYWwsXHJcblx0XHRNZXNoVG9vbk1hdGVyaWFsOiBNZXNoVG9vbk1hdGVyaWFsLFxyXG5cdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiBNZXNoTm9ybWFsTWF0ZXJpYWwsXHJcblx0XHRNZXNoTGFtYmVydE1hdGVyaWFsOiBNZXNoTGFtYmVydE1hdGVyaWFsLFxyXG5cdFx0TWVzaERlcHRoTWF0ZXJpYWw6IE1lc2hEZXB0aE1hdGVyaWFsLFxyXG5cdFx0TWVzaERpc3RhbmNlTWF0ZXJpYWw6IE1lc2hEaXN0YW5jZU1hdGVyaWFsLFxyXG5cdFx0TWVzaEJhc2ljTWF0ZXJpYWw6IE1lc2hCYXNpY01hdGVyaWFsLFxyXG5cdFx0TGluZURhc2hlZE1hdGVyaWFsOiBMaW5lRGFzaGVkTWF0ZXJpYWwsXHJcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogTGluZUJhc2ljTWF0ZXJpYWwsXHJcblx0XHRNYXRlcmlhbDogTWF0ZXJpYWxcclxuXHR9KTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0dmFyIENhY2hlID0ge1xyXG5cclxuXHRcdGVuYWJsZWQ6IGZhbHNlLFxyXG5cclxuXHRcdGZpbGVzOiB7fSxcclxuXHJcblx0XHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xyXG5cclxuXHRcdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmZpbGVzID0ge307XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBMb2FkaW5nTWFuYWdlciggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cdFx0dmFyIGl0ZW1zTG9hZGVkID0gMDtcclxuXHRcdHZhciBpdGVtc1RvdGFsID0gMDtcclxuXHRcdHZhciB1cmxNb2RpZmllciA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR0aGlzLm9uU3RhcnQgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcclxuXHRcdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XHJcblx0XHR0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xyXG5cclxuXHRcdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0XHRpdGVtc1RvdGFsICsrO1xyXG5cclxuXHRcdFx0aWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlzTG9hZGluZyA9IHRydWU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRcdGl0ZW1zTG9hZGVkICsrO1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwgKSB7XHJcblxyXG5cdFx0XHRcdGlzTG9hZGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHNjb3BlLm9uTG9hZCgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5vbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm9uRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5yZXNvbHZlVVJMID0gZnVuY3Rpb24gKCB1cmwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHVybE1vZGlmaWVyICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdXJsTW9kaWZpZXIoIHVybCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHVybDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuc2V0VVJMTW9kaWZpZXIgPSBmdW5jdGlvbiAoIHRyYW5zZm9ybSApIHtcclxuXHJcblx0XHRcdHVybE1vZGlmaWVyID0gdHJhbnNmb3JtO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0dmFyIGxvYWRpbmcgPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gRmlsZUxvYWRlciggbWFuYWdlciApIHtcclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBGaWxlTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xyXG5cclxuXHRcdFx0dXJsID0gdGhpcy5tYW5hZ2VyLnJlc29sdmVVUkwoIHVybCApO1xyXG5cclxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRcdHZhciBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xyXG5cclxuXHRcdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xyXG5cclxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0XHRcdH0sIDAgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNhY2hlZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgZHVwbGljYXRlXHJcblxyXG5cdFx0XHRpZiAoIGxvYWRpbmdbIHVybCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcclxuXHJcblx0XHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcclxuXHRcdFx0XHRcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXHJcblx0XHRcdFx0XHRvbkVycm9yOiBvbkVycm9yXHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGRhdGE6IFVSSVxyXG5cdFx0XHR2YXIgZGF0YVVyaVJlZ2V4ID0gL15kYXRhOiguKj8pKDtiYXNlNjQpPywoLiopJC87XHJcblx0XHRcdHZhciBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goIGRhdGFVcmlSZWdleCApO1xyXG5cclxuXHRcdFx0Ly8gU2FmYXJpIGNhbiBub3QgaGFuZGxlIERhdGEgVVJJcyB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0IHNvIHByb2Nlc3MgbWFudWFsbHlcclxuXHRcdFx0aWYgKCBkYXRhVXJpUmVnZXhSZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtaW1lVHlwZSA9IGRhdGFVcmlSZWdleFJlc3VsdFsgMSBdO1xyXG5cdFx0XHRcdHZhciBpc0Jhc2U2NCA9ICEhIGRhdGFVcmlSZWdleFJlc3VsdFsgMiBdO1xyXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAzIF07XHJcblxyXG5cdFx0XHRcdGRhdGEgPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdGlmICggaXNCYXNlNjQgKSBkYXRhID0gd2luZG93LmF0b2IoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcmVzcG9uc2U7XHJcblx0XHRcdFx0XHR2YXIgcmVzcG9uc2VUeXBlID0gKCB0aGlzLnJlc3BvbnNlVHlwZSB8fCAnJyApLnRvTG93ZXJDYXNlKCk7XHJcblxyXG5cdFx0XHRcdFx0c3dpdGNoICggcmVzcG9uc2VUeXBlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnYXJyYXlidWZmZXInOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdibG9iJzpcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSggZGF0YS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmlld1sgaSBdID0gZGF0YS5jaGFyQ29kZUF0KCBpICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCByZXNwb25zZVR5cGUgPT09ICdibG9iJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBCbG9iKCBbIHZpZXcuYnVmZmVyIF0sIHsgdHlwZTogbWltZVR5cGUgfSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gdmlldy5idWZmZXI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdkb2N1bWVudCc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBtaW1lVHlwZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ2pzb24nOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IEpTT04ucGFyc2UoIGRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRkZWZhdWx0OiAvLyAndGV4dCcgb3Igb3RoZXJcclxuXHJcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBkYXRhO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gV2FpdCBmb3IgbmV4dCBicm93c2VyIHRpY2sgbGlrZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBldmVudCBkaXNwYXRjaGluZyBkb2VzXHJcblx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0XHRcdH0sIDAgKTtcclxuXHJcblx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIFdhaXQgZm9yIG5leHQgYnJvd3NlciB0aWNrIGxpa2Ugc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3QgZXZlbnQgZGlzcGF0Y2hpbmcgZG9lc1xyXG5cdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGVycm9yICk7XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblxyXG5cdFx0XHRcdFx0fSwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBJbml0aWFsaXNlIGFycmF5IGZvciBkdXBsaWNhdGUgcmVxdWVzdHNcclxuXHJcblx0XHRcdFx0bG9hZGluZ1sgdXJsIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0bG9hZGluZ1sgdXJsIF0ucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdG9uTG9hZDogb25Mb2FkLFxyXG5cdFx0XHRcdFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcclxuXHRcdFx0XHRcdG9uRXJyb3I6IG9uRXJyb3JcclxuXHJcblx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHRcdFx0XHRyZXF1ZXN0Lm9wZW4oICdHRVQnLCB1cmwsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcclxuXHJcblx0XHRcdFx0XHRDYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XHJcblxyXG5cdFx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGhpcy5zdGF0dXMgPT09IDIwMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25Mb2FkICkgY2FsbGJhY2sub25Mb2FkKCByZXNwb25zZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnN0YXR1cyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxyXG5cdFx0XHRcdFx0XHQvLyBlLmcuICdmaWxlOi8vJyBvciAnZGF0YTovLycuIEhhbmRsZSBhcyBzdWNjZXNzLlxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmlsZUxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4nICk7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLm9uTG9hZCApIGNhbGxiYWNrLm9uTG9hZCggcmVzcG9uc2UgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sub25FcnJvciApIGNhbGxiYWNrLm9uRXJyb3IoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cdFx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcclxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vblByb2dyZXNzICkgY2FsbGJhY2sub25Qcm9ncmVzcyggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0XHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XHJcblxyXG5cdFx0XHRcdFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcclxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHRcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcclxuXHJcblx0XHRcdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLnJlc3BvbnNlVHlwZSAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuXHRcdFx0XHRpZiAoIHRoaXMud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSApIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSggdGhpcy5taW1lVHlwZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5taW1lVHlwZSA6ICd0ZXh0L3BsYWluJyApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaGVhZGVyIGluIHRoaXMucmVxdWVzdEhlYWRlciApIHtcclxuXHJcblx0XHRcdFx0XHRyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoIGhlYWRlciwgdGhpcy5yZXF1ZXN0SGVhZGVyWyBoZWFkZXIgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJlcXVlc3Q7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRXaXRoQ3JlZGVudGlhbHM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldE1pbWVUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5taW1lVHlwZSA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlcXVlc3RIZWFkZXIgPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICpcclxuXHQgKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG5cdFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuXHRcdHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgaW1hZ2VzID0gW107XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcclxuXHJcblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0XHRpbWFnZXNbIGkgXSA9IHtcclxuXHRcdFx0XHRcdFx0d2lkdGg6IHRleERhdGFzLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcclxuXHRcdFx0XHRcdFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXHJcblx0XHRcdFx0XHRcdG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0bG9hZGVkICs9IDE7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcclxuXHRcdFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbG9hZGVkID0gMDtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRsb2FkVGV4dHVyZSggaSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcclxuXHJcblx0XHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdID0geyBtaXBtYXBzOiBbXSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcclxuXHRcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XHJcblx0XHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cclxuXHQgKlxyXG5cdCAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gRGF0YVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG5cdFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcclxuXHRcdHRoaXMuX3BhcnNlciA9IG51bGw7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggRGF0YVRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xyXG5cclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XHJcblxyXG5cdFx0XHRcdGlmICggISB0ZXhEYXRhICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHRcdFx0XHR0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xyXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pbkZpbHRlciA/IHRleERhdGEubWluRmlsdGVyIDogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSB1bmRlZmluZWQgIT09IHRleERhdGEuYW5pc290cm9weSA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XHJcblxyXG5cdFx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xyXG5cclxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBJbWFnZUxvYWRlciggbWFuYWdlciApIHtcclxuXHJcblx0XHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBJbWFnZUxvYWRlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXHJcblxyXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdGlmICggdXJsID09PSB1bmRlZmluZWQgKSB1cmwgPSAnJztcclxuXHJcblx0XHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XHJcblxyXG5cdFx0XHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdFx0fSwgMCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdpbWcnICk7XHJcblxyXG5cdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Q2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uUHJvZ3Jlc3MgKSBvblByb2dyZXNzKCBldmVudCApO1xyXG5cclxuXHRcdFx0fSwgZmFsc2UgKTtcclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdGlmICggdXJsLnN1YnN0ciggMCwgNSApICE9PSAnZGF0YTonICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIGltYWdlLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdGltYWdlLnNyYyA9IHVybDtcclxuXHJcblx0XHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEN1YmVUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEN1YmVUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGNyb3NzT3JpZ2luOiAnQW5vbnltb3VzJyxcclxuXHJcblx0XHRsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblx0XHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcclxuXHJcblx0XHRcdHZhciBsb2FkZWQgPSAwO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xyXG5cclxuXHRcdFx0XHRcdGxvYWRlZCArKztcclxuXHJcblx0XHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXHJcblxyXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcclxuXHJcblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xyXG5cclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xyXG5cclxuXHRcdFx0XHQvLyBKUEVHcyBjYW4ndCBoYXZlIGFuIGFscGhhIGNoYW5uZWwsIHNvIG1lbW9yeSBjYW4gYmUgc2F2ZWQgYnkgc3RvcmluZyB0aGVtIGFzIFJHQi5cclxuXHRcdFx0XHR2YXIgaXNKUEVHID0gdXJsLnNlYXJjaCggL1xcLihqcGd8anBlZykkLyApID4gMCB8fCB1cmwuc2VhcmNoKCAvXmRhdGFcXDppbWFnZVxcL2pwZWcvICkgPT09IDA7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gaXNKUEVHID8gUkdCRm9ybWF0IDogUkdCQUZvcm1hdDtcclxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gdmFsdWU7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcblx0ICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcclxuXHQgKlxyXG5cdCAqIFNvbWUgY29tbW9uIG9mIGN1cnZlIG1ldGhvZHM6XHJcblx0ICogLmdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudCggdCApXHJcblx0ICogLmdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50QXQoIHUgKVxyXG5cdCAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXHJcblx0ICogLmdldExlbmd0aCgpXHJcblx0ICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxyXG5cdCAqXHJcblx0ICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcclxuXHQgKlxyXG5cdCAqIC0tIDJEIGN1cnZlcyAtLVxyXG5cdCAqIFRIUkVFLkFyY0N1cnZlXHJcblx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxyXG5cdCAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxyXG5cdCAqIFRIUkVFLkxpbmVDdXJ2ZVxyXG5cdCAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXHJcblx0ICogVEhSRUUuU3BsaW5lQ3VydmVcclxuXHQgKlxyXG5cdCAqIC0tIDNEIGN1cnZlcyAtLVxyXG5cdCAqIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTNcclxuXHQgKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xyXG5cdCAqIFRIUkVFLkxpbmVDdXJ2ZTNcclxuXHQgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcclxuXHQgKlxyXG5cdCAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGguXHJcblx0ICpcclxuXHQgKiovXHJcblxyXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cdCAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXHJcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHRmdW5jdGlvbiBDdXJ2ZSgpIHtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ3VydmUnO1xyXG5cclxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gMjAwO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEN1cnZlLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xyXG5cdFx0Ly9cdC0gdCBbMCAuLiAxXVxyXG5cclxuXHRcdGdldFBvaW50OiBmdW5jdGlvbiAoIC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5nZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZC4nICk7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gR2V0IHBvaW50IGF0IHJlbGF0aXZlIHBvc2l0aW9uIGluIGN1cnZlIGFjY29yZGluZyB0byBhcmMgbGVuZ3RoXHJcblx0XHQvLyAtIHUgWzAgLi4gMV1cclxuXHJcblx0XHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXHJcblxyXG5cdFx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBvaW50cztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXHJcblxyXG5cdFx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcclxuXHJcblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblx0XHRcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXHJcblxyXG5cdFx0Z2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXHJcblx0XHRcdFx0KCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJlxyXG5cdFx0XHRcdCEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dmFyIGNhY2hlID0gW107XHJcblx0XHRcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG5cdFx0XHR2YXIgcCwgc3VtID0gMDtcclxuXHJcblx0XHRcdGNhY2hlLnB1c2goIDAgKTtcclxuXHJcblx0XHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQoIHAgLyBkaXZpc2lvbnMgKTtcclxuXHRcdFx0XHRzdW0gKz0gY3VycmVudC5kaXN0YW5jZVRvKCBsYXN0ICk7XHJcblx0XHRcdFx0Y2FjaGUucHVzaCggc3VtICk7XHJcblx0XHRcdFx0bGFzdCA9IGN1cnJlbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06IHN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmdldExlbmd0aHMoKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcclxuXHJcblx0XHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XHJcblxyXG5cdFx0XHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XHJcblxyXG5cdFx0XHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcclxuXHJcblx0XHRcdGlmICggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcclxuXHJcblx0XHRcdHZhciBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xyXG5cclxuXHRcdFx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcclxuXHJcblx0XHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXHJcblxyXG5cdFx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XHJcblxyXG5cdFx0XHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bG93ID0gaSArIDE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdGhpZ2ggPSBpIC0gMTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRoaWdoID0gaTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdC8vIERPTkVcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aSA9IGhpZ2g7XHJcblxyXG5cdFx0XHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaSAvICggaWwgLSAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB3ZSBjb3VsZCBnZXQgZmluZXIgZ3JhaW4gYXQgbGVuZ3Rocywgb3IgdXNlIHNpbXBsZSBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xyXG5cclxuXHRcdFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcclxuXHRcdFx0dmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcclxuXHJcblx0XHRcdHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XHJcblxyXG5cdFx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xyXG5cclxuXHRcdFx0dmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xyXG5cclxuXHRcdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxyXG5cclxuXHRcdFx0dmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcclxuXHRcdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcclxuXHRcdC8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XHJcblx0XHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXHJcblxyXG5cdFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdFx0dmFyIGRlbHRhID0gMC4wMDAxO1xyXG5cdFx0XHR2YXIgdDEgPSB0IC0gZGVsdGE7XHJcblx0XHRcdHZhciB0MiA9IHQgKyBkZWx0YTtcclxuXHJcblx0XHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcclxuXHJcblx0XHRcdGlmICggdDEgPCAwICkgdDEgPSAwO1xyXG5cdFx0XHRpZiAoIHQyID4gMSApIHQyID0gMTtcclxuXHJcblx0XHRcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xyXG5cdFx0XHR2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcclxuXHJcblx0XHRcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xyXG5cdFx0XHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29tcHV0ZUZyZW5ldEZyYW1lczogZnVuY3Rpb24gKCBzZWdtZW50cywgY2xvc2VkICkge1xyXG5cclxuXHRcdFx0Ly8gc2VlIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxyXG5cclxuXHRcdFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2YXIgdGFuZ2VudHMgPSBbXTtcclxuXHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdFx0dmFyIGJpbm9ybWFscyA9IFtdO1xyXG5cclxuXHRcdFx0dmFyIHZlYyA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBtYXQgPSBuZXcgTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0dmFyIGksIHUsIHRoZXRhO1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dSA9IGkgLyBzZWdtZW50cztcclxuXHJcblx0XHRcdFx0dGFuZ2VudHNbIGkgXSA9IHRoaXMuZ2V0VGFuZ2VudEF0KCB1ICk7XHJcblx0XHRcdFx0dGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXHJcblx0XHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxyXG5cclxuXHRcdFx0bm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHR2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHRcdFx0dmFyIHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xyXG5cdFx0XHR2YXIgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XHJcblx0XHRcdHZhciB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcclxuXHJcblx0XHRcdGlmICggdHggPD0gbWluICkge1xyXG5cclxuXHRcdFx0XHRtaW4gPSB0eDtcclxuXHRcdFx0XHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHR5IDw9IG1pbiApIHtcclxuXHJcblx0XHRcdFx0bWluID0gdHk7XHJcblx0XHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0eiA8PSBtaW4gKSB7XHJcblxyXG5cdFx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XHJcblx0XHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHRiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xyXG5cclxuXHRcdFx0XHRcdHZlYy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggX01hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXHJcblxyXG5cdFx0XHRpZiAoIGNsb3NlZCA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XHJcblx0XHRcdFx0dGhldGEgLz0gc2VnbWVudHM7XHJcblxyXG5cdFx0XHRcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgc2VnbWVudHMgXSApICkgPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRoZXRhID0gLSB0aGV0YTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XHJcblx0XHRcdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcclxuXHRcdFx0XHRub3JtYWxzOiBub3JtYWxzLFxyXG5cdFx0XHRcdGJpbm9ybWFsczogYmlub3JtYWxzXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSB7XHJcblx0XHRcdFx0bWV0YWRhdGE6IHtcclxuXHRcdFx0XHRcdHZlcnNpb246IDQuNSxcclxuXHRcdFx0XHRcdHR5cGU6ICdDdXJ2ZScsXHJcblx0XHRcdFx0XHRnZW5lcmF0b3I6ICdDdXJ2ZS50b0pTT04nXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0ZGF0YS5hcmNMZW5ndGhEaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcclxuXHRcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBqc29uLmFyY0xlbmd0aERpdmlzaW9ucztcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRmdW5jdGlvbiBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcclxuXHJcblx0XHR0aGlzLmFYID0gYVggfHwgMDtcclxuXHRcdHRoaXMuYVkgPSBhWSB8fCAwO1xyXG5cclxuXHRcdHRoaXMueFJhZGl1cyA9IHhSYWRpdXMgfHwgMTtcclxuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXMgfHwgMTtcclxuXHJcblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGUgfHwgMDtcclxuXHRcdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlIHx8IDIgKiBNYXRoLlBJO1xyXG5cclxuXHRcdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2UgfHwgZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb24gfHwgMDtcclxuXHJcblx0fVxyXG5cclxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2VDdXJ2ZTtcclxuXHJcblx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XHJcblxyXG5cdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0dmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XHJcblx0XHR2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcclxuXHRcdHZhciBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xyXG5cclxuXHRcdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxyXG5cdFx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XHJcblx0XHR3aGlsZSAoIGRlbHRhQW5nbGUgPiB0d29QaSApIGRlbHRhQW5nbGUgLT0gdHdvUGk7XHJcblxyXG5cdFx0aWYgKCBkZWx0YUFuZ2xlIDwgTnVtYmVyLkVQU0lMT04gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNhbWVQb2ludHMgKSB7XHJcblxyXG5cdFx0XHRcdGRlbHRhQW5nbGUgPSAwO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRlbHRhQW5nbGUgPT09IHR3b1BpICkge1xyXG5cclxuXHRcdFx0XHRkZWx0YUFuZ2xlID0gLSB0d29QaTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGRlbHRhQW5nbGUgPSBkZWx0YUFuZ2xlIC0gdHdvUGk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHRcdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmFSb3RhdGlvbiAhPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcclxuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xyXG5cclxuXHRcdFx0dmFyIHR4ID0geCAtIHRoaXMuYVg7XHJcblx0XHRcdHZhciB0eSA9IHkgLSB0aGlzLmFZO1xyXG5cclxuXHRcdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxyXG5cdFx0XHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XHJcblx0XHRcdHkgPSB0eCAqIHNpbiArIHR5ICogY29zICsgdGhpcy5hWTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnNldCggeCwgeSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLmFYID0gc291cmNlLmFYO1xyXG5cdFx0dGhpcy5hWSA9IHNvdXJjZS5hWTtcclxuXHJcblx0XHR0aGlzLnhSYWRpdXMgPSBzb3VyY2UueFJhZGl1cztcclxuXHRcdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xyXG5cclxuXHRcdHRoaXMuYVN0YXJ0QW5nbGUgPSBzb3VyY2UuYVN0YXJ0QW5nbGU7XHJcblx0XHR0aGlzLmFFbmRBbmdsZSA9IHNvdXJjZS5hRW5kQW5nbGU7XHJcblxyXG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0gc291cmNlLmFDbG9ja3dpc2U7XHJcblxyXG5cdFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRkYXRhLmFYID0gdGhpcy5hWDtcclxuXHRcdGRhdGEuYVkgPSB0aGlzLmFZO1xyXG5cclxuXHRcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcclxuXHRcdGRhdGEueVJhZGl1cyA9IHRoaXMueVJhZGl1cztcclxuXHJcblx0XHRkYXRhLmFTdGFydEFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZTtcclxuXHRcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XHJcblxyXG5cdFx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xyXG5cclxuXHRcdGRhdGEuYVJvdGF0aW9uID0gdGhpcy5hUm90YXRpb247XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH07XHJcblxyXG5cdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLmFYID0ganNvbi5hWDtcclxuXHRcdHRoaXMuYVkgPSBqc29uLmFZO1xyXG5cclxuXHRcdHRoaXMueFJhZGl1cyA9IGpzb24ueFJhZGl1cztcclxuXHRcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcclxuXHJcblx0XHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcclxuXHRcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XHJcblxyXG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xyXG5cclxuXHRcdHRoaXMuYVJvdGF0aW9uID0ganNvbi5hUm90YXRpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEFyY0N1cnZlKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0RWxsaXBzZUN1cnZlLmNhbGwoIHRoaXMsIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XHJcblxyXG5cdH1cclxuXHJcblx0QXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xyXG5cdEFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFyY0N1cnZlO1xyXG5cclxuXHRBcmNDdXJ2ZS5wcm90b3R5cGUuaXNBcmNDdXJ2ZSA9IHRydWU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG5cdCAqXHJcblx0ICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcclxuXHQgKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cclxuXHQgKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxyXG5cdCAqXHJcblx0ICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXHJcblx0ICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxyXG5cdCAqL1xyXG5cclxuXHJcblx0LypcclxuXHRCYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXHJcblx0IC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cclxuXHQgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cclxuXHJcblx0VGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxyXG5cdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxyXG5cdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cclxuXHQqL1xyXG5cclxuXHRmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XHJcblxyXG5cdFx0dmFyIGMwID0gMCwgYzEgPSAwLCBjMiA9IDAsIGMzID0gMDtcclxuXHJcblx0XHQvKlxyXG5cdFx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxyXG5cdFx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXHJcblx0XHQgKiBzdWNoIHRoYXRcclxuXHRcdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcclxuXHRcdCAqICBhbmRcclxuXHRcdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cclxuXHRcdCAqL1xyXG5cdFx0ZnVuY3Rpb24gaW5pdCggeDAsIHgxLCB0MCwgdDEgKSB7XHJcblxyXG5cdFx0XHRjMCA9IHgwO1xyXG5cdFx0XHRjMSA9IHQwO1xyXG5cdFx0XHRjMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XHJcblx0XHRcdGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHJcblx0XHRcdGluaXRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xyXG5cclxuXHRcdFx0XHRpbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0aW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXHJcblx0XHRcdFx0dmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcclxuXHRcdFx0XHR2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xyXG5cclxuXHRcdFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cclxuXHRcdFx0XHR0MSAqPSBkdDE7XHJcblx0XHRcdFx0dDIgKj0gZHQxO1xyXG5cclxuXHRcdFx0XHRpbml0KCB4MSwgeDIsIHQxLCB0MiApO1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGNhbGM6IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHQyID0gdCAqIHQ7XHJcblx0XHRcdFx0dmFyIHQzID0gdDIgKiB0O1xyXG5cdFx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIHRtcCA9IG5ldyBWZWN0b3IzKCk7XHJcblx0dmFyIHB4ID0gbmV3IEN1YmljUG9seSgpO1xyXG5cdHZhciBweSA9IG5ldyBDdWJpY1BvbHkoKTtcclxuXHR2YXIgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XHJcblxyXG5cdGZ1bmN0aW9uIENhdG11bGxSb21DdXJ2ZTMoIHBvaW50cywgY2xvc2VkLCBjdXJ2ZVR5cGUsIHRlbnNpb24gKSB7XHJcblxyXG5cdFx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuXHRcdHRoaXMuY2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xyXG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGUgfHwgJ2NlbnRyaXBldGFsJztcclxuXHRcdHRoaXMudGVuc2lvbiA9IHRlbnNpb24gfHwgMC41O1xyXG5cclxuXHR9XHJcblxyXG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYXRtdWxsUm9tQ3VydmUzO1xyXG5cclxuXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xyXG5cclxuXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcblx0XHR2YXIgbCA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0dmFyIHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcclxuXHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcclxuXHRcdHZhciB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcclxuXHJcblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xyXG5cclxuXHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcclxuXHRcdFx0d2VpZ2h0ID0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xyXG5cclxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xyXG5cclxuXHRcdFx0cDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBsIF07XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XHJcblx0XHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XHJcblx0XHRcdHAwID0gdG1wO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XHJcblx0XHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XHJcblxyXG5cdFx0XHRwMyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIGwgXTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxyXG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDEgXSApO1xyXG5cdFx0XHRwMyA9IHRtcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xyXG5cclxuXHRcdFx0Ly8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cclxuXHRcdFx0dmFyIHBvdyA9IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xyXG5cdFx0XHR2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcclxuXHRcdFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XHJcblx0XHRcdHZhciBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xyXG5cclxuXHRcdFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcclxuXHRcdFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xyXG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XHJcblx0XHRcdGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcclxuXHJcblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xyXG5cdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcclxuXHRcdFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcclxuXHJcblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcclxuXHRcdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRoaXMudGVuc2lvbiApO1xyXG5cdFx0XHRwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0cHguY2FsYyggd2VpZ2h0ICksXHJcblx0XHRcdHB5LmNhbGMoIHdlaWdodCApLFxyXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH07XHJcblxyXG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHNvdXJjZS5wb2ludHNbIGkgXTtcclxuXHJcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jbG9zZWQgPSBzb3VyY2UuY2xvc2VkO1xyXG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBzb3VyY2UuY3VydmVUeXBlO1xyXG5cdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdGRhdGEucG9pbnRzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzWyBpIF07XHJcblx0XHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkYXRhLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xyXG5cdFx0ZGF0YS5jdXJ2ZVR5cGUgPSB0aGlzLmN1cnZlVHlwZTtcclxuXHRcdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fTtcclxuXHJcblx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xyXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggcG9pbnQgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNsb3NlZCA9IGpzb24uY2xvc2VkO1xyXG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcclxuXHRcdHRoaXMudGVuc2lvbiA9IGpzb24udGVuc2lvbjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqXHJcblx0ICogQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXHJcblx0ICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIENhdG11bGxSb20oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xyXG5cclxuXHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xyXG5cdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XHJcblx0XHR2YXIgdDIgPSB0ICogdDtcclxuXHRcdHZhciB0MyA9IHQgKiB0MjtcclxuXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gayAqIGsgKiBwO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAxKCB0LCBwICkge1xyXG5cclxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDIoIHQsIHAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHQgKiB0ICogcDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXIoIHQsIHAwLCBwMSwgcDIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIFF1YWRyYXRpY0JlemllclAwKCB0LCBwMCApICsgUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAxICkgK1xyXG5cdFx0XHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAxKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMiggdCwgcCApIHtcclxuXHJcblx0XHRyZXR1cm4gMyAqICggMSAtIHQgKSAqIHQgKiB0ICogcDtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBDdWJpY0JlemllclAzKCB0LCBwICkge1xyXG5cclxuXHRcdHJldHVybiB0ICogdCAqIHQgKiBwO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEN1YmljQmV6aWVyKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcclxuXHJcblx0XHRyZXR1cm4gQ3ViaWNCZXppZXJQMCggdCwgcDAgKSArIEN1YmljQmV6aWVyUDEoIHQsIHAxICkgKyBDdWJpY0JlemllclAyKCB0LCBwMiApICtcclxuXHRcdFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBDdWJpY0JlemllckN1cnZlKCB2MCwgdjEsIHYyLCB2MyApIHtcclxuXHJcblx0XHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUnO1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cdFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IyKCk7XHJcblx0XHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHRcdHRoaXMudjMgPSB2MyB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHR9XHJcblxyXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJpY0JlemllckN1cnZlO1xyXG5cclxuXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xyXG5cclxuXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH07XHJcblxyXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblx0XHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH07XHJcblxyXG5cdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZTMoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMudjMgPSB2MyB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHR9XHJcblxyXG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmUzO1xyXG5cclxuXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNDdWJpY0JlemllckN1cnZlMyA9IHRydWU7XHJcblxyXG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKSxcclxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH07XHJcblxyXG5cdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcclxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xyXG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fTtcclxuXHJcblx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XHJcblxyXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcclxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gTGluZUN1cnZlKCB2MSwgdjIgKSB7XHJcblxyXG5cdFx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xyXG5cclxuXHRcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMigpO1xyXG5cdFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdH1cclxuXHJcblx0TGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5cdExpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQ3VydmU7XHJcblxyXG5cdExpbmVDdXJ2ZS5wcm90b3R5cGUuaXNMaW5lQ3VydmUgPSB0cnVlO1xyXG5cclxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdGlmICggdCA9PT0gMSApIHtcclxuXHJcblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xyXG5cdFx0XHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxyXG5cclxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiAoIC8qIHQgKi8gKSB7XHJcblxyXG5cdFx0dmFyIHRhbmdlbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XHJcblxyXG5cdFx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdExpbmVDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XHJcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRMaW5lQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcclxuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fTtcclxuXHJcblx0TGluZUN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBMaW5lQ3VydmUzKCB2MSwgdjIgKSB7XHJcblxyXG5cdFx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcclxuXHJcblx0XHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHR9XHJcblxyXG5cdExpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblx0TGluZUN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQ3VydmUzO1xyXG5cclxuXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5pc0xpbmVDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRpZiAoIHQgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcclxuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcclxuXHJcblx0TGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdExpbmVDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0TGluZUN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xyXG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9O1xyXG5cclxuXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XHJcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiApIHtcclxuXHJcblx0XHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcclxuXHJcblx0XHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcclxuXHRcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMigpO1xyXG5cdFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdH1cclxuXHJcblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XHJcblxyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcclxuXHJcblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xyXG5cclxuXHRcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXHJcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludDtcclxuXHJcblx0fTtcclxuXHJcblx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xyXG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcclxuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH07XHJcblxyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XHJcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xyXG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyICkge1xyXG5cclxuXHRcdEN1cnZlLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcclxuXHJcblx0XHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjMoKTtcclxuXHRcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XHJcblxyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xyXG5cclxuXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xyXG5cclxuXHRcdHBvaW50LnNldChcclxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXHJcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxyXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnogKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH07XHJcblxyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XHJcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xyXG5cdFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XHJcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdH07XHJcblxyXG5cdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xyXG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcclxuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFNwbGluZUN1cnZlKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcclxuXHJcblx0XHRDdXJ2ZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGxpbmVDdXJ2ZTtcclxuXHJcblx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xyXG5cclxuXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG5cdFx0dmFyIHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xyXG5cclxuXHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcclxuXHRcdHZhciB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XHJcblxyXG5cdFx0dmFyIHAwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XHJcblx0XHR2YXIgcDEgPSBwb2ludHNbIGludFBvaW50IF07XHJcblx0XHR2YXIgcDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xyXG5cdFx0dmFyIHAzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcclxuXHJcblx0XHRwb2ludC5zZXQoXHJcblx0XHRcdENhdG11bGxSb20oIHdlaWdodCwgcDAueCwgcDEueCwgcDIueCwgcDMueCApLFxyXG5cdFx0XHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gcG9pbnQ7XHJcblxyXG5cdH07XHJcblxyXG5cdFNwbGluZUN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XHJcblxyXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9O1xyXG5cclxuXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcclxuXHRcdFx0ZGF0YS5wb2ludHMucHVzaCggcG9pbnQudG9BcnJheSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHR9O1xyXG5cclxuXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xyXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggcG9pbnQgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fTtcclxuXHJcblxyXG5cclxuXHR2YXIgQ3VydmVzID0gT2JqZWN0LmZyZWV6ZSh7XHJcblx0XHRBcmNDdXJ2ZTogQXJjQ3VydmUsXHJcblx0XHRDYXRtdWxsUm9tQ3VydmUzOiBDYXRtdWxsUm9tQ3VydmUzLFxyXG5cdFx0Q3ViaWNCZXppZXJDdXJ2ZTogQ3ViaWNCZXppZXJDdXJ2ZSxcclxuXHRcdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcclxuXHRcdEVsbGlwc2VDdXJ2ZTogRWxsaXBzZUN1cnZlLFxyXG5cdFx0TGluZUN1cnZlOiBMaW5lQ3VydmUsXHJcblx0XHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxyXG5cdFx0UXVhZHJhdGljQmV6aWVyQ3VydmU6IFF1YWRyYXRpY0JlemllckN1cnZlLFxyXG5cdFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzOiBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMsXHJcblx0XHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcclxuXHR9KTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqXHJcblx0ICoqL1xyXG5cclxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHQgKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXHJcblx0ICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXHJcblx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHRmdW5jdGlvbiBDdXJ2ZVBhdGgoKSB7XHJcblxyXG5cdFx0Q3VydmUuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdDdXJ2ZVBhdGgnO1xyXG5cclxuXHRcdHRoaXMuY3VydmVzID0gW107XHJcblx0XHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxyXG5cclxuXHR9XHJcblxyXG5cdEN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBDdXJ2ZVBhdGgsXHJcblxyXG5cdFx0YWRkOiBmdW5jdGlvbiAoIGN1cnZlICkge1xyXG5cclxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXHJcblx0XHRcdHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xyXG5cdFx0XHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1sgdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMSBdLmdldFBvaW50KCAxICk7XHJcblxyXG5cdFx0XHRpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBMaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xyXG5cdFx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxyXG5cdFx0Ly8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxyXG5cclxuXHRcdC8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cclxuXHRcdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxyXG5cdFx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxyXG5cdFx0Ly8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXHJcblxyXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHRcdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XHJcblx0XHRcdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdFx0XHR2YXIgaSA9IDA7XHJcblxyXG5cdFx0XHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcblx0XHRcdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcclxuXHRcdFx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcclxuXHRcdFx0XHRcdHZhciB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cclxuXHRcdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxyXG5cdFx0Ly8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxyXG5cclxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cdFx0XHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXHJcblx0XHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xyXG5cdFx0XHR0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gQ29tcHV0ZSBsZW5ndGhzIGFuZCBjYWNoZSB0aGVtXHJcblx0XHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxyXG5cclxuXHRcdGdldEN1cnZlTGVuZ3RoczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcclxuXHRcdFx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XHJcblxyXG5cdFx0XHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcclxuXHRcdFx0XHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcclxuXHJcblx0XHRcdHJldHVybiBsZW5ndGhzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA0MDtcclxuXHJcblx0XHRcdHZhciBwb2ludHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBvaW50cztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0XHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XHJcblxyXG5cdFx0XHR2YXIgcG9pbnRzID0gW10sIGxhc3Q7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGN1cnZlcyA9IHRoaXMuY3VydmVzOyBpIDwgY3VydmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGN1cnZlID0gY3VydmVzWyBpIF07XHJcblx0XHRcdFx0dmFyIHJlc29sdXRpb24gPSAoIGN1cnZlICYmIGN1cnZlLmlzRWxsaXBzZUN1cnZlICkgPyBkaXZpc2lvbnMgKiAyXHJcblx0XHRcdFx0XHQ6ICggY3VydmUgJiYgY3VydmUuaXNMaW5lQ3VydmUgKSA/IDFcclxuXHRcdFx0XHRcdFx0OiAoIGN1cnZlICYmIGN1cnZlLmlzU3BsaW5lQ3VydmUgKSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcclxuXHRcdFx0XHRcdFx0XHQ6IGRpdmlzaW9ucztcclxuXHJcblx0XHRcdFx0dmFyIHB0cyA9IGN1cnZlLmdldFBvaW50cyggcmVzb2x1dGlvbiApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBwb2ludCA9IHB0c1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xyXG5cclxuXHRcdFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludCApO1xyXG5cdFx0XHRcdFx0bGFzdCA9IHBvaW50O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICEgcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9pbnRzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHRcdHRoaXMuY3VydmVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjdXJ2ZSA9IHNvdXJjZS5jdXJ2ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUuY2xvbmUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hdXRvQ2xvc2UgPSBzb3VyY2UuYXV0b0Nsb3NlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0XHRkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xyXG5cdFx0XHRkYXRhLmN1cnZlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcclxuXHRcdFx0XHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHRcdHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XHJcblx0XHRcdHRoaXMuY3VydmVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY3VydmUgPSBqc29uLmN1cnZlc1sgaSBdO1xyXG5cdFx0XHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxyXG5cdCAqKi9cclxuXHJcblx0ZnVuY3Rpb24gUGF0aCggcG9pbnRzICkge1xyXG5cclxuXHRcdEN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ1BhdGgnO1xyXG5cclxuXHRcdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcblx0XHRpZiAoIHBvaW50cyApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdFBhdGgucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ3VydmVQYXRoLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFBhdGgsXHJcblxyXG5cdFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1vdmVUbyggcG9pbnRzWyAwIF0ueCwgcG9pbnRzWyAwIF0ueSApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubGluZVRvKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRtb3ZlVG86IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApOyAvLyBUT0RPIGNvbnNpZGVyIHJlZmVyZW5jaW5nIHZlY3RvcnMgaW5zdGVhZCBvZiBjb3B5aW5nP1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bGluZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VydmUgPSBuZXcgTGluZUN1cnZlKCB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMiggeCwgeSApICk7XHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IFF1YWRyYXRpY0JlemllckN1cnZlKFxyXG5cdFx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFDUHgsIGFDUHkgKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYVgsIGFZIClcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcclxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXHJcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxyXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzcGxpbmVUaHJ1OiBmdW5jdGlvbiAoIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xyXG5cclxuXHRcdFx0dmFyIG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xyXG5cclxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKCBucHRzICk7XHJcblx0XHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBwdHNbIHB0cy5sZW5ndGggLSAxIF0gKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGFyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0XHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xyXG5cdFx0XHR2YXIgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xyXG5cclxuXHRcdFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXHJcblx0XHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YWJzYXJjOiBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcclxuXHRcdFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcclxuXHJcblx0XHRcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRhYnNlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cclxuXHRcdFx0XHR2YXIgZmlyc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAwICk7XHJcblxyXG5cdFx0XHRcdGlmICggISBmaXJzdFBvaW50LmVxdWFscyggdGhpcy5jdXJyZW50UG9pbnQgKSApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLmxpbmVUbyggZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcblx0XHRcdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xyXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0Q3VydmVQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggc291cmNlLmN1cnJlbnRQb2ludCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBkYXRhID0gQ3VydmVQYXRoLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdFx0ZGF0YS5jdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0XHRDdXJ2ZVBhdGgucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFBvaW50LmZyb21BcnJheSgganNvbi5jdXJyZW50UG9pbnQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcblx0ICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxyXG5cdCAqKi9cclxuXHJcblx0Ly8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXHJcblx0Ly8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxyXG5cdC8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXHJcblx0Ly8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xyXG5cdC8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXHJcblxyXG5cdGZ1bmN0aW9uIFNoYXBlKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0UGF0aC5jYWxsKCB0aGlzLCBwb2ludHMgKTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xyXG5cclxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcclxuXHJcblx0fVxyXG5cclxuXHRTaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQYXRoLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFNoYXBlLFxyXG5cclxuXHRcdGdldFBvaW50c0hvbGVzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRcdHZhciBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gaG9sZXNQdHM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcclxuXHJcblx0XHRleHRyYWN0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXHJcblx0XHRcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHRQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdFx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBob2xlID0gc291cmNlLmhvbGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdHRoaXMuaG9sZXMucHVzaCggaG9sZS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSBQYXRoLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xyXG5cdFx0XHRkYXRhLmhvbGVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBob2xlID0gdGhpcy5ob2xlc1sgaSBdO1xyXG5cdFx0XHRcdGRhdGEuaG9sZXMucHVzaCggaG9sZS50b0pTT04oKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdFx0UGF0aC5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xyXG5cclxuXHRcdFx0dGhpcy51dWlkID0ganNvbi51dWlkO1xyXG5cdFx0XHR0aGlzLmhvbGVzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBob2xlID0ganNvbi5ob2xlc1sgaSBdO1xyXG5cdFx0XHRcdHRoaXMuaG9sZXMucHVzaCggbmV3IFBhdGgoKS5mcm9tSlNPTiggaG9sZSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0xpZ2h0JztcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xyXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCA/IGludGVuc2l0eSA6IDE7XHJcblxyXG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxuXHR9XHJcblxyXG5cdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IExpZ2h0LFxyXG5cclxuXHRcdGlzTGlnaHQ6IHRydWUsXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcclxuXHJcblx0XHRcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XHJcblx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xyXG5cclxuXHRcdFx0ZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cdFx0XHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5ncm91bmRDb2xvciAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XHJcblx0XHRcdGlmICggdGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xyXG5cdFx0XHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcclxuXHRcdFx0aWYgKCB0aGlzLnBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmE7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuc2hhZG93ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcclxuXHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBIZW1pc3BoZXJlTGlnaHQoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRcdExpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcclxuXHJcblx0XHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcclxuXHRcdHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBDb2xvciggZ3JvdW5kQ29sb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHRIZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogSGVtaXNwaGVyZUxpZ2h0LFxyXG5cclxuXHRcdGlzSGVtaXNwaGVyZUxpZ2h0OiB0cnVlLFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIExpZ2h0U2hhZG93KCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0dGhpcy5iaWFzID0gMDtcclxuXHRcdHRoaXMucmFkaXVzID0gMTtcclxuXHJcblx0XHR0aGlzLm1hcFNpemUgPSBuZXcgVmVjdG9yMiggNTEyLCA1MTIgKTtcclxuXHJcblx0XHR0aGlzLm1hcCA9IG51bGw7XHJcblx0XHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggTGlnaHRTaGFkb3cucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcclxuXHJcblx0XHRcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IHNvdXJjZS5yYWRpdXM7XHJcblxyXG5cdFx0XHR0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmJpYXMgIT09IDAgKSBvYmplY3QuYmlhcyA9IHRoaXMuYmlhcztcclxuXHRcdFx0aWYgKCB0aGlzLnJhZGl1cyAhPT0gMSApIG9iamVjdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcclxuXHRcdFx0aWYgKCB0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIgKSBvYmplY3QubWFwU2l6ZSA9IHRoaXMubWFwU2l6ZS50b0FycmF5KCk7XHJcblxyXG5cdFx0XHRvYmplY3QuY2FtZXJhID0gdGhpcy5jYW1lcmEudG9KU09OKCBmYWxzZSApLm9iamVjdDtcclxuXHRcdFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xyXG5cclxuXHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gU3BvdExpZ2h0U2hhZG93KCkge1xyXG5cclxuXHRcdExpZ2h0U2hhZG93LmNhbGwoIHRoaXMsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRTcG90TGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogU3BvdExpZ2h0U2hhZG93LFxyXG5cclxuXHRcdGlzU3BvdExpZ2h0U2hhZG93OiB0cnVlLFxyXG5cclxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCBsaWdodCApIHtcclxuXHJcblx0XHRcdHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHJcblx0XHRcdHZhciBmb3YgPSBfTWF0aC5SQUQyREVHICogMiAqIGxpZ2h0LmFuZ2xlO1xyXG5cdFx0XHR2YXIgYXNwZWN0ID0gdGhpcy5tYXBTaXplLndpZHRoIC8gdGhpcy5tYXBTaXplLmhlaWdodDtcclxuXHRcdFx0dmFyIGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XHJcblxyXG5cdFx0XHRpZiAoIGZvdiAhPT0gY2FtZXJhLmZvdiB8fCBhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgfHwgZmFyICE9PSBjYW1lcmEuZmFyICkge1xyXG5cclxuXHRcdFx0XHRjYW1lcmEuZm92ID0gZm92O1xyXG5cdFx0XHRcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XHJcblx0XHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcclxuXHRcdFx0XHRjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBTcG90TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBhbmdsZSwgcGVudW1icmEsIGRlY2F5ICkge1xyXG5cclxuXHRcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xyXG5cclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxyXG5cdFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogTWF0aC5QSTtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCBwb3dlciApIHtcclxuXHJcblx0XHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxyXG5cdFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXHJcblx0XHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvIE1hdGguUEk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xyXG5cdFx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcclxuXHRcdHRoaXMucGVudW1icmEgPSAoIHBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSA/IHBlbnVtYnJhIDogMDtcclxuXHRcdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cclxuXHJcblx0XHR0aGlzLnNoYWRvdyA9IG5ldyBTcG90TGlnaHRTaGFkb3coKTtcclxuXHJcblx0fVxyXG5cclxuXHRTcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogU3BvdExpZ2h0LFxyXG5cclxuXHRcdGlzU3BvdExpZ2h0OiB0cnVlLFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xyXG5cdFx0XHR0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xyXG5cdFx0XHR0aGlzLnBlbnVtYnJhID0gc291cmNlLnBlbnVtYnJhO1xyXG5cdFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xyXG5cclxuXHRcdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XHJcblxyXG5cdFx0XHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gUG9pbnRMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlY2F5ICkge1xyXG5cclxuXHRcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUG9pbnRMaWdodCc7XHJcblxyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncG93ZXInLCB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXHJcblx0XHRcdFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTUpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiA0ICogTWF0aC5QSTtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCBwb3dlciApIHtcclxuXHJcblx0XHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxyXG5cdFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXHJcblx0XHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvICggNCAqIE1hdGguUEkgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0gKTtcclxuXHJcblx0XHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XHJcblx0XHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXHJcblxyXG5cdFx0dGhpcy5zaGFkb3cgPSBuZXcgTGlnaHRTaGFkb3coIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggOTAsIDEsIDAuNSwgNTAwICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRQb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFBvaW50TGlnaHQsXHJcblxyXG5cdFx0aXNQb2ludExpZ2h0OiB0cnVlLFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xyXG5cdFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xyXG5cclxuXHRcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyggKSB7XHJcblxyXG5cdFx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHREaXJlY3Rpb25hbExpZ2h0U2hhZG93LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0U2hhZG93LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHRTaGFkb3dcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XHJcblxyXG5cdFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xyXG5cclxuXHRcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcclxuXHJcblx0fVxyXG5cclxuXHREaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHQsXHJcblxyXG5cdFx0aXNEaXJlY3Rpb25hbExpZ2h0OiB0cnVlLFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcclxuXHJcblx0XHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEFtYmllbnRMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0XHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XHJcblxyXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xyXG5cclxuXHR9XHJcblxyXG5cdEFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBBbWJpZW50TGlnaHQsXHJcblxyXG5cdFx0aXNBbWJpZW50TGlnaHQ6IHRydWVcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFJlY3RBcmVhTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdSZWN0QXJlYUxpZ2h0JztcclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xyXG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0XHR0aGlzLndpZHRoID0gKCB3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyB3aWR0aCA6IDEwO1xyXG5cdFx0dGhpcy5oZWlnaHQgPSAoIGhlaWdodCAhPT0gdW5kZWZpbmVkICkgPyBoZWlnaHQgOiAxMDtcclxuXHJcblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogZGlzdGFuY2UvZGVjYXlcclxuXHJcblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogdXBkYXRlIG1ldGhvZCBmb3IgUmVjdEFyZWFMaWdodCB0byB1cGRhdGUgdHJhbnNmb3JtIHRvIGxvb2thdCB0YXJnZXRcclxuXHJcblx0XHQvLyBUT0RPIChhYmVsbmF0aW9uKTogc2hhZG93c1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IHVwZGF0ZSB3aGVuIGxpZ2h0IHNoYXBlIGlzIGNoYW5nZWRcclxuXHRSZWN0QXJlYUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFJlY3RBcmVhTGlnaHQsXHJcblxyXG5cdFx0aXNSZWN0QXJlYUxpZ2h0OiB0cnVlLFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xyXG5cdFx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSBMaWdodC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcclxuXHJcblx0XHRcdGRhdGEub2JqZWN0LndpZHRoID0gdGhpcy53aWR0aDtcclxuXHRcdFx0ZGF0YS5vYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBBIFRyYWNrIHRoYXQgaW50ZXJwb2xhdGVzIFN0cmluZ3NcclxuXHQgKlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFN0cmluZ0tleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0U3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFN0cmluZ0tleWZyYW1lVHJhY2ssXHJcblxyXG5cdFx0VmFsdWVUeXBlTmFtZTogJ3N0cmluZycsXHJcblx0XHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxyXG5cclxuXHRcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxyXG5cclxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxyXG5cclxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBBIFRyYWNrIG9mIEJvb2xlYW4ga2V5ZnJhbWUgdmFsdWVzLlxyXG5cdCAqXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQm9vbGVhbktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzICk7XHJcblxyXG5cdH1cclxuXHJcblx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBCb29sZWFuS2V5ZnJhbWVUcmFjayxcclxuXHJcblx0XHRWYWx1ZVR5cGVOYW1lOiAnYm9vbCcsXHJcblx0XHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxyXG5cclxuXHRcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxyXG5cclxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxyXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWRcclxuXHJcblx0XHQvLyBOb3RlOiBBY3R1YWxseSB0aGlzIHRyYWNrIGNvdWxkIGhhdmUgYSBvcHRpbWl6ZWQgLyBjb21wcmVzc2VkXHJcblx0XHQvLyByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSB2YWx1ZSBhbmQgYSBjdXN0b20gaW50ZXJwb2xhbnQgdGhhdFxyXG5cdFx0Ly8gY29tcHV0ZXMgXCJmaXJzdFZhbHVlIF4gaXNPZGQoIGluZGV4IClcIi5cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIG9mIGludGVycG9sYW50cyBvdmVyIHBhcmFtZXRyaWMgc2FtcGxlcy5cclxuXHQgKlxyXG5cdCAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxyXG5cdCAqIGFsb25nIGEgY3VydmUgZGVmaW5lZCBieSB0aGUgZGF0YS5cclxuXHQgKlxyXG5cdCAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxyXG5cdCAqIGFwcGx5IHNwZWNpYWwgaW50ZXJwcmV0YXRpb25zIHRvIHRoZSBkYXRhLlxyXG5cdCAqXHJcblx0ICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXHJcblx0ICogdGhlIGFjdHVhbCBpbnRlcnBvbGF0aW9uIHRvIGRlcml2ZWQgY2xhc3Nlcy5cclxuXHQgKlxyXG5cdCAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xyXG5cdCAqIGFuZCBPKGxvZyBOKSBmb3IgcmFuZG9tIGFjY2Vzcywgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucy5cclxuXHQgKlxyXG5cdCAqIFJlZmVyZW5jZXM6XHJcblx0ICpcclxuXHQgKiBcdFx0aHR0cDovL3d3dy5vb2Rlc2lnbi5jb20vdGVtcGxhdGUtbWV0aG9kLXBhdHRlcm4uaHRtbFxyXG5cdCAqXHJcblx0ICogQGF1dGhvciB0c2Nod1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcclxuXHJcblx0XHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcclxuXHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcclxuXHJcblx0XHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0cmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3Rvciggc2FtcGxlU2l6ZSApO1xyXG5cdFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XHJcblx0XHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggSW50ZXJwb2xhbnQucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0ZXZhbHVhdGU6IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRcdGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXHJcblxyXG5cdFx0XHRcdHQxID0gcHBbIGkxIF0sXHJcblx0XHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XHJcblxyXG5cdFx0XHR2YWxpZGF0ZV9pbnRlcnZhbDoge1xyXG5cclxuXHRcdFx0XHRzZWVrOiB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHJpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGxpbmVhcl9zY2FuOiB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLy0gU2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbXBhcmlzb24tdG8tdW5kZWZpbmVkLzNcclxuXHRcdFx0XHRcdFx0Ly8tIHNsb3dlciBjb2RlOlxyXG5cdFx0XHRcdFx0XHQvLy1cclxuXHRcdFx0XHRcdFx0Ly8tIFx0XHRcdFx0aWYgKCB0ID49IHQxIHx8IHQxID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRcdGZvcndhcmRfc2NhbjogaWYgKCAhICggdCA8IHQxICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxICsgMjsgOyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MCApIGJyZWFrIGZvcndhcmRfc2NhbjtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFmdGVyIGVuZFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aTEgPSBwcC5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRW5kXyggaTEgLSAxLCB0LCB0MCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR0MCA9IHQxO1xyXG5cdFx0XHRcdFx0XHRcdFx0dDEgPSBwcFsgKysgaTEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcclxuXHRcdFx0XHRcdFx0XHRyaWdodCA9IHBwLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0XHRicmVhayBsaW5lYXJfc2NhbjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vLSBzbG93ZXIgY29kZTpcclxuXHRcdFx0XHRcdFx0Ly8tXHRcdFx0XHRcdGlmICggdCA8IHQwIHx8IHQwID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggISAoIHQgPj0gdDAgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gbG9vcGluZz9cclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHQxZ2xvYmFsID0gcHBbIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDFnbG9iYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xyXG5cdFx0XHRcdFx0XHRcdFx0dDAgPSB0MWdsb2JhbDtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBnaXZlVXBBdCA9IGkxIC0gMjsgOyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR0MSA9IHQwO1xyXG5cdFx0XHRcdFx0XHRcdFx0dDAgPSBwcFsgLS0gaTEgLSAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0ID49IHQwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XHJcblx0XHRcdFx0XHRcdFx0cmlnaHQgPSBpMTtcclxuXHRcdFx0XHRcdFx0XHRpMSA9IDA7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xyXG5cclxuXHRcdFx0XHRcdH0gLy8gbGluZWFyIHNjYW5cclxuXHJcblx0XHRcdFx0XHQvLyBiaW5hcnkgc2VhcmNoXHJcblxyXG5cdFx0XHRcdFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1pZCA9ICggaTEgKyByaWdodCApID4+PiAxO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0IDwgcHBbIG1pZCBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyaWdodCA9IG1pZDtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGkxID0gbWlkICsgMTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dDEgPSBwcFsgaTEgXTtcclxuXHRcdFx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxyXG5cclxuXHRcdFx0XHRcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQwLCB0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IC8vIHNlZWtcclxuXHJcblx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcclxuXHJcblx0XHRcdFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XHJcblxyXG5cdFx0XHR9IC8vIHZhbGlkYXRlX2ludGVydmFsXHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldHRpbmdzOiBudWxsLCAvLyBvcHRpb25hbCwgc3ViY2xhc3Mtc3BlY2lmaWMgc2V0dGluZ3Mgc3RydWN0dXJlXHJcblx0XHQvLyBOb3RlOiBUaGUgaW5kaXJlY3Rpb24gYWxsb3dzIGNlbnRyYWwgY29udHJvbCBvZiBtYW55IGludGVycG9sYW50cy5cclxuXHJcblx0XHQvLyAtLS0gUHJvdGVjdGVkIGludGVyZmFjZVxyXG5cclxuXHRcdERlZmF1bHRTZXR0aW5nc186IHt9LFxyXG5cclxuXHRcdGdldFNldHRpbmdzXzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0dGluZ3MgfHwgdGhpcy5EZWZhdWx0U2V0dGluZ3NfO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weVNhbXBsZVZhbHVlXzogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRcdC8vIGNvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlclxyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cdFx0XHRcdG9mZnNldCA9IGluZGV4ICogc3RyaWRlO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gVGVtcGxhdGUgbWV0aG9kcyBmb3IgZGVyaXZlZCBjbGFzc2VzOlxyXG5cclxuXHRcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCAvKiBpMSwgdDAsIHQsIHQxICovICkge1xyXG5cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnY2FsbCB0byBhYnN0cmFjdCBtZXRob2QnICk7XHJcblx0XHRcdC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uICggLyogaTEsIHQwLCB0MSAqLyApIHtcclxuXHJcblx0XHRcdC8vIGVtcHR5XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8vIVxcIERFQ0xBUkUgQUxJQVMgQUZURVIgYXNzaWduIHByb3RvdHlwZSAhXHJcblx0T2JqZWN0LmFzc2lnbiggSW50ZXJwb2xhbnQucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Ly8oIDAsIHQsIHQwICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcclxuXHRcdGJlZm9yZVN0YXJ0XzogSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sXHJcblxyXG5cdFx0Ly8oIE4tMSwgdE4tMSwgdCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXHJcblx0XHRhZnRlckVuZF86IEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfLFxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNwaGVyaWNhbCBsaW5lYXIgdW5pdCBxdWF0ZXJuaW9uIGludGVycG9sYW50LlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciB0c2Nod1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XHJcblxyXG5cdFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQsXHJcblxyXG5cdFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXHJcblx0XHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXHJcblx0XHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IGkxICogc3RyaWRlLFxyXG5cclxuXHRcdFx0XHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBlbmQgPSBvZmZzZXQgKyBzdHJpZGU7IG9mZnNldCAhPT0gZW5kOyBvZmZzZXQgKz0gNCApIHtcclxuXHJcblx0XHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIHJlc3VsdCwgMCwgdmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xyXG5cclxuXHRcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xyXG5cclxuXHR9XHJcblxyXG5cdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFx0VmFsdWVUeXBlTmFtZTogJ3F1YXRlcm5pb24nLFxyXG5cclxuXHRcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcclxuXHJcblx0XHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVMaW5lYXIsXHJcblxyXG5cdFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZCAvLyBub3QgeWV0IGltcGxlbWVudGVkXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cclxuXHQgKlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIENvbG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHRDb2xvcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBDb2xvcktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFx0VmFsdWVUeXBlTmFtZTogJ2NvbG9yJ1xyXG5cclxuXHRcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcclxuXHJcblx0XHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcblx0XHQvLyBOb3RlOiBWZXJ5IGJhc2ljIGltcGxlbWVudGF0aW9uIGFuZCBub3RoaW5nIHNwZWNpYWwgeWV0LlxyXG5cdFx0Ly8gSG93ZXZlciwgdGhpcyBpcyB0aGUgcGxhY2UgZm9yIGNvbG9yIHNwYWNlIHBhcmFtZXRlcml6YXRpb24uXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBBIFRyYWNrIG9mIG51bWVyaWMga2V5ZnJhbWUgdmFsdWVzLlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE51bWJlcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XHJcblxyXG5cdH1cclxuXHJcblx0TnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IE51bWJlcktleWZyYW1lVHJhY2ssXHJcblxyXG5cdFx0VmFsdWVUeXBlTmFtZTogJ251bWJlcidcclxuXHJcblx0XHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXHJcblxyXG5cdFx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogRmFzdCBhbmQgc2ltcGxlIGN1YmljIHNwbGluZSBpbnRlcnBvbGFudC5cclxuXHQgKlxyXG5cdCAqIEl0IHdhcyBkZXJpdmVkIGZyb20gYSBIZXJtaXRpYW4gY29uc3RydWN0aW9uIHNldHRpbmcgdGhlIGZpcnN0IGRlcml2YXRpdmVcclxuXHQgKiBhdCBlYWNoIHNhbXBsZSBwb3NpdGlvbiB0byB0aGUgbGluZWFyIHNsb3BlIGJldHdlZW4gbmVpZ2hib3JpbmcgcG9zaXRpb25zXHJcblx0ICogb3ZlciB0aGVpciBwYXJhbWV0ZXIgaW50ZXJ2YWwuXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEN1YmljSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XHJcblxyXG5cdFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHRcdHRoaXMuX3dlaWdodFByZXYgPSAtIDA7XHJcblx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gLSAwO1xyXG5cdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0gMDtcclxuXHRcdHRoaXMuX29mZnNldE5leHQgPSAtIDA7XHJcblxyXG5cdH1cclxuXHJcblx0Q3ViaWNJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBDdWJpY0ludGVycG9sYW50LFxyXG5cclxuXHRcdERlZmF1bHRTZXR0aW5nc186IHtcclxuXHJcblx0XHRcdGVuZGluZ1N0YXJ0OiBaZXJvQ3VydmF0dXJlRW5kaW5nLFxyXG5cdFx0XHRlbmRpbmdFbmQ6IFplcm9DdXJ2YXR1cmVFbmRpbmdcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uICggaTEsIHQwLCB0MSApIHtcclxuXHJcblx0XHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRcdGlQcmV2ID0gaTEgLSAyLFxyXG5cdFx0XHRcdGlOZXh0ID0gaTEgKyAxLFxyXG5cclxuXHRcdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxyXG5cdFx0XHRcdHROZXh0ID0gcHBbIGlOZXh0IF07XHJcblxyXG5cdFx0XHRpZiAoIHRQcmV2ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBmJyh0MCkgPSAwXHJcblx0XHRcdFx0XHRcdGlQcmV2ID0gaTE7XHJcblx0XHRcdFx0XHRcdHRQcmV2ID0gMiAqIHQwIC0gdDE7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcclxuXHRcdFx0XHRcdFx0aVByZXYgPSBwcC5sZW5ndGggLSAyO1xyXG5cdFx0XHRcdFx0XHR0UHJldiA9IHQwICsgcHBbIGlQcmV2IF0gLSBwcFsgaVByZXYgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBmJycodDApID0gMCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcclxuXHRcdFx0XHRcdFx0aVByZXYgPSBpMTtcclxuXHRcdFx0XHRcdFx0dFByZXYgPSB0MTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0TmV4dCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCApIHtcclxuXHJcblx0XHRcdFx0XHRjYXNlIFplcm9TbG9wZUVuZGluZzpcclxuXHJcblx0XHRcdFx0XHRcdC8vIGYnKHROKSA9IDBcclxuXHRcdFx0XHRcdFx0aU5leHQgPSBpMTtcclxuXHRcdFx0XHRcdFx0dE5leHQgPSAyICogdDEgLSB0MDtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcclxuXHJcblx0XHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxyXG5cdFx0XHRcdFx0XHRpTmV4dCA9IDE7XHJcblx0XHRcdFx0XHRcdHROZXh0ID0gdDEgKyBwcFsgMSBdIC0gcHBbIDAgXTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcclxuXHJcblx0XHRcdFx0XHRcdC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcclxuXHRcdFx0XHRcdFx0aU5leHQgPSBpMSAtIDE7XHJcblx0XHRcdFx0XHRcdHROZXh0ID0gdDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBoYWxmRHQgPSAoIHQxIC0gdDAgKSAqIDAuNSxcclxuXHRcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcclxuXHJcblx0XHRcdHRoaXMuX3dlaWdodFByZXYgPSBoYWxmRHQgLyAoIHQwIC0gdFByZXYgKTtcclxuXHRcdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IGhhbGZEdCAvICggdE5leHQgLSB0MSApO1xyXG5cdFx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XHJcblx0XHRcdHRoaXMuX29mZnNldE5leHQgPSBpTmV4dCAqIHN0cmlkZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cclxuXHRcdFx0XHRvMSA9IGkxICogc3RyaWRlLFx0XHRvMCA9IG8xIC0gc3RyaWRlLFxyXG5cdFx0XHRcdG9QID0gdGhpcy5fb2Zmc2V0UHJldiwgXHRvTiA9IHRoaXMuX29mZnNldE5leHQsXHJcblx0XHRcdFx0d1AgPSB0aGlzLl93ZWlnaHRQcmV2LFx0d04gPSB0aGlzLl93ZWlnaHROZXh0LFxyXG5cclxuXHRcdFx0XHRwID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxyXG5cdFx0XHRcdHBwID0gcCAqIHAsXHJcblx0XHRcdFx0cHBwID0gcHAgKiBwO1xyXG5cclxuXHRcdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcclxuXHJcblx0XHRcdHZhciBzUCA9IC0gd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcclxuXHRcdFx0dmFyIHMwID0gKCAxICsgd1AgKSAqIHBwcCArICggLSAxLjUgLSAyICogd1AgKSAqIHBwICsgKCAtIDAuNSArIHdQICkgKiBwICsgMTtcclxuXHRcdFx0dmFyIHMxID0gKCAtIDEgLSB3TiApICogcHBwICsgKCAxLjUgKyB3TiApICogcHAgKyAwLjUgKiBwO1xyXG5cdFx0XHR2YXIgc04gPSB3TiAqIHBwcCAtIHdOICogcHA7XHJcblxyXG5cdFx0XHQvLyBjb21iaW5lIGRhdGEgbGluZWFybHlcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRyZXN1bHRbIGkgXSA9XHJcblx0XHRcdFx0XHRcdHNQICogdmFsdWVzWyBvUCArIGkgXSArXHJcblx0XHRcdFx0XHRcdHMwICogdmFsdWVzWyBvMCArIGkgXSArXHJcblx0XHRcdFx0XHRcdHMxICogdmFsdWVzWyBvMSArIGkgXSArXHJcblx0XHRcdFx0XHRcdHNOICogdmFsdWVzWyBvTiArIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gTGluZWFySW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XHJcblxyXG5cdFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdExpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IExpbmVhckludGVycG9sYW50LFxyXG5cclxuXHRcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xyXG5cclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxyXG5cdFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxyXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cclxuXHRcdFx0XHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXHJcblx0XHRcdFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXHJcblxyXG5cdFx0XHRcdHdlaWdodDEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXHJcblx0XHRcdFx0d2VpZ2h0MCA9IDEgLSB3ZWlnaHQxO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdFsgaSBdID1cclxuXHRcdFx0XHRcdFx0dmFsdWVzWyBvZmZzZXQwICsgaSBdICogd2VpZ2h0MCArXHJcblx0XHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZWRpbmdcclxuXHQgKiB0aGUgcGFyYW1ldGVyLlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciB0c2Nod1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBEaXNjcmV0ZUludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xyXG5cclxuXHRcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHREaXNjcmV0ZUludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IERpc2NyZXRlSW50ZXJwb2xhbnQsXHJcblxyXG5cdFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxIC8qLCB0MCwgdCwgdDEgKi8gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB0c2Nod1xyXG5cdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcblx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXHJcblx0ICovXHJcblxyXG5cdHZhciBBbmltYXRpb25VdGlscyA9IHtcclxuXHJcblx0XHQvLyBzYW1lIGFzIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IGFsc28gd29ya3Mgb24gdHlwZWQgYXJyYXlzXHJcblx0XHRhcnJheVNsaWNlOiBmdW5jdGlvbiAoIGFycmF5LCBmcm9tLCB0byApIHtcclxuXHJcblx0XHRcdGlmICggQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCBhcnJheSApICkge1xyXG5cclxuXHRcdFx0XHQvLyBpbiBpb3M5IGFycmF5LnN1YmFycmF5KGZyb20sIHVuZGVmaW5lZCkgd2lsbCByZXR1cm4gZW1wdHkgYXJyYXlcclxuXHRcdFx0XHQvLyBidXQgYXJyYXkuc3ViYXJyYXkoZnJvbSkgb3IgYXJyYXkuc3ViYXJyYXkoZnJvbSwgbGVuKSBpcyBjb3JyZWN0XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBhcnJheS5jb25zdHJ1Y3RvciggYXJyYXkuc3ViYXJyYXkoIGZyb20sIHRvICE9PSB1bmRlZmluZWQgPyB0byA6IGFycmF5Lmxlbmd0aCApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYXJyYXkuc2xpY2UoIGZyb20sIHRvICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjb252ZXJ0cyBhbiBhcnJheSB0byBhIHNwZWNpZmljIHR5cGVcclxuXHRcdGNvbnZlcnRBcnJheTogZnVuY3Rpb24gKCBhcnJheSwgdHlwZSwgZm9yY2VDbG9uZSApIHtcclxuXHJcblx0XHRcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXHJcblx0XHRcdFx0XHQhIGZvcmNlQ2xvbmUgJiYgYXJyYXkuY29uc3RydWN0b3IgPT09IHR5cGUgKSByZXR1cm4gYXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG5ldyB0eXBlKCBhcnJheSApOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTsgLy8gY3JlYXRlIEFycmF5XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpc1R5cGVkQXJyYXk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiZcclxuXHRcdFx0XHRcdCEgKCBvYmplY3QgaW5zdGFuY2VvZiBEYXRhVmlldyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcmV0dXJucyBhbiBhcnJheSBieSB3aGljaCB0aW1lcyBhbmQgdmFsdWVzIGNhbiBiZSBzb3J0ZWRcclxuXHRcdGdldEtleWZyYW1lT3JkZXI6IGZ1bmN0aW9uICggdGltZXMgKSB7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBjb21wYXJlVGltZSggaSwgaiApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIG4gPSB0aW1lcy5sZW5ndGg7XHJcblx0XHRcdHZhciByZXN1bHQgPSBuZXcgQXJyYXkoIG4gKTtcclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkgcmVzdWx0WyBpIF0gPSBpO1xyXG5cclxuXHRcdFx0cmVzdWx0LnNvcnQoIGNvbXBhcmVUaW1lICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXHJcblx0XHRzb3J0ZWRBcnJheTogZnVuY3Rpb24gKCB2YWx1ZXMsIHN0cmlkZSwgb3JkZXIgKSB7XHJcblxyXG5cdFx0XHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XHJcblx0XHRcdHZhciByZXN1bHQgPSBuZXcgdmFsdWVzLmNvbnN0cnVjdG9yKCBuVmFsdWVzICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdHJlc3VsdFsgZHN0T2Zmc2V0ICsrIF0gPSB2YWx1ZXNbIHNyY09mZnNldCArIGogXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGZ1bmN0aW9uIGZvciBwYXJzaW5nIEFPUyBrZXlmcmFtZSBmb3JtYXRzXHJcblx0XHRmbGF0dGVuSlNPTjogZnVuY3Rpb24gKCBqc29uS2V5cywgdGltZXMsIHZhbHVlcywgdmFsdWVQcm9wZXJ0eU5hbWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaSA9IDEsIGtleSA9IGpzb25LZXlzWyAwIF07XHJcblxyXG5cdFx0XHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxyXG5cclxuXHRcdFx0dmFyIHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xyXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcclxuXHJcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcclxuXHJcblx0XHRcdFx0ZG8ge1xyXG5cclxuXHRcdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoLmFwcGx5KCB2YWx1ZXMsIHZhbHVlICk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XHJcblxyXG5cdFx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcclxuXHJcblx0XHRcdFx0ZG8ge1xyXG5cclxuXHRcdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XHJcblx0XHRcdFx0XHRcdHZhbHVlLnRvQXJyYXkoIHZhbHVlcywgdmFsdWVzLmxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xyXG5cclxuXHRcdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIG90aGVyd2lzZSBwdXNoIGFzLWlzXHJcblxyXG5cdFx0XHRcdGRvIHtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcclxuXHJcblx0XHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEEgdGltZWQgc2VxdWVuY2Ugb2Yga2V5ZnJhbWVzIGZvciBhIHNwZWNpZmljIHByb3BlcnR5LlxyXG5cdCAqXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkJyApO1xyXG5cdFx0aWYgKCB0aW1lcyA9PT0gdW5kZWZpbmVkIHx8IHRpbWVzLmxlbmd0aCA9PT0gMCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IG5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCAnICsgbmFtZSApO1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblxyXG5cdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdGltZXMsIHRoaXMuVGltZUJ1ZmZlclR5cGUgKTtcclxuXHRcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XHJcblxyXG5cdFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcclxuXHJcblx0XHR0aGlzLnZhbGlkYXRlKCk7XHJcblx0XHR0aGlzLm9wdGltaXplKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU3RhdGljIG1ldGhvZHM6XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEtleWZyYW1lVHJhY2ssIHtcclxuXHJcblx0XHQvLyBTZXJpYWxpemF0aW9uIChpbiBzdGF0aWMgY29udGV4dCwgYmVjYXVzZSBvZiBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uXHJcblx0XHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XHJcblxyXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRcdGlmICgganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRyYWNrVHlwZSA9IEtleWZyYW1lVHJhY2suX2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0aW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oIGpzb24ua2V5cywgdGltZXMsIHZhbHVlcywgJ3ZhbHVlJyApO1xyXG5cclxuXHRcdFx0XHRqc29uLnRpbWVzID0gdGltZXM7XHJcblx0XHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyBwYXJzZSBtZXRob2RcclxuXHRcdFx0aWYgKCB0cmFja1R5cGUucGFyc2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXHJcblx0XHRcdFx0cmV0dXJuIG5ldyB0cmFja1R5cGUoIGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9KU09OOiBmdW5jdGlvbiAoIHRyYWNrICkge1xyXG5cclxuXHRcdFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xyXG5cclxuXHRcdFx0dmFyIGpzb247XHJcblxyXG5cdFx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXHJcblx0XHRcdGlmICggdHJhY2tUeXBlLnRvSlNPTiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRqc29uID0gdHJhY2tUeXBlLnRvSlNPTiggdHJhY2sgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSB0aGUgZGF0YSBjYW4gYmUgc2VyaWFsaXplZCBhcy1pc1xyXG5cdFx0XHRcdGpzb24gPSB7XHJcblxyXG5cdFx0XHRcdFx0J25hbWUnOiB0cmFjay5uYW1lLFxyXG5cdFx0XHRcdFx0J3RpbWVzJzogQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcclxuXHRcdFx0XHRcdCd2YWx1ZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnZhbHVlcywgQXJyYXkgKVxyXG5cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR2YXIgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRqc29uLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRqc29uLnR5cGUgPSB0cmFjay5WYWx1ZVR5cGVOYW1lOyAvLyBtYW5kYXRvcnlcclxuXHJcblx0XHRcdHJldHVybiBqc29uO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0X2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWU6IGZ1bmN0aW9uICggdHlwZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xyXG5cclxuXHRcdFx0XHRjYXNlICdzY2FsYXInOlxyXG5cdFx0XHRcdGNhc2UgJ2RvdWJsZSc6XHJcblx0XHRcdFx0Y2FzZSAnZmxvYXQnOlxyXG5cdFx0XHRcdGNhc2UgJ251bWJlcic6XHJcblx0XHRcdFx0Y2FzZSAnaW50ZWdlcic6XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIE51bWJlcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ3ZlY3Rvcic6XHJcblx0XHRcdFx0Y2FzZSAndmVjdG9yMic6XHJcblx0XHRcdFx0Y2FzZSAndmVjdG9yMyc6XHJcblx0XHRcdFx0Y2FzZSAndmVjdG9yNCc6XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIFZlY3RvcktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2NvbG9yJzpcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gQ29sb3JLZXlmcmFtZVRyYWNrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdxdWF0ZXJuaW9uJzpcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ2Jvb2wnOlxyXG5cdFx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnc3RyaW5nJzpcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFVuc3VwcG9ydGVkIHR5cGVOYW1lOiAnICsgdHlwZU5hbWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogS2V5ZnJhbWVUcmFjayxcclxuXHJcblx0XHRUaW1lQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxyXG5cclxuXHRcdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxyXG5cclxuXHRcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZUxpbmVhcixcclxuXHJcblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTogZnVuY3Rpb24gKCByZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24gKCByZXN1bHQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjdG9yeU1ldGhvZDtcclxuXHJcblx0XHRcdHN3aXRjaCAoIGludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgSW50ZXJwb2xhdGVEaXNjcmV0ZTpcclxuXHJcblx0XHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTtcclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZUxpbmVhcjpcclxuXHJcblx0XHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XHJcblxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdGNhc2UgSW50ZXJwb2xhdGVTbW9vdGg6XHJcblxyXG5cdFx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoO1xyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtZXNzYWdlID0gXCJ1bnN1cHBvcnRlZCBpbnRlcnBvbGF0aW9uIGZvciBcIiArXHJcblx0XHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyBcIiBrZXlmcmFtZSB0cmFjayBuYW1lZCBcIiArIHRoaXMubmFtZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZmFsbCBiYWNrIHRvIGRlZmF1bHQsIHVubGVzcyB0aGUgZGVmYXVsdCBpdHNlbGYgaXMgbWVzc2VkIHVwXHJcblx0XHRcdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7IC8vIGZhdGFsLCBpbiB0aGlzIGNhc2VcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRzd2l0Y2ggKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ICkge1xyXG5cclxuXHRcdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlRGlzY3JldGU7XHJcblxyXG5cdFx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIEludGVycG9sYXRlTGluZWFyO1xyXG5cclxuXHRcdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZVNtb290aDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFZhbHVlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAvIHRoaXMudGltZXMubGVuZ3RoO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gbW92ZSBhbGwga2V5ZnJhbWVzIGVpdGhlciBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGltZVxyXG5cdFx0c2hpZnQ6IGZ1bmN0aW9uICggdGltZU9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggdGltZU9mZnNldCAhPT0gMC4wICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSA8LT4gc2Vjb25kcyBjb252ZXJzaW9ucylcclxuXHRcdHNjYWxlOiBmdW5jdGlvbiAoIHRpbWVTY2FsZSApIHtcclxuXHJcblx0XHRcdGlmICggdGltZVNjYWxlICE9PSAxLjAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cclxuXHRcdC8vIElNUE9SVEFOVDogV2UgZG8gbm90IHNoaWZ0IGFyb3VuZCBrZXlzIHRvIHRoZSBzdGFydCBvZiB0aGUgdHJhY2sgdGltZSwgYmVjYXVzZSBmb3IgaW50ZXJwb2xhdGVkIGtleXMgdGhpcyB3aWxsIGNoYW5nZSB0aGVpciB2YWx1ZXNcclxuXHRcdHRyaW06IGZ1bmN0aW9uICggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xyXG5cclxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcclxuXHRcdFx0XHRuS2V5cyA9IHRpbWVzLmxlbmd0aCxcclxuXHRcdFx0XHRmcm9tID0gMCxcclxuXHRcdFx0XHR0byA9IG5LZXlzIC0gMTtcclxuXHJcblx0XHRcdHdoaWxlICggZnJvbSAhPT0gbktleXMgJiYgdGltZXNbIGZyb20gXSA8IHN0YXJ0VGltZSApIHtcclxuXHJcblx0XHRcdFx0KysgZnJvbTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdoaWxlICggdG8gIT09IC0gMSAmJiB0aW1lc1sgdG8gXSA+IGVuZFRpbWUgKSB7XHJcblxyXG5cdFx0XHRcdC0tIHRvO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0KysgdG87IC8vIGluY2x1c2l2ZSAtPiBleGNsdXNpdmUgYm91bmRcclxuXHJcblx0XHRcdGlmICggZnJvbSAhPT0gMCB8fCB0byAhPT0gbktleXMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxyXG5cdFx0XHRcdGlmICggZnJvbSA+PSB0byApIHRvID0gTWF0aC5tYXgoIHRvLCAxICksIGZyb20gPSB0byAtIDE7XHJcblxyXG5cdFx0XHRcdHZhciBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xyXG5cdFx0XHRcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgZnJvbSwgdG8gKTtcclxuXHRcdFx0XHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRoaXMudmFsdWVzLCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBlbnN1cmUgd2UgZG8gbm90IGdldCBhIEdhcmJhZ2VJbkdhcmJhZ2VPdXQgc2l0dWF0aW9uLCBtYWtlIHN1cmUgdHJhY2tzIGFyZSBhdCBsZWFzdCBtaW5pbWFsbHkgdmlhYmxlXHJcblx0XHR2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHZhbGlkID0gdHJ1ZTtcclxuXHJcblx0XHRcdHZhciB2YWx1ZVNpemUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xyXG5cdFx0XHRpZiAoIHZhbHVlU2l6ZSAtIE1hdGguZmxvb3IoIHZhbHVlU2l6ZSApICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogSW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrLicsIHRoaXMgKTtcclxuXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcclxuXHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcclxuXHJcblx0XHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIG5LZXlzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuJywgdGhpcyApO1xyXG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcHJldlRpbWUgPSBudWxsO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuS2V5czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGN1cnJUaW1lID0gdGltZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB0eXBlb2YgY3VyclRpbWUgPT09ICdudW1iZXInICYmIGlzTmFOKCBjdXJyVGltZSApICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCBjdXJyVGltZSApO1xyXG5cdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogT3V0IG9mIG9yZGVyIGtleXMuJywgdGhpcywgaSwgY3VyclRpbWUsIHByZXZUaW1lICk7XHJcblx0XHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cHJldlRpbWUgPSBjdXJyVGltZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCB2YWx1ZXMgKSApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB2YWxpZDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgYXMgY29tbW9uIGluIG1vcnBoIHRhcmdldCBzZXF1ZW5jZXNcclxuXHRcdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXHJcblx0XHRvcHRpbWl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcclxuXHRcdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcclxuXHRcdFx0XHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxyXG5cclxuXHRcdFx0XHRzbW9vdGhJbnRlcnBvbGF0aW9uID0gdGhpcy5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IEludGVycG9sYXRlU21vb3RoLFxyXG5cclxuXHRcdFx0XHR3cml0ZUluZGV4ID0gMSxcclxuXHRcdFx0XHRsYXN0SW5kZXggPSB0aW1lcy5sZW5ndGggLSAxO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAxOyBpIDwgbGFzdEluZGV4OyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIga2VlcCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR2YXIgdGltZSA9IHRpbWVzWyBpIF07XHJcblx0XHRcdFx0dmFyIHRpbWVOZXh0ID0gdGltZXNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcclxuXHJcblx0XHRcdFx0aWYgKCB0aW1lICE9PSB0aW1lTmV4dCAmJiAoIGkgIT09IDEgfHwgdGltZSAhPT0gdGltZVsgMCBdICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIHNtb290aEludGVycG9sYXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0UCArIGogXSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdGtlZXAgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBpbi1wbGFjZSBjb21wYWN0aW9uXHJcblxyXG5cdFx0XHRcdGlmICgga2VlcCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGkgIT09IHdyaXRlSW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcclxuXHRcdFx0XHRcdFx0XHR3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGU7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Kysgd3JpdGVJbmRleDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcclxuXHJcblx0XHRcdGlmICggbGFzdEluZGV4ID4gMCApIHtcclxuXHJcblx0XHRcdFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBsYXN0SW5kZXggXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHJlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZSwgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHdyaXRlSW5kZXggIT09IHRpbWVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XHJcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB2YWx1ZXMsIDAsIHdyaXRlSW5kZXggKiBzdHJpZGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEEgVHJhY2sgb2YgdmVjdG9yZWQga2V5ZnJhbWUgdmFsdWVzLlxyXG5cdCAqXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcclxuXHJcblx0XHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcclxuXHJcblx0fVxyXG5cclxuXHRWZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogVmVjdG9yS2V5ZnJhbWVUcmFjayxcclxuXHJcblx0XHRWYWx1ZVR5cGVOYW1lOiAndmVjdG9yJ1xyXG5cclxuXHRcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcclxuXHJcblx0XHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIFJldXNhYmxlIHNldCBvZiBUcmFja3MgdGhhdCByZXByZXNlbnQgYW4gYW5pbWF0aW9uLlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQW5pbWF0aW9uQ2xpcCggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApIHtcclxuXHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0dGhpcy50cmFja3MgPSB0cmFja3M7XHJcblx0XHR0aGlzLmR1cmF0aW9uID0gKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkdXJhdGlvbiA6IC0gMTtcclxuXHJcblx0XHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcclxuXHJcblx0XHQvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBmaWd1cmUgb3V0IGl0cyBkdXJhdGlvbiBieSBzY2FubmluZyB0aGUgdHJhY2tzXHJcblx0XHRpZiAoIHRoaXMuZHVyYXRpb24gPCAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5yZXNldER1cmF0aW9uKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMub3B0aW1pemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25DbGlwLCB7XHJcblxyXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRcdHZhciB0cmFja3MgPSBbXSxcclxuXHRcdFx0XHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXHJcblx0XHRcdFx0ZnJhbWVUaW1lID0gMS4wIC8gKCBqc29uLmZwcyB8fCAxLjAgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR0cmFja3MucHVzaCggS2V5ZnJhbWVUcmFjay5wYXJzZSgganNvblRyYWNrc1sgaSBdICkuc2NhbGUoIGZyYW1lVGltZSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR0b0pTT046IGZ1bmN0aW9uICggY2xpcCApIHtcclxuXHJcblx0XHRcdHZhciB0cmFja3MgPSBbXSxcclxuXHRcdFx0XHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XHJcblxyXG5cdFx0XHR2YXIganNvbiA9IHtcclxuXHJcblx0XHRcdFx0J25hbWUnOiBjbGlwLm5hbWUsXHJcblx0XHRcdFx0J2R1cmF0aW9uJzogY2xpcC5kdXJhdGlvbixcclxuXHRcdFx0XHQndHJhY2tzJzogdHJhY2tzXHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gY2xpcFRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHRyYWNrcy5wdXNoKCBLZXlmcmFtZVRyYWNrLnRvSlNPTiggY2xpcFRyYWNrc1sgaSBdICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBqc29uO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Q3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2U6IGZ1bmN0aW9uICggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzLCBub0xvb3AgKSB7XHJcblxyXG5cdFx0XHR2YXIgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XHJcblx0XHRcdHZhciB0cmFja3MgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHRpbWVzID0gW107XHJcblx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHR0aW1lcy5wdXNoKFxyXG5cdFx0XHRcdFx0KCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLFxyXG5cdFx0XHRcdFx0aSxcclxuXHRcdFx0XHRcdCggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyApO1xyXG5cclxuXHRcdFx0XHR2YWx1ZXMucHVzaCggMCwgMSwgMCApO1xyXG5cclxuXHRcdFx0XHR2YXIgb3JkZXIgPSBBbmltYXRpb25VdGlscy5nZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xyXG5cdFx0XHRcdHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHRpbWVzLCAxLCBvcmRlciApO1xyXG5cdFx0XHRcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XHJcblxyXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxyXG5cdFx0XHRcdC8vIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxyXG5cdFx0XHRcdGlmICggISBub0xvb3AgJiYgdGltZXNbIDAgXSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcclxuXHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZXNbIDAgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYWNrcy5wdXNoKFxyXG5cdFx0XHRcdFx0bmV3IE51bWJlcktleWZyYW1lVHJhY2soXHJcblx0XHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcclxuXHRcdFx0XHRcdFx0dGltZXMsIHZhbHVlc1xyXG5cdFx0XHRcdFx0KS5zY2FsZSggMS4wIC8gZnBzICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgLSAxLCB0cmFja3MgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGZpbmRCeU5hbWU6IGZ1bmN0aW9uICggb2JqZWN0T3JDbGlwQXJyYXksIG5hbWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2xpcEFycmF5ID0gb2JqZWN0T3JDbGlwQXJyYXk7XHJcblxyXG5cdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcclxuXHJcblx0XHRcdFx0dmFyIG8gPSBvYmplY3RPckNsaXBBcnJheTtcclxuXHRcdFx0XHRjbGlwQXJyYXkgPSBvLmdlb21ldHJ5ICYmIG8uZ2VvbWV0cnkuYW5pbWF0aW9ucyB8fCBvLmFuaW1hdGlvbnM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGNsaXBBcnJheVsgaSBdLm5hbWUgPT09IG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGNsaXBBcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzOiBmdW5jdGlvbiAoIG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3AgKSB7XHJcblxyXG5cdFx0XHR2YXIgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMgPSB7fTtcclxuXHJcblx0XHRcdC8vIHRlc3RlZCB3aXRoIGh0dHBzOi8vcmVnZXgxMDEuY29tLyBvbiB0cmljayBzZXF1ZW5jZXNcclxuXHRcdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XHJcblx0XHRcdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcclxuXHJcblx0XHRcdC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZFxyXG5cdFx0XHQvLyBwYXR0ZXJucyBsaWtlIFdhbGtfMDAxLCBXYWxrXzAwMiwgUnVuXzAwMSwgUnVuXzAwMlxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcclxuXHRcdFx0XHR2YXIgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbmFtZSA9IHBhcnRzWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XHJcblx0XHRcdFx0XHRpZiAoICEgYW5pbWF0aW9uTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb25Nb3JwaFRhcmdldHMucHVzaCggbW9ycGhUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGNsaXBzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0Y2xpcHMucHVzaCggQW5pbWF0aW9uQ2xpcC5DcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZSggbmFtZSwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSwgZnBzLCBub0xvb3AgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNsaXBzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcGFyc2UgdGhlIGFuaW1hdGlvbi5oaWVyYXJjaHkgZm9ybWF0XHJcblx0XHRwYXJzZUFuaW1hdGlvbjogZnVuY3Rpb24gKCBhbmltYXRpb24sIGJvbmVzICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbkNsaXA6IE5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGEuJyApO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGFkZE5vbmVtcHR5VHJhY2sgPSBmdW5jdGlvbiAoIHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XHJcblxyXG5cdFx0XHRcdC8vIG9ubHkgcmV0dXJuIHRyYWNrIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBrZXlzLlxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5cy5sZW5ndGggIT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRpbWVzID0gW107XHJcblx0XHRcdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRcdFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oIGFuaW1hdGlvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHByb3BlcnR5TmFtZSApO1xyXG5cclxuXHRcdFx0XHRcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cclxuXHRcdFx0XHRcdGlmICggdGltZXMubGVuZ3RoICE9PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGVzdFRyYWNrcy5wdXNoKCBuZXcgdHJhY2tUeXBlKCB0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMgKSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHZhciB0cmFja3MgPSBbXTtcclxuXHJcblx0XHRcdHZhciBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0JztcclxuXHRcdFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXHJcblx0XHRcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLSAxO1xyXG5cdFx0XHR2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcclxuXHJcblx0XHRcdHZhciBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xyXG5cclxuXHRcdFx0XHQvLyBza2lwIGVtcHR5IHRyYWNrc1xyXG5cdFx0XHRcdGlmICggISBhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdC8vIHByb2Nlc3MgbW9ycGggdGFyZ2V0c1xyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xyXG5cdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBhbmltYXRpb25LZXlzLmxlbmd0aDsgayArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0bW9ycGhUYXJnZXROYW1lc1sgYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0c1sgbSBdIF0gPSAtIDE7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cclxuXHRcdFx0XHRcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXHJcblx0XHRcdFx0XHQvLyB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIG1vcnBoVGFyZ2V0TmFtZXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdGltZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtICE9PSBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgKysgbSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNbIGsgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0dGltZXMucHVzaCggYW5pbWF0aW9uS2V5LnRpbWUgKTtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayggJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqICggZnBzIHx8IDEuMCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cclxuXHJcblx0XHRcdFx0XHR2YXIgYm9uZU5hbWUgPSAnLmJvbmVzWycgKyBib25lc1sgaCBdLm5hbWUgKyAnXSc7XHJcblxyXG5cdFx0XHRcdFx0YWRkTm9uZW1wdHlUcmFjayhcclxuXHRcdFx0XHRcdFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnBvc2l0aW9uJyxcclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3BvcycsIHRyYWNrcyApO1xyXG5cclxuXHRcdFx0XHRcdGFkZE5vbmVtcHR5VHJhY2soXHJcblx0XHRcdFx0XHRcdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXHJcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MgKTtcclxuXHJcblx0XHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxyXG5cdFx0XHRcdFx0XHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLFxyXG5cdFx0XHRcdFx0XHRhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgY2xpcCA9IG5ldyBBbmltYXRpb25DbGlwKCBjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNsaXA7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkNsaXAucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0cmVzZXREdXJhdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzLCBkdXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KCBkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dHJpbTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0b3B0aW1pemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dGhpcy50cmFja3NbIGkgXS5vcHRpbWl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIE1hdGVyaWFsTG9hZGVyKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cdFx0dGhpcy50ZXh0dXJlcyA9IHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIE1hdGVyaWFsTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdFx0b25Mb2FkKCBzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApICkgKTtcclxuXHJcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXRUZXh0dXJlKCBuYW1lICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWxzWyBqc29uLnR5cGUgXSgpO1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLnV1aWQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XHJcblx0XHRcdGlmICgganNvbi5uYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0ganNvbi5uYW1lO1xyXG5cdFx0XHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xyXG5cdFx0XHRpZiAoIGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcclxuXHRcdFx0aWYgKCBqc29uLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzID0ganNvbi5tZXRhbG5lc3M7XHJcblx0XHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XHJcblx0XHRcdGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XHJcblx0XHRcdGlmICgganNvbi5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoaW5pbmVzcyA9IGpzb24uc2hpbmluZXNzO1xyXG5cdFx0XHRpZiAoIGpzb24uY2xlYXJDb2F0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhckNvYXQgPSBqc29uLmNsZWFyQ29hdDtcclxuXHRcdFx0aWYgKCBqc29uLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0ganNvbi5jbGVhckNvYXRSb3VnaG5lc3M7XHJcblx0XHRcdGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudW5pZm9ybXMgPSBqc29uLnVuaWZvcm1zO1xyXG5cdFx0XHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcclxuXHRcdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XHJcblx0XHRcdGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xyXG5cdFx0XHRpZiAoIGpzb24uZm9nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mb2cgPSBqc29uLmZvZztcclxuXHRcdFx0aWYgKCBqc29uLmZsYXRTaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XHJcblx0XHRcdGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xyXG5cdFx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcclxuXHRcdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XHJcblx0XHRcdGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xyXG5cdFx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcclxuXHRcdFx0aWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XHJcblx0XHRcdGlmICgganNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xyXG5cdFx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcclxuXHRcdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XHJcblx0XHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdFx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IGpzb24ud2lyZWZyYW1lTGluZWNhcDtcclxuXHRcdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVqb2luICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XHJcblxyXG5cdFx0XHRpZiAoIGpzb24ucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdGF0aW9uID0ganNvbi5yb3RhdGlvbjtcclxuXHJcblx0XHRcdGlmICgganNvbi5saW5ld2lkdGggIT09IDEgKSBtYXRlcmlhbC5saW5ld2lkdGggPSBqc29uLmxpbmV3aWR0aDtcclxuXHRcdFx0aWYgKCBqc29uLmRhc2hTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kYXNoU2l6ZSA9IGpzb24uZGFzaFNpemU7XHJcblx0XHRcdGlmICgganNvbi5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5nYXBTaXplID0ganNvbi5nYXBTaXplO1xyXG5cdFx0XHRpZiAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNjYWxlID0ganNvbi5zY2FsZTtcclxuXHJcblx0XHRcdGlmICgganNvbi5za2lubmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2tpbm5pbmcgPSBqc29uLnNraW5uaW5nO1xyXG5cdFx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSBqc29uLm1vcnBoVGFyZ2V0cztcclxuXHRcdFx0aWYgKCBqc29uLmRpdGhlcmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGl0aGVyaW5nID0ganNvbi5kaXRoZXJpbmc7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmlzaWJsZSA9IGpzb24udmlzaWJsZTtcclxuXHRcdFx0aWYgKCBqc29uLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51c2VyRGF0YSA9IGpzb24udXNlckRhdGE7XHJcblxyXG5cdFx0XHQvLyBEZXByZWNhdGVkXHJcblxyXG5cdFx0XHRpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLnNoYWRpbmcgPT09IDE7IC8vIFRIUkVFLkZsYXRTaGFkaW5nXHJcblxyXG5cdFx0XHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcclxuXHJcblx0XHRcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xyXG5cdFx0XHRpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcclxuXHJcblx0XHRcdC8vIG1hcHNcclxuXHJcblx0XHRcdGlmICgganNvbi5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGpzb24ubWFwICk7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwuYWxwaGFNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFscGhhTWFwICk7XHJcblx0XHRcdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBqc29uLmJ1bXBNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmJ1bXBNYXAgKTtcclxuXHRcdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBqc29uLm5vcm1hbE1hcCApO1xyXG5cdFx0XHRpZiAoIGpzb24ubm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcclxuXHJcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBub3JtYWxTY2FsZSApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBCbGVuZGVyIGV4cG9ydGVyIHVzZWQgdG8gZXhwb3J0IGEgc2NhbGFyLiBTZWUgIzc0NTlcclxuXHJcblx0XHRcdFx0XHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggbm9ybWFsU2NhbGUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XHJcblx0XHRcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cdFx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcclxuXHJcblx0XHRcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XHJcblx0XHRcdGlmICgganNvbi5tZXRhbG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ubWV0YWxuZXNzTWFwICk7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbWlzc2l2ZU1hcCApO1xyXG5cdFx0XHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcclxuXHJcblx0XHRcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbnZNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xyXG5cdFx0XHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcclxuXHJcblx0XHRcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XHJcblx0XHRcdGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xyXG5cclxuXHRcdFx0aWYgKCBqc29uLmdyYWRpZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ncmFkaWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZ3JhZGllbnRNYXAgKTtcclxuXHJcblx0XHRcdHJldHVybiBtYXRlcmlhbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnlMb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xyXG5cclxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGluZGV4LnR5cGUgXSggaW5kZXguYXJyYXkgKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XHJcblx0XHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgVFlQRURfQVJSQVlTWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGdyb3VwcyA9IGpzb24uZGF0YS5ncm91cHMgfHwganNvbi5kYXRhLmRyYXdjYWxscyB8fCBqc29uLmRhdGEub2Zmc2V0cztcclxuXHJcblx0XHRcdGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XHJcblxyXG5cdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0dmFyIFRZUEVEX0FSUkFZUyA9IHtcclxuXHRcdEludDhBcnJheTogSW50OEFycmF5LFxyXG5cdFx0VWludDhBcnJheTogVWludDhBcnJheSxcclxuXHRcdC8vIFdvcmthcm91bmQgZm9yIElFMTEgcHJlIEtCMjkyOTQzNy4gU2VlICMxMTQ0MFxyXG5cdFx0VWludDhDbGFtcGVkQXJyYXk6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OENsYW1wZWRBcnJheSA6IFVpbnQ4QXJyYXksXHJcblx0XHRJbnQxNkFycmF5OiBJbnQxNkFycmF5LFxyXG5cdFx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxyXG5cdFx0SW50MzJBcnJheTogSW50MzJBcnJheSxcclxuXHRcdFVpbnQzMkFycmF5OiBVaW50MzJBcnJheSxcclxuXHRcdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxyXG5cdFx0RmxvYXQ2NEFycmF5OiBGbG9hdDY0QXJyYXlcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBMb2FkZXIoKSB7XHJcblxyXG5cdFx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdFx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdFx0dGhpcy5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdExvYWRlci5IYW5kbGVycyA9IHtcclxuXHJcblx0XHRoYW5kbGVyczogW10sXHJcblxyXG5cdFx0YWRkOiBmdW5jdGlvbiAoIHJlZ2V4LCBsb2FkZXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmhhbmRsZXJzLnB1c2goIHJlZ2V4LCBsb2FkZXIgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuXHRcdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlZ2V4ID0gaGFuZGxlcnNbIGkgXTtcclxuXHRcdFx0XHR2YXIgbG9hZGVyID0gaGFuZGxlcnNbIGkgKyAxIF07XHJcblxyXG5cdFx0XHRcdGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBsb2FkZXI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcclxuXHJcblx0XHRcdHZhciBhcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbWF0ZXJpYWxzLmxlbmd0aDsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNyZWF0ZU1hdGVyaWFsOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBCbGVuZGluZ01vZGUgPSB7XHJcblx0XHRcdFx0Tm9CbGVuZGluZzogTm9CbGVuZGluZyxcclxuXHRcdFx0XHROb3JtYWxCbGVuZGluZzogTm9ybWFsQmxlbmRpbmcsXHJcblx0XHRcdFx0QWRkaXRpdmVCbGVuZGluZzogQWRkaXRpdmVCbGVuZGluZyxcclxuXHRcdFx0XHRTdWJ0cmFjdGl2ZUJsZW5kaW5nOiBTdWJ0cmFjdGl2ZUJsZW5kaW5nLFxyXG5cdFx0XHRcdE11bHRpcGx5QmxlbmRpbmc6IE11bHRpcGx5QmxlbmRpbmcsXHJcblx0XHRcdFx0Q3VzdG9tQmxlbmRpbmc6IEN1c3RvbUJsZW5kaW5nXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcclxuXHRcdFx0dmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xyXG5cdFx0XHR2YXIgbWF0ZXJpYWxMb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXRlcmlhbCggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxyXG5cclxuXHRcdFx0XHR2YXIgdGV4dHVyZXMgPSB7fTtcclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIHBhdGgsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgcGF0aDtcclxuXHRcdFx0XHRcdHZhciBsb2FkZXIgPSBMb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbG9hZGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHJlcGVhdCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIHdyYXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBSZXBlYXRXcmFwcGluZztcclxuXHRcdFx0XHRcdFx0aWYgKCB3cmFwWyAwIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwUyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0XHRcdGlmICggd3JhcFsgMSBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFQgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IGFuaXNvdHJvcHk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHZhciB1dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XHJcblxyXG5cdFx0XHRcdFx0dGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHV1aWQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0dmFyIGpzb24gPSB7XHJcblx0XHRcdFx0XHR1dWlkOiBfTWF0aC5nZW5lcmF0ZVVVSUQoKSxcclxuXHRcdFx0XHRcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBuYW1lIGluIG0gKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gbVsgbmFtZSBdO1xyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdEYmdDb2xvcic6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0RiZ0luZGV4JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnb3B0aWNhbERlbnNpdHknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdpbGx1bWluYXRpb24nOlxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdEYmdOYW1lJzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLm5hbWUgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnYmxlbmRpbmcnOlxyXG5cdFx0XHRcdFx0XHRcdGpzb24uYmxlbmRpbmcgPSBCbGVuZGluZ01vZGVbIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yQW1iaWVudCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFtYmllbnQnOlxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDonLCBuYW1lLCAnaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yRGlmZnVzZSc6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5jb2xvciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JTcGVjdWxhcic6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5zcGVjdWxhciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnY29sb3JFbWlzc2l2ZSc6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5lbWlzc2l2ZSA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnc3BlY3VsYXJDb2VmJzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLnNoaW5pbmVzcyA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdzaGFkaW5nJzpcclxuXHRcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNpYycgKSBqc29uLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnc3RhbmRhcmQnICkganNvbi50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZSc6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5tYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwRGlmZnVzZVJlcGVhdCwgbS5tYXBEaWZmdXNlT2Zmc2V0LCBtLm1hcERpZmZ1c2VXcmFwLCBtLm1hcERpZmZ1c2VBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VSZXBlYXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlT2Zmc2V0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlJzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLmVtaXNzaXZlTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEVtaXNzaXZlUmVwZWF0LCBtLm1hcEVtaXNzaXZlT2Zmc2V0LCBtLm1hcEVtaXNzaXZlV3JhcCwgbS5tYXBFbWlzc2l2ZUFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVSZXBlYXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZU9mZnNldCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlV3JhcCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0JzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLmxpZ2h0TWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcExpZ2h0UmVwZWF0LCBtLm1hcExpZ2h0T2Zmc2V0LCBtLm1hcExpZ2h0V3JhcCwgbS5tYXBMaWdodEFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRSZXBlYXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodE9mZnNldCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0V3JhcCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0QW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFPJzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLmFvTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQU9SZXBlYXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBT09mZnNldCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFPV3JhcCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFPQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXAnOlxyXG5cdFx0XHRcdFx0XHRcdGpzb24uYnVtcE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLmJ1bXBTY2FsZSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wUmVwZWF0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcE9mZnNldCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBXcmFwJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcEFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWwnOlxyXG5cdFx0XHRcdFx0XHRcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEZhY3Rvcic6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFJlcGVhdCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFdyYXAnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXInOlxyXG5cdFx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXJNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhclJlcGVhdCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyT2Zmc2V0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJBbmlzb3Ryb3B5JzpcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzJzpcclxuXHRcdFx0XHRcdFx0XHRqc29uLm1ldGFsbmVzc01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBNZXRhbG5lc3NSZXBlYXQsIG0ubWFwTWV0YWxuZXNzT2Zmc2V0LCBtLm1hcE1ldGFsbmVzc1dyYXAsIG0ubWFwTWV0YWxuZXNzQW5pc290cm9weSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NSZXBlYXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NPZmZzZXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBNZXRhbG5lc3NXcmFwJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzQW5pc290cm9weSc6XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzcyc6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5yb3VnaG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwUm91Z2huZXNzUmVwZWF0LCBtLm1hcFJvdWdobmVzc09mZnNldCwgbS5tYXBSb3VnaG5lc3NXcmFwLCBtLm1hcFJvdWdobmVzc0FuaXNvdHJvcHkgKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzUmVwZWF0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzT2Zmc2V0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwUm91Z2huZXNzV3JhcCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc0FuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYSc6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5hbHBoYU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhUmVwZWF0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFPZmZzZXQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVdyYXAnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYUFuaXNvdHJvcHknOlxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdmbGlwU2lkZWQnOlxyXG5cdFx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IEJhY2tTaWRlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkb3VibGVTaWRlZCc6XHJcblx0XHRcdFx0XHRcdFx0anNvbi5zaWRlID0gRG91YmxlU2lkZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XHJcblx0XHRcdFx0XHRcdFx0anNvbi5vcGFjaXR5ID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2RlcHRoVGVzdCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2RlcHRoV3JpdGUnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdjb2xvcldyaXRlJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnb3BhY2l0eSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3JlZmxlY3Rpdml0eSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3dpcmVmcmFtZSc6XHJcblx0XHRcdFx0XHRcdFx0anNvblsgbmFtZSBdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3ZlcnRleENvbG9ycyc6XHJcblx0XHRcdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xyXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICdmYWNlJyApIGpzb24udmVydGV4Q29sb3JzID0gRmFjZUNvbG9ycztcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZCcsIG5hbWUsIHZhbHVlICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi50eXBlID09PSAnTWVzaEJhc2ljTWF0ZXJpYWwnICkgZGVsZXRlIGpzb24uZW1pc3NpdmU7XHJcblx0XHRcdFx0aWYgKCBqc29uLnR5cGUgIT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgKSBkZWxldGUganNvbi5zcGVjdWxhcjtcclxuXHJcblx0XHRcdFx0aWYgKCBqc29uLm9wYWNpdHkgPCAxICkganNvbi50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsTG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxMb2FkZXIucGFyc2UoIGpzb24gKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSApKClcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIERvbiBNY0N1cmR5IC8gaHR0cHM6Ly93d3cuZG9ubWNjdXJkeS5jb21cclxuXHQgKi9cclxuXHJcblx0dmFyIExvYWRlclV0aWxzID0ge1xyXG5cclxuXHRcdGRlY29kZVRleHQ6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGFycmF5ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBdm9pZCB0aGUgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgc2hvcnRjdXQsIHdoaWNoXHJcblx0XHRcdC8vIHRocm93cyBhIFwibWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIiBlcnJvciBmb3IgbGFyZ2UgYXJyYXlzLlxyXG5cclxuXHRcdFx0dmFyIHMgPSAnJztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gSW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW4uXHJcblx0XHRcdFx0cyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBhcnJheVsgaSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XHJcblxyXG5cdFx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xyXG5cclxuXHRcdFx0cGFydHMucG9wKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEpTT05Mb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgbWFuYWdlciA9PT0gJ2Jvb2xlYW4nICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogc2hvd1N0YXR1cyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGNvbnN0cnVjdG9yLicgKTtcclxuXHRcdFx0bWFuYWdlciA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblxyXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBKU09OTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIHRleHR1cmVQYXRoID0gdGhpcy50ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID09PSAnc3RyaW5nJyApID8gdGhpcy50ZXh0dXJlUGF0aCA6IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcclxuXHJcblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XHJcblx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XHJcblx0XHRcdFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcblx0XHRcdFx0aWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB0eXBlID0gbWV0YWRhdGEudHlwZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdHlwZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzY2VuZScgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XHJcblx0XHRcdFx0b25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcclxuXHJcblx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2U6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VNb2RlbCgganNvbiwgZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGksIGosIGZpLFxyXG5cclxuXHRcdFx0XHRcdG9mZnNldCwgekxlbmd0aCxcclxuXHJcblx0XHRcdFx0XHRjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCwgbWF0ZXJpYWxJbmRleCxcclxuXHJcblx0XHRcdFx0XHR0eXBlLFxyXG5cdFx0XHRcdFx0aXNRdWFkLFxyXG5cdFx0XHRcdFx0aGFzTWF0ZXJpYWwsXHJcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4VXYsXHJcblx0XHRcdFx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxyXG5cdFx0XHRcdFx0aGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXHJcblxyXG5cdFx0XHRcdFx0dmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxyXG5cclxuXHRcdFx0XHRcdHV2TGF5ZXIsIHV2LCB1LCB2LFxyXG5cclxuXHRcdFx0XHRcdGZhY2VzID0ganNvbi5mYWNlcyxcclxuXHRcdFx0XHRcdHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcclxuXHRcdFx0XHRcdG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXHJcblx0XHRcdFx0XHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcclxuXHJcblx0XHRcdFx0XHRzY2FsZSA9IGpzb24uc2NhbGUsXHJcblxyXG5cdFx0XHRcdFx0blV2TGF5ZXJzID0gMDtcclxuXHJcblxyXG5cdFx0XHRcdGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRvZmZzZXQgPSAwO1xyXG5cdFx0XHRcdHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XHJcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRvZmZzZXQgPSAwO1xyXG5cdFx0XHRcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdGlzUXVhZCA9IGlzQml0U2V0KCB0eXBlLCAwICk7XHJcblx0XHRcdFx0XHRoYXNNYXRlcmlhbCA9IGlzQml0U2V0KCB0eXBlLCAxICk7XHJcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4VXYgPSBpc0JpdFNldCggdHlwZSwgMyApO1xyXG5cdFx0XHRcdFx0aGFzRmFjZU5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XHJcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcclxuXHRcdFx0XHRcdGhhc0ZhY2VDb2xvciA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XHJcblx0XHRcdFx0XHRoYXNGYWNlVmVydGV4Q29sb3IgPSBpc0JpdFNldCggdHlwZSwgNyApO1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpc1F1YWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQSA9IG5ldyBGYWNlMygpO1xyXG5cdFx0XHRcdFx0XHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xyXG5cdFx0XHRcdFx0XHRmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlQiA9IG5ldyBGYWNlMygpO1xyXG5cdFx0XHRcdFx0XHRmYWNlQi5hID0gZmFjZXNbIG9mZnNldCArIDEgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XHJcblx0XHRcdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cdFx0XHRcdFx0XHRcdGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG5cdFx0XHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFZlY3RvcjIoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaiAhPT0gMiApIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZUEubm9ybWFsLnNldChcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0XHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcclxuXHRcdFx0XHRcdFx0XHRmYWNlQi5jb2xvci5zZXRIZXgoIGhleCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGhleCApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBoZXggKSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlID0gbmV3IEZhY2UzKCk7XHJcblx0XHRcdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRmYWNlLmMgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdFx0XHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcclxuXHJcblx0XHRcdFx0XHRcdGZpID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVmVjdG9yMiggdSwgdiApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZS5ub3JtYWwuc2V0KFxyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcclxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRcdFx0XHRmYWNlLmNvbG9yLnNldEhleCggY29sb3JzWyBjb2xvckluZGV4IF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCAzOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VTa2luKCBqc29uLCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xyXG5cclxuXHRcdFx0XHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgeCA9IGpzb24uc2tpbldlaWdodHNbIGkgXTtcclxuXHRcdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcclxuXHRcdFx0XHRcdFx0dmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcclxuXHRcdFx0XHRcdFx0dmFyIHcgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMyBdIDogMDtcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBWZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGEgPSBqc29uLnNraW5JbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XHJcblx0XHRcdFx0XHRcdHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XHJcblx0XHRcdFx0XHRcdHZhciBkID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDMgXSA6IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5wdXNoKCBuZXcgVmVjdG9yNCggYSwgYiwgYywgZCApICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICYmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICE9PSBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggfHwgZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICE9PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSApIHtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKCcgKyBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKyAnKSwgc2tpbkluZGljZXMgKCcgK1xyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZygganNvbiwgZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzY2FsZSA9IGpzb24uc2NhbGU7XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcclxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cdFx0XHRcdFx0XHR2YXIgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRcdFx0XHRcdHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcclxuXHRcdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogXCJtb3JwaENvbG9yc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzaW5nIHRoZW0gYXMgZmFjZSBjb2xvcnMuJyApO1xyXG5cclxuXHRcdFx0XHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xyXG5cdFx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZXNbIGkgXS5jb2xvci5mcm9tQXJyYXkoIG1vcnBoQ29sb3JzLCBpICogMyApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCBqc29uLCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdFx0Ly8gcGFyc2Ugb2xkIHN0eWxlIEJvbmUvSGllcmFyY2h5IGFuaW1hdGlvbnNcclxuXHRcdFx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbnMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuY29uY2F0KCBqc29uLmFuaW1hdGlvbnMgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbnMgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlQW5pbWF0aW9uKCBhbmltYXRpb25zWyBpIF0sIGdlb21ldHJ5LmJvbmVzICk7XHJcblx0XHRcdFx0XHRpZiAoIGNsaXAgKSBvdXRwdXRBbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBwYXJzZSBpbXBsaWNpdCBtb3JwaCBhbmltYXRpb25zXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVE9ETzogRmlndXJlIG91dCB3aGF0IGFuIGFwcHJvcHJhaXRlIEZQUyBpcyBmb3IgbW9ycGggdGFyZ2V0IGFuaW1hdGlvbnMgLS0gZGVmYXVsdGluZyB0byAxMCwgYnV0IHJlYWxseSBpdCBpcyBjb21wbGV0ZWx5IGFyYml0cmFyeS5cclxuXHRcdFx0XHRcdHZhciBtb3JwaEFuaW1hdGlvbkNsaXBzID0gQW5pbWF0aW9uQ2xpcC5DcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlcyggZ2VvbWV0cnkubW9ycGhUYXJnZXRzLCAxMCApO1xyXG5cdFx0XHRcdFx0b3V0cHV0QW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnMuY29uY2F0KCBtb3JwaEFuaW1hdGlvbkNsaXBzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBvdXRwdXRBbmltYXRpb25zLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5hbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIEdlb21ldHJ5IDQuMCBzcGVjXHJcblx0XHRcdFx0XHRqc29uID0ganNvbi5kYXRhO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGpzb24uc2NhbGUgPSAxLjAgLyBqc29uLnNjYWxlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGpzb24uc2NhbGUgPSAxLjA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XHJcblxyXG5cdFx0XHRcdHBhcnNlTW9kZWwoIGpzb24sIGdlb21ldHJ5ICk7XHJcblx0XHRcdFx0cGFyc2VTa2luKCBqc29uLCBnZW9tZXRyeSApO1xyXG5cdFx0XHRcdHBhcnNlTW9ycGhpbmcoIGpzb24sIGdlb21ldHJ5ICk7XHJcblx0XHRcdFx0cGFyc2VBbmltYXRpb25zKCBqc29uLCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcclxuXHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRcdFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSApKClcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBPYmplY3RMb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblx0XHR0aGlzLnRleHR1cmVQYXRoID0gJyc7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggT2JqZWN0TG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRleHR1cmVQYXRoID0gdXJsLnN1YnN0cmluZyggMCwgdXJsLmxhc3RJbmRleE9mKCAnLycgKSArIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIganNvbiA9IG51bGw7XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcclxuXHJcblx0XHRcdFx0fSBjYXRjaCAoIGVycm9yICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkgb25FcnJvciggZXJyb3IgKTtcclxuXHJcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUU6T2JqZWN0TG9hZGVyOiBDYW5cXCd0IHBhcnNlICcgKyB1cmwgKyAnLicsIGVycm9yLm1lc3NhZ2UgKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcclxuXHJcblx0XHRcdFx0aWYgKCBtZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdnZW9tZXRyeScgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwgKyAnLiBVc2UgVEhSRUUuSlNPTkxvYWRlciBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzY29wZS5wYXJzZSgganNvbiwgb25Mb2FkICk7XHJcblxyXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZSgganNvbi5zaGFwZXMgKTtcclxuXHRcdFx0dmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzLCBzaGFwZXMgKTtcclxuXHJcblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XHJcblx0XHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcclxuXHJcblx0XHRcdHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucyApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBvYmplY3Q7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRwYXJzZVNoYXBlOiBmdW5jdGlvbiAoIGpzb24gKSB7XHJcblxyXG5cdFx0XHR2YXIgc2hhcGVzID0ge307XHJcblxyXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBzaGFwZSA9IG5ldyBTaGFwZSgpLmZyb21KU09OKCBqc29uWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRzaGFwZXNbIHNoYXBlLnV1aWQgXSA9IHNoYXBlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2VHZW9tZXRyaWVzOiBmdW5jdGlvbiAoIGpzb24sIHNoYXBlcyApIHtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyaWVzID0ge307XHJcblxyXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IEpTT05Mb2FkZXIoKTtcclxuXHRcdFx0XHR2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBnZW9tZXRyeTtcclxuXHRcdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdCb3hHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0JveEJ1ZmZlckdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGhTZWdtZW50c1xyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzVG9wLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNCb3R0b20sXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaWFsU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5vcGVuRW5kZWQsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdDb25lR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdDb25lQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnU3BoZXJlR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnT2N0YWhlZHJvbkdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1RldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ1JpbmdHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1JpbmdCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5pbm5lclJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3V0ZXJSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnBoaVNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnVG9ydXNHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1RvcnVzQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnVG9ydXNLbm90QnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5wLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5xXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdMYXRoZUdlb21ldHJ5JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnTGF0aGVCdWZmZXJHZW9tZXRyeSc6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5wb2ludHMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRjYXNlICdQb2x5aGVkcm9uR2VvbWV0cnknOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudmVydGljZXMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmluZGljZXMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsc1xyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FzZSAnU2hhcGVHZW9tZXRyeSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1NoYXBlQnVmZmVyR2VvbWV0cnknOlxyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBpIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeVNoYXBlcy5wdXNoKCBzaGFwZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnlTaGFwZXMsXHJcblx0XHRcdFx0XHRcdFx0XHRkYXRhLmN1cnZlU2VnbWVudHNcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSwgdGhpcy50ZXh0dXJlUGF0aCApLmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcIicgKyBkYXRhLnR5cGUgKyAnXCInICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBnZW9tZXRyaWVzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0ZXJpYWxzID0ge307XHJcblxyXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xyXG5cdFx0XHRcdGxvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBkYXRhID0ganNvblsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGF0YS50eXBlID09PSAnTXVsdGlNYXRlcmlhbCcgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBEZXByZWNhdGVkXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYXJyYXkgPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGRhdGEubWF0ZXJpYWxzLmxlbmd0aDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaCggbG9hZGVyLnBhcnNlKCBkYXRhLm1hdGVyaWFsc1sgaiBdICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBhcnJheTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1hdGVyaWFscztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHBhcnNlQW5pbWF0aW9uczogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2UoIGpzb25bIGkgXSApO1xyXG5cclxuXHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhbmltYXRpb25zO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xyXG5cclxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHRcdFx0dmFyIGltYWdlcyA9IHt9O1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cclxuXHRcdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xyXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCBvbkxvYWQgKTtcclxuXHJcblx0XHRcdFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggbWFuYWdlciApO1xyXG5cdFx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGltYWdlID0ganNvblsgaSBdO1xyXG5cdFx0XHRcdFx0dmFyIHBhdGggPSAvXihcXC9cXC8pfChbYS16XSs6KFxcL1xcLyk/KS9pLnRlc3QoIGltYWdlLnVybCApID8gaW1hZ2UudXJsIDogc2NvcGUudGV4dHVyZVBhdGggKyBpbWFnZS51cmw7XHJcblxyXG5cdFx0XHRcdFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBsb2FkSW1hZ2UoIHBhdGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGltYWdlcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICgganNvbiwgaW1hZ2VzICkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gcGFyc2VDb25zdGFudCggdmFsdWUsIHR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHlwZVsgdmFsdWUgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xyXG5cclxuXHRcdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubmFtZSA9IGRhdGEubmFtZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nLCBURVhUVVJFX01BUFBJTkcgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRhdGEub2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIGRhdGEub2Zmc2V0ICk7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIGRhdGEucmVwZWF0ICk7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEuY2VudGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNlbnRlci5mcm9tQXJyYXkoIGRhdGEuY2VudGVyICk7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCApIHRleHR1cmUucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGF0YS53cmFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcclxuXHRcdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMSBdLCBURVhUVVJFX1dSQVBQSU5HICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICggZGF0YS5taW5GaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5taW5GaWx0ZXIsIFRFWFRVUkVfRklMVEVSICk7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGRhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZmxpcFkgPSBkYXRhLmZsaXBZO1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0ZXh0dXJlcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBwYXJzZU9iamVjdCggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0O1xyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBnZXRHZW9tZXRyeSggbmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJpZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gW107XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB1dWlkID0gbmFtZVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsc1sgdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCB1dWlkICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaCggbWF0ZXJpYWxzWyB1dWlkIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnU2NlbmUnOlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNjZW5lKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIE51bWJlci5pc0ludGVnZXIoIGRhdGEuYmFja2dyb3VuZCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKCBkYXRhLmJhY2tncm91bmQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhLmZvZyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2cnICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC5mb2cgPSBuZXcgRm9nKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2dFeHAyJyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5kZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuZm9jdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5mb2N1cyA9IGRhdGEuZm9jdXM7XHJcblx0XHRcdFx0XHRcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcclxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhLmZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1HYXVnZSA9IGRhdGEuZmlsbUdhdWdlO1xyXG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuZmlsbU9mZnNldCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1PZmZzZXQgPSBkYXRhLmZpbG1PZmZzZXQ7XHJcblx0XHRcdFx0XHRcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnQW1iaWVudExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnUG9pbnRMaWdodCc6XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLnBlbnVtYnJhLCBkYXRhLmRlY2F5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ1NraW5uZWRNZXNoJzpcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZU9iamVjdCgpIGRvZXMgbm90IHN1cHBvcnQgU2tpbm5lZE1lc2ggeWV0LicgKTtcclxuXHJcblx0XHRcdFx0XHRjYXNlICdNZXNoJzpcclxuXHJcblx0XHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XHJcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdMT0QnOlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IExPRCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnTGluZSc6XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZSggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSwgZGF0YS5tb2RlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdMaW5lTG9vcCc6XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZUxvb3AoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ0xpbmVTZWdtZW50cyc6XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdQb2ludENsb3VkJzpcclxuXHRcdFx0XHRcdGNhc2UgJ1BvaW50cyc6XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRjYXNlICdTcHJpdGUnOlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xyXG5cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0Y2FzZSAnR3JvdXAnOlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEdyb3VwKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcclxuXHRcdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcclxuXHRcdFx0XHRcdG1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBkYXRhLnF1YXRlcm5pb24gKTtcclxuXHRcdFx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcclxuXHRcdFx0XHRpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS5zaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xyXG5cdFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5tYXBTaXplICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KCBkYXRhLnNoYWRvdy5tYXBTaXplICk7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEuc2hhZG93LmNhbWVyYSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5jYW1lcmEgPSB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLnNoYWRvdy5jYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XHJcblx0XHRcdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LmFkZExldmVsKCBjaGlsZCwgbGV2ZWwuZGlzdGFuY2UgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG9iamVjdDtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpXHJcblxyXG5cdH0gKTtcclxuXHJcblx0dmFyIFRFWFRVUkVfTUFQUElORyA9IHtcclxuXHRcdFVWTWFwcGluZzogVVZNYXBwaW5nLFxyXG5cdFx0Q3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXHJcblx0XHRDdWJlUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVSZWZyYWN0aW9uTWFwcGluZyxcclxuXHRcdEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcclxuXHRcdEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcclxuXHRcdFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOiBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyxcclxuXHRcdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyxcclxuXHRcdEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZ1xyXG5cdH07XHJcblxyXG5cdHZhciBURVhUVVJFX1dSQVBQSU5HID0ge1xyXG5cdFx0UmVwZWF0V3JhcHBpbmc6IFJlcGVhdFdyYXBwaW5nLFxyXG5cdFx0Q2xhbXBUb0VkZ2VXcmFwcGluZzogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcclxuXHRcdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcclxuXHR9O1xyXG5cclxuXHR2YXIgVEVYVFVSRV9GSUxURVIgPSB7XHJcblx0XHROZWFyZXN0RmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxyXG5cdFx0TmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyLFxyXG5cdFx0TmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcixcclxuXHRcdExpbmVhckZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0TGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjogTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcixcclxuXHRcdExpbmVhck1pcE1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB0aGVzcGl0ZSAvIGh0dHA6Ly9jbGlja3RvcmVsZWFzZS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEltYWdlQml0bWFwTG9hZGVyKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBjcmVhdGVJbWFnZUJpdG1hcCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogZmV0Y2goKSBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlciAhPT0gdW5kZWZpbmVkID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcclxuXHRcdHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHRJbWFnZUJpdG1hcExvYWRlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IEltYWdlQml0bWFwTG9hZGVyLFxyXG5cclxuXHRcdHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoIG9wdGlvbnMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsb2FkOiBmdW5jdGlvbiBsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdGlmICggdXJsID09PSB1bmRlZmluZWQgKSB1cmwgPSAnJztcclxuXHJcblx0XHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XHJcblxyXG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdFx0dmFyIGNhY2hlZCA9IENhY2hlLmdldCggdXJsICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XHJcblxyXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XHJcblxyXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdFx0fSwgMCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FjaGVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmV0Y2goIHVybCApLnRoZW4oIGZ1bmN0aW9uICggcmVzICkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzLmJsb2IoKTtcclxuXHJcblx0XHRcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGJsb2IgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcCggYmxvYiwgc2NvcGUub3B0aW9ucyApO1xyXG5cclxuXHRcdFx0fSApLnRoZW4oIGZ1bmN0aW9uICggaW1hZ2VCaXRtYXAgKSB7XHJcblxyXG5cdFx0XHRcdENhY2hlLmFkZCggdXJsLCBpbWFnZUJpdG1hcCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggaW1hZ2VCaXRtYXAgKTtcclxuXHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcclxuXHJcblx0XHRcdH0gKS5jYXRjaCggZnVuY3Rpb24gKCBlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlICk7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XHJcblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggLyogdmFsdWUgKi8gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcblx0ICogbWluaW1hbCBjbGFzcyBmb3IgcHJveGluZyBmdW5jdGlvbnMgdG8gUGF0aC4gUmVwbGFjZXMgb2xkIFwiZXh0cmFjdFN1YnBhdGhzKClcIlxyXG5cdCAqKi9cclxuXHJcblx0ZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xyXG5cclxuXHRcdHRoaXMudHlwZSA9ICdTaGFwZVBhdGgnO1xyXG5cclxuXHRcdHRoaXMuc3ViUGF0aHMgPSBbXTtcclxuXHRcdHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIFNoYXBlUGF0aC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRtb3ZlVG86IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFBhdGggPSBuZXcgUGF0aCgpO1xyXG5cdFx0XHR0aGlzLnN1YlBhdGhzLnB1c2goIHRoaXMuY3VycmVudFBhdGggKTtcclxuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oIHgsIHkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxpbmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5saW5lVG8oIHgsIHkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xyXG5cclxuXHRcdFx0dGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcclxuXHJcblx0XHRcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUoIHB0cyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dG9TaGFwZXM6IGZ1bmN0aW9uICggaXNDQ1csIG5vSG9sZXMgKSB7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaGFwZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHZhciB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xyXG5cdFx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG5cdFx0XHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHNoYXBlcztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Ly8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3JcclxuXHRcdFx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXHJcblx0XHRcdFx0Ly8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxyXG5cdFx0XHRcdC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXHJcblx0XHRcdFx0dmFyIGluc2lkZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcCBdO1xyXG5cdFx0XHRcdFx0dmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XHJcblx0XHRcdFx0XHR2YXIgZWRnZUR5ID0gZWRnZUhpZ2hQdC55IC0gZWRnZUxvd1B0Lnk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIG5vdCBwYXJhbGxlbFxyXG5cdFx0XHRcdFx0XHRpZiAoIGVkZ2VEeSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcSBdOyBlZGdlRHggPSAtIGVkZ2VEeDtcclxuXHRcdFx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC0gZWRnZUR5O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHRcdFx0Ly8gY29udGludWU7XHRcdFx0XHQvLyBubyBpbnRlcnNlY3Rpb24gb3IgZWRnZUxvd1B0ID0+IGRvZXNuJ3QgY291bnQgISEhXHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA9PT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XHJcblx0XHRcdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXHJcblx0XHRcdFx0XHRcdGlmICggaW5QdC55ICE9PSBlZGdlTG93UHQueSApIFx0XHRjb250aW51ZTtcdFx0XHQvLyBwYXJhbGxlbFxyXG5cdFx0XHRcdFx0XHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcclxuXHRcdFx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdCAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApXHRcdHJldHVyblx0dHJ1ZTtcdC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxyXG5cdFx0XHRcdFx0XHQvLyBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuXHRpbnNpZGU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xyXG5cclxuXHRcdFx0dmFyIHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcclxuXHRcdFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XHJcblxyXG5cdFx0XHRpZiAoIG5vSG9sZXMgPT09IHRydWUgKVx0cmV0dXJuXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XHJcblxyXG5cclxuXHRcdFx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XHJcblxyXG5cdFx0XHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XHJcblx0XHRcdFx0dG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcclxuXHRcdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcclxuXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcclxuXHRcdFx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XHJcblx0XHRcdGhvbGVzRmlyc3QgPSBpc0NDVyA/ICEgaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XHJcblxyXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xyXG5cclxuXHRcdFx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcclxuXHRcdFx0dmFyIG5ld1NoYXBlcyA9IFtdO1xyXG5cdFx0XHR2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xyXG5cdFx0XHR2YXIgbWFpbklkeCA9IDA7XHJcblx0XHRcdHZhciB0bXBQb2ludHM7XHJcblxyXG5cdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcclxuXHRcdFx0XHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xyXG5cdFx0XHRcdHNvbGlkID0gaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xyXG5cdFx0XHRcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XHJcblxyXG5cdFx0XHRcdGlmICggc29saWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAoICEgaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzWyBtYWluSWR4IF0gKSApXHRtYWluSWR4ICsrO1xyXG5cclxuXHRcdFx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XHJcblx0XHRcdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaG9sZXNGaXJzdCApXHRtYWluSWR4ICsrO1xyXG5cdFx0XHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XHJcblxyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxyXG5cdFx0XHRpZiAoICEgbmV3U2hhcGVzWyAwIF0gKVx0cmV0dXJuXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XHJcblxyXG5cclxuXHRcdFx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFtYmlndW91cyA9IGZhbHNlO1xyXG5cdFx0XHRcdHZhciB0b0NoYW5nZSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1sgc0lkeCBdO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcclxuXHRcdFx0XHRcdFx0dmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggc0lkeCAhPT0gczJJZHggKVx0dG9DaGFuZ2UucHVzaCggeyBmcm9tczogc0lkeCwgdG9zOiBzMklkeCwgaG9sZTogaElkeCB9ICk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzMklkeCBdLnB1c2goIGhvICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGFtYmlndW91cyA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0ucHVzaCggaG8gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XHJcblx0XHRcdFx0aWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xyXG5cdFx0XHRcdFx0aWYgKCAhIGFtYmlndW91cyApXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRtcEhvbGVzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xyXG5cdFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0XHRcdHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dG1wU2hhcGUuaG9sZXMucHVzaCggdG1wSG9sZXNbIGogXS5oICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHNoYXBlcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEZvbnQoIGRhdGEgKSB7XHJcblxyXG5cdFx0dGhpcy50eXBlID0gJ0ZvbnQnO1xyXG5cclxuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggRm9udC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc0ZvbnQ6IHRydWUsXHJcblxyXG5cdFx0Z2VuZXJhdGVTaGFwZXM6IGZ1bmN0aW9uICggdGV4dCwgc2l6ZSwgZGl2aXNpb25zICkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gY3JlYXRlUGF0aHMoIHRleHQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApO1xyXG5cdFx0XHRcdHZhciBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XHJcblx0XHRcdFx0dmFyIGxpbmVfaGVpZ2h0ID0gKCBkYXRhLmJvdW5kaW5nQm94LnlNYXggLSBkYXRhLmJvdW5kaW5nQm94LnlNaW4gKyBkYXRhLnVuZGVybGluZVRoaWNrbmVzcyApICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdHZhciBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDA7XHJcblxyXG5cdFx0XHRcdHZhciBwYXRocyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNoYXIgPSBjaGFyc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY2hhciA9PT0gJ1xcbicgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvZmZzZXRYID0gMDtcclxuXHRcdFx0XHRcdFx0b2Zmc2V0WSAtPSBsaW5lX2hlaWdodDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHJldCA9IGNyZWF0ZVBhdGgoIGNoYXIsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZICk7XHJcblx0XHRcdFx0XHRcdG9mZnNldFggKz0gcmV0Lm9mZnNldFg7XHJcblx0XHRcdFx0XHRcdHBhdGhzLnB1c2goIHJldC5wYXRoICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBwYXRocztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIGMsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2x5cGggPSBkYXRhLmdseXBoc1sgYyBdIHx8IGRhdGEuZ2x5cGhzWyAnPycgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGdseXBoICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcclxuXHJcblx0XHRcdFx0dmFyIHB0cyA9IFtdO1xyXG5cdFx0XHRcdHZhciB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgbGFzdGU7XHJcblxyXG5cdFx0XHRcdGlmICggZ2x5cGgubyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG91dGxpbmUubGVuZ3RoOyBpIDwgbDsgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYWN0aW9uID0gb3V0bGluZVsgaSArKyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0c3dpdGNoICggYWN0aW9uICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjYXNlICdtJzogLy8gbW92ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcclxuXHRcdFx0XHRcdFx0XHRcdHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAnbCc6IC8vIGxpbmVUb1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XHJcblx0XHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3B4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3B5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcclxuXHRcdFx0XHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGlmICggbGFzdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2InOiAvLyBiZXppZXJDdXJ2ZVRvXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3B4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3B5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcclxuXHRcdFx0XHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XHJcblx0XHRcdFx0XHRcdFx0XHRjcHgyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3B5MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRwYXRoLmJlemllckN1cnZlVG8oIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGNweCwgY3B5ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHsgb2Zmc2V0WDogZ2x5cGguaGEgKiBzY2FsZSwgcGF0aDogcGF0aCB9O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDEwMDtcclxuXHRcdFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDQ7XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHJcblx0XHRcdHZhciBwYXRocyA9IGNyZWF0ZVBhdGhzKCB0ZXh0ICk7XHJcblx0XHRcdHZhciBzaGFwZXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIHNoYXBlcywgcGF0aHNbIHAgXS50b1NoYXBlcygpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBGb250TG9hZGVyKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEZvbnRMb2FkZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcclxuXHJcblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGpzb247XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblxyXG5cdFx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcclxuXHJcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRm9udExvYWRlcjogdHlwZWZhY2UuanMgc3VwcG9ydCBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgdHlwZWZhY2UuanNvbiBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0LnN1YnN0cmluZyggNjUsIHRleHQubGVuZ3RoIC0gMiApICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGZvbnQgPSBzY29wZS5wYXJzZSgganNvbiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggZm9udCApO1xyXG5cclxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgRm9udCgganNvbiApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0dmFyIGNvbnRleHQ7XHJcblxyXG5cdHZhciBBdWRpb0NvbnRleHQgPSB7XHJcblxyXG5cdFx0Z2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCBjb250ZXh0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRDb250ZXh0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y29udGV4dCA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBSZWVjZSBBYXJvbiBMZWNyaXZhaW4gLyBodHRwOi8vcmVlY2Vub3Rlcy5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEF1ZGlvTG9hZGVyKCBtYW5hZ2VyICkge1xyXG5cclxuXHRcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEF1ZGlvTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xyXG5cdFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XHJcblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XHJcblxyXG5cdFx0XHRcdGNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCBidWZmZXIsIGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0b25Mb2FkKCBhdWRpb0J1ZmZlciApO1xyXG5cclxuXHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFN0ZXJlb0NhbWVyYSgpIHtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcclxuXHJcblx0XHR0aGlzLmFzcGVjdCA9IDE7XHJcblxyXG5cdFx0dGhpcy5leWVTZXAgPSAwLjA2NDtcclxuXHJcblx0XHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHRcdHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XHJcblx0XHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xyXG5cdFx0dGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoIDIgKTtcclxuXHRcdHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggU3RlcmVvQ2FtZXJhLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgaW5zdGFuY2UsIGZvY3VzLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyLCB6b29tLCBleWVTZXA7XHJcblxyXG5cdFx0XHR2YXIgZXllUmlnaHQgPSBuZXcgTWF0cml4NCgpO1xyXG5cdFx0XHR2YXIgZXllTGVmdCA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBuZWVkc1VwZGF0ZSA9IGluc3RhbmNlICE9PSB0aGlzIHx8IGZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgZm92ICE9PSBjYW1lcmEuZm92IHx8XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3QgfHwgbmVhciAhPT0gY2FtZXJhLm5lYXIgfHxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmYXIgIT09IGNhbWVyYS5mYXIgfHwgem9vbSAhPT0gY2FtZXJhLnpvb20gfHwgZXllU2VwICE9PSB0aGlzLmV5ZVNlcDtcclxuXHJcblx0XHRcdFx0aWYgKCBuZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpbnN0YW5jZSA9IHRoaXM7XHJcblx0XHRcdFx0XHRmb2N1cyA9IGNhbWVyYS5mb2N1cztcclxuXHRcdFx0XHRcdGZvdiA9IGNhbWVyYS5mb3Y7XHJcblx0XHRcdFx0XHRhc3BlY3QgPSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3Q7XHJcblx0XHRcdFx0XHRuZWFyID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0XHRmYXIgPSBjYW1lcmEuZmFyO1xyXG5cdFx0XHRcdFx0em9vbSA9IGNhbWVyYS56b29tO1xyXG5cclxuXHRcdFx0XHRcdC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cclxuXHRcdFx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXHJcblxyXG5cdFx0XHRcdFx0dmFyIHByb2plY3Rpb25NYXRyaXggPSBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0ZXllU2VwID0gdGhpcy5leWVTZXAgLyAyO1xyXG5cdFx0XHRcdFx0dmFyIGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcCAqIG5lYXIgLyBmb2N1cztcclxuXHRcdFx0XHRcdHZhciB5bWF4ID0gKCBuZWFyICogTWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiBmb3YgKiAwLjUgKSApIC8gem9vbTtcclxuXHRcdFx0XHRcdHZhciB4bWluLCB4bWF4O1xyXG5cclxuXHRcdFx0XHRcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XHJcblxyXG5cdFx0XHRcdFx0ZXllTGVmdC5lbGVtZW50c1sgMTIgXSA9IC0gZXllU2VwO1xyXG5cdFx0XHRcdFx0ZXllUmlnaHQuZWxlbWVudHNbIDEyIF0gPSBleWVTZXA7XHJcblxyXG5cdFx0XHRcdFx0Ly8gZm9yIGxlZnQgZXllXHJcblxyXG5cdFx0XHRcdFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcclxuXHRcdFx0XHRcdHhtYXggPSB5bWF4ICogYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xyXG5cclxuXHRcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHQvLyBmb3IgcmlnaHQgZXllXHJcblxyXG5cdFx0XHRcdFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcclxuXHRcdFx0XHRcdHhtYXggPSB5bWF4ICogYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xyXG5cclxuXHRcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cdFx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmNhbWVyYUwubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZUxlZnQgKTtcclxuXHRcdFx0XHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZVJpZ2h0ICk7XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0gKSgpXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FtZXJhIGZvciByZW5kZXJpbmcgY3ViZSBtYXBzXHJcblx0ICpcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBDdWJlQ2FtZXJhKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XHJcblxyXG5cdFx0dmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xyXG5cclxuXHRcdHZhciBjYW1lcmFQWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdFx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRcdGNhbWVyYVBYLmxvb2tBdCggbmV3IFZlY3RvcjMoIDEsIDAsIDAgKSApO1xyXG5cdFx0dGhpcy5hZGQoIGNhbWVyYVBYICk7XHJcblxyXG5cdFx0dmFyIGNhbWVyYU5YID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0XHRjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xyXG5cdFx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcclxuXHRcdHRoaXMuYWRkKCBjYW1lcmFOWCApO1xyXG5cclxuXHRcdHZhciBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdFx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XHJcblx0XHRjYW1lcmFQWS5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHRcdHRoaXMuYWRkKCBjYW1lcmFQWSApO1xyXG5cclxuXHRcdHZhciBjYW1lcmFOWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcclxuXHRcdGNhbWVyYU5ZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApICk7XHJcblx0XHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcclxuXHJcblx0XHR2YXIgY2FtZXJhUFogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRcdGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XHJcblx0XHRjYW1lcmFQWi5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAwLCAxICkgKTtcclxuXHRcdHRoaXMuYWRkKCBjYW1lcmFQWiApO1xyXG5cclxuXHRcdHZhciBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xyXG5cdFx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcclxuXHRcdGNhbWVyYU5aLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApICk7XHJcblx0XHR0aGlzLmFkZCggY2FtZXJhTlogKTtcclxuXHJcblx0XHR2YXIgb3B0aW9ucyA9IHsgZm9ybWF0OiBSR0JGb3JtYXQsIG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLCBtaW5GaWx0ZXI6IExpbmVhckZpbHRlciB9O1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggY3ViZVJlc29sdXRpb24sIGN1YmVSZXNvbHV0aW9uLCBvcHRpb25zICk7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIkN1YmVDYW1lcmFcIjtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcclxuXHRcdFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCByZW5kZXJlciwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xyXG5cclxuXHRcdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gaTtcclxuXHRcdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0XHRyZW5kZXJlci5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdEN1YmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblx0Q3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJlQ2FtZXJhO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBBdWRpb0xpc3RlbmVyKCkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XHJcblxyXG5cdFx0dGhpcy5jb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcclxuXHJcblx0XHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xyXG5cdFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xyXG5cclxuXHRcdHRoaXMuZmlsdGVyID0gbnVsbDtcclxuXHJcblx0fVxyXG5cclxuXHRBdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IEF1ZGlvTGlzdGVuZXIsXHJcblxyXG5cdFx0Z2V0SW5wdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdhaW47XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZW1vdmVGaWx0ZXI6IGZ1bmN0aW9uICggKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcclxuXHRcdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHRcdFx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XHJcblx0XHRcdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0RmlsdGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5maWx0ZXI7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGaWx0ZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcclxuXHRcdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XHJcblx0XHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xyXG5cdFx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldE1hc3RlclZvbHVtZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0TWFzdGVyVm9sdW1lOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcclxuXHRcdFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZhciBvcmllbnRhdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xyXG5cclxuXHRcdFx0XHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcclxuXHJcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xyXG5cdFx0XHRcdHZhciB1cCA9IHRoaXMudXA7XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcclxuXHJcblx0XHRcdFx0b3JpZW50YXRpb24uc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcclxuXHJcblx0XHRcdFx0aWYgKCBsaXN0ZW5lci5wb3NpdGlvblggKSB7XHJcblxyXG5cdFx0XHRcdFx0bGlzdGVuZXIucG9zaXRpb25YLnNldFZhbHVlQXRUaW1lKCBwb3NpdGlvbi54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcclxuXHRcdFx0XHRcdGxpc3RlbmVyLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZSggcG9zaXRpb24ueSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XHJcblx0XHRcdFx0XHRsaXN0ZW5lci5wb3NpdGlvblouc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFguc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFkuc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIuZm9yd2FyZFouc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xyXG5cdFx0XHRcdFx0bGlzdGVuZXIudXBYLnNldFZhbHVlQXRUaW1lKCB1cC54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcclxuXHRcdFx0XHRcdGxpc3RlbmVyLnVwWS5zZXRWYWx1ZUF0VGltZSggdXAueSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XHJcblx0XHRcdFx0XHRsaXN0ZW5lci51cFouc2V0VmFsdWVBdFRpbWUoIHVwLnosIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XHJcblx0XHRcdFx0XHRsaXN0ZW5lci5zZXRPcmllbnRhdGlvbiggb3JpZW50YXRpb24ueCwgb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgdXAueCwgdXAueSwgdXAueiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0gKSgpXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQXVkaW8oIGxpc3RlbmVyICkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQXVkaW8nO1xyXG5cclxuXHRcdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XHJcblxyXG5cdFx0dGhpcy5nYWluID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCBsaXN0ZW5lci5nZXRJbnB1dCgpICk7XHJcblxyXG5cdFx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuYnVmZmVyID0gbnVsbDtcclxuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xyXG5cdFx0dGhpcy5vZmZzZXQgPSAwO1xyXG5cdFx0dGhpcy5wbGF5YmFja1JhdGUgPSAxO1xyXG5cdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gdHJ1ZTtcclxuXHRcdHRoaXMuc291cmNlVHlwZSA9ICdlbXB0eSc7XHJcblxyXG5cdFx0dGhpcy5maWx0ZXJzID0gW107XHJcblxyXG5cdH1cclxuXHJcblx0QXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogQXVkaW8sXHJcblxyXG5cdFx0Z2V0T3V0cHV0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5nYWluO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0Tm9kZVNvdXJjZTogZnVuY3Rpb24gKCBhdWRpb05vZGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcclxuXHRcdFx0dGhpcy5zb3VyY2UgPSBhdWRpb05vZGU7XHJcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRCdWZmZXI6IGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xyXG5cdFx0XHR0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdXRvcGxheSApIHRoaXMucGxheSgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRwbGF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG5cdFx0XHRzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcblx0XHRcdHNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xyXG5cdFx0XHRzb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XHJcblx0XHRcdHNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLnN0YXJ0VGltZSApO1xyXG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcclxuXHRcdFx0c291cmNlLnN0YXJ0KCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5vZmZzZXQgKTtcclxuXHJcblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29ubmVjdCgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9ICggdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5zdGFydFRpbWUgKSAqIHRoaXMucGxheWJhY2tSYXRlO1xyXG5cdFx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xyXG5cdFx0XHR0aGlzLm9mZnNldCA9IDA7XHJcblx0XHRcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldEZpbHRlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmZpbHRlcnM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGaWx0ZXJzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIHZhbHVlICkgdmFsdWUgPSBbXTtcclxuXHJcblx0XHRcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdCgpO1xyXG5cdFx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlO1xyXG5cdFx0XHRcdHRoaXMuY29ubmVjdCgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldEZpbHRlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0RmlsdGVycygpWyAwIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGaWx0ZXI6IGZ1bmN0aW9uICggZmlsdGVyICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RmlsdGVycyggZmlsdGVyID8gWyBmaWx0ZXIgXSA6IFtdICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRQbGF5YmFja1JhdGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRvbkVuZGVkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0TG9vcDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5sb29wO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0TG9vcDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5sb29wID0gdmFsdWU7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRWb2x1bWU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFZvbHVtZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gUG9zaXRpb25hbEF1ZGlvKCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHRBdWRpby5jYWxsKCB0aGlzLCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdHRoaXMucGFubmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xyXG5cdFx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XHJcblxyXG5cdH1cclxuXHJcblx0UG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEF1ZGlvLnByb3RvdHlwZSApLCB7XHJcblxyXG5cdFx0Y29uc3RydWN0b3I6IFBvc2l0aW9uYWxBdWRpbyxcclxuXHJcblx0XHRnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnBhbm5lcjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFJlZkRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRSb2xsb2ZmRmFjdG9yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvcjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXREaXN0YW5jZU1vZGVsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XHJcblxyXG5cdFx0XHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSApKClcclxuXHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQXVkaW9BbmFseXNlciggYXVkaW8sIGZmdFNpemUgKSB7XHJcblxyXG5cdFx0dGhpcy5hbmFseXNlciA9IGF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcclxuXHRcdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemUgIT09IHVuZGVmaW5lZCA/IGZmdFNpemUgOiAyMDQ4O1xyXG5cclxuXHRcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XHJcblxyXG5cdFx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Z2V0RnJlcXVlbmN5RGF0YTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSggdGhpcy5kYXRhICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0QXZlcmFnZUZyZXF1ZW5jeTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHZhbHVlID0gMCwgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhbHVlICs9IGRhdGFbIGkgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEJ1ZmZlcmVkIHNjZW5lIGdyYXBoIHByb3BlcnR5IHRoYXQgYWxsb3dzIHdlaWdodGVkIGFjY3VtdWxhdGlvbi5cclxuXHQgKlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFByb3BlcnR5TWl4ZXIoIGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUgKSB7XHJcblxyXG5cdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcclxuXHRcdHRoaXMudmFsdWVTaXplID0gdmFsdWVTaXplO1xyXG5cclxuXHRcdHZhciBidWZmZXJUeXBlID0gRmxvYXQ2NEFycmF5LFxyXG5cdFx0XHRtaXhGdW5jdGlvbjtcclxuXHJcblx0XHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcclxuXHJcblx0XHRcdGNhc2UgJ3F1YXRlcm5pb24nOlxyXG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlICdzdHJpbmcnOlxyXG5cdFx0XHRjYXNlICdib29sJzpcclxuXHRcdFx0XHRidWZmZXJUeXBlID0gQXJyYXk7XHJcblx0XHRcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5idWZmZXIgPSBuZXcgYnVmZmVyVHlwZSggdmFsdWVTaXplICogNCApO1xyXG5cdFx0Ly8gbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgXVxyXG5cdFx0Ly9cclxuXHRcdC8vIGludGVycG9sYXRvcnMgY2FuIHVzZSAuYnVmZmVyIGFzIHRoZWlyIC5yZXN1bHRcclxuXHRcdC8vIHRoZSBkYXRhIHRoZW4gZ29lcyB0byAnaW5jb21pbmcnXHJcblx0XHQvL1xyXG5cdFx0Ly8gJ2FjY3UwJyBhbmQgJ2FjY3UxJyBhcmUgdXNlZCBmcmFtZS1pbnRlcmxlYXZlZCBmb3JcclxuXHRcdC8vIHRoZSBjdW11bGF0aXZlIHJlc3VsdCBhbmQgYXJlIGNvbXBhcmVkIHRvIGRldGVjdFxyXG5cdFx0Ly8gY2hhbmdlc1xyXG5cdFx0Ly9cclxuXHRcdC8vICdvcmlnJyBzdG9yZXMgdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBwcm9wZXJ0eVxyXG5cclxuXHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xyXG5cclxuXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcblxyXG5cdFx0dGhpcy51c2VDb3VudCA9IDA7XHJcblx0XHR0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eU1peGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8vIGFjY3VtdWxhdGUgZGF0YSBpbiB0aGUgJ2luY29taW5nJyByZWdpb24gaW50byAnYWNjdTxpPidcclxuXHRcdGFjY3VtdWxhdGU6IGZ1bmN0aW9uICggYWNjdUluZGV4LCB3ZWlnaHQgKSB7XHJcblxyXG5cdFx0XHQvLyBub3RlOiBoYXBwaWx5IGFjY3VtdWxhdGluZyBub3RoaW5nIHdoZW4gd2VpZ2h0ID0gMCwgdGhlIGNhbGxlciBrbm93c1xyXG5cdFx0XHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxyXG5cclxuXHRcdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxyXG5cdFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxyXG5cdFx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcclxuXHJcblx0XHRcdFx0Y3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFdlaWdodCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YnVmZmVyWyBvZmZzZXQgKyBpIF0gPSBidWZmZXJbIGkgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxyXG5cclxuXHRcdFx0XHRjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcclxuXHRcdFx0XHR2YXIgbWl4ID0gd2VpZ2h0IC8gY3VycmVudFdlaWdodDtcclxuXHRcdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcclxuXHRcdGFwcGx5OiBmdW5jdGlvbiAoIGFjY3VJbmRleCApIHtcclxuXHJcblx0XHRcdHZhciBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHRcdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcclxuXHRcdFx0XHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXHJcblxyXG5cdFx0XHRcdHdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodCxcclxuXHJcblx0XHRcdFx0YmluZGluZyA9IHRoaXMuYmluZGluZztcclxuXHJcblx0XHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIHdlaWdodCA8IDEgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcclxuXHJcblx0XHRcdFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiAzO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oXHJcblx0XHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgaSAhPT0gZTsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyByZW1lbWJlciB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIHByb3BlcnR5IGFuZCBjb3B5IGl0IHRvIGJvdGggYWNjdXNcclxuXHRcdHNhdmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZztcclxuXHJcblx0XHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcclxuXHRcdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcclxuXHJcblx0XHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XHJcblxyXG5cdFx0XHRiaW5kaW5nLmdldFZhbHVlKCBidWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcclxuXHJcblx0XHRcdC8vIGFjY3VbMC4uMV0gOj0gb3JpZyAtLSBpbml0aWFsbHkgZGV0ZWN0IGNoYW5nZXMgYWdhaW5zdCB0aGUgb3JpZ2luYWxcclxuXHRcdFx0Zm9yICggdmFyIGkgPSBzdHJpZGUsIGUgPSBvcmlnaW5hbFZhbHVlT2Zmc2V0OyBpICE9PSBlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIGkgXSA9IGJ1ZmZlclsgb3JpZ2luYWxWYWx1ZU9mZnNldCArICggaSAlIHN0cmlkZSApIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcclxuXHRcdHJlc3RvcmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHRoaXMudmFsdWVTaXplICogMztcclxuXHRcdFx0dGhpcy5iaW5kaW5nLnNldFZhbHVlKCB0aGlzLmJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8vIG1peCBmdW5jdGlvbnNcclxuXHJcblx0XHRfc2VsZWN0OiBmdW5jdGlvbiAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcclxuXHJcblx0XHRcdGlmICggdCA+PSAwLjUgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRcdGJ1ZmZlclsgZHN0T2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF9zbGVycDogZnVuY3Rpb24gKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0ICkge1xyXG5cclxuXHRcdFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF9sZXJwOiBmdW5jdGlvbiAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcclxuXHJcblx0XHRcdHZhciBzID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGogPSBkc3RPZmZzZXQgKyBpO1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIGogXSA9IGJ1ZmZlclsgaiBdICogcyArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBBIHJlZmVyZW5jZSB0byBhIHJlYWwgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoLlxyXG5cdCAqXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xyXG5cdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xyXG5cdCAqIEBhdXRob3IgdHNjaHdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQ29tcG9zaXRlKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xyXG5cclxuXHRcdHZhciBwYXJzZWRQYXRoID0gb3B0aW9uYWxQYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xyXG5cclxuXHRcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XHJcblx0XHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBDb21wb3NpdGUucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXHJcblxyXG5cdFx0XHR2YXIgZmlyc3RWYWxpZEluZGV4ID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxyXG5cdFx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1sgZmlyc3RWYWxpZEluZGV4IF07XHJcblxyXG5cdFx0XHQvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcclxuXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRWYWx1ZTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YmluZGluZ3NbIGkgXS5zZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YmluZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YmluZGluZ3NbIGkgXS5iaW5kKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXHJcblx0XHRcdFx0XHQgIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiBQcm9wZXJ0eUJpbmRpbmcoIHJvb3ROb2RlLCBwYXRoLCBwYXJzZWRQYXRoICkge1xyXG5cclxuXHRcdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0XHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xyXG5cclxuXHRcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdE5vZGUsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHJvb3ROb2RlO1xyXG5cclxuXHRcdHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcsIHtcclxuXHJcblx0XHRDb21wb3NpdGU6IENvbXBvc2l0ZSxcclxuXHJcblx0XHRjcmVhdGU6IGZ1bmN0aW9uICggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApIHtcclxuXHJcblx0XHRcdGlmICggISAoIHJvb3QgJiYgcm9vdC5pc0FuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVwbGFjZXMgc3BhY2VzIHdpdGggdW5kZXJzY29yZXMgYW5kIHJlbW92ZXMgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycyBmcm9tXHJcblx0XHQgKiBub2RlIG5hbWVzLCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHBhcnNlVHJhY2tOYW1lKCkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIE5vZGUgbmFtZSB0byBiZSBzYW5pdGl6ZWQuXHJcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdHNhbml0aXplTm9kZU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBuYW1lLnJlcGxhY2UoIC9cXHMvZywgJ18nICkucmVwbGFjZSggL1teXFx3LV0vZywgJycgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHBhcnNlVHJhY2tOYW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBQYXJlbnQgZGlyZWN0b3JpZXMsIGRlbGltaXRlZCBieSAnLycgb3IgJzonLiBDdXJyZW50bHkgdW51c2VkLCBidXQgbXVzdFxyXG5cdFx0XHQvLyBiZSBtYXRjaGVkIHRvIHBhcnNlIHRoZSByZXN0IG9mIHRoZSB0cmFjayBuYW1lLlxyXG5cdFx0XHR2YXIgZGlyZWN0b3J5UmUgPSAvKCg/OltcXHctXStbXFwvOl0pKikvO1xyXG5cclxuXHRcdFx0Ly8gVGFyZ2V0IG5vZGUuIE1heSBjb250YWluIHdvcmQgY2hhcmFjdGVycyAoYS16QS1aMC05XykgYW5kICcuJyBvciAnLScuXHJcblx0XHRcdHZhciBub2RlUmUgPSAvKFtcXHctXFwuXSspPy87XHJcblxyXG5cdFx0XHQvLyBPYmplY3Qgb24gdGFyZ2V0IG5vZGUsIGFuZCBhY2Nlc3Nvci4gTmFtZSBtYXkgY29udGFpbiBvbmx5IHdvcmRcclxuXHRcdFx0Ly8gY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5IGNvbnRhaW4gYW55IGNoYXJhY3RlciBleGNlcHQgY2xvc2luZyBicmFja2V0LlxyXG5cdFx0XHR2YXIgb2JqZWN0UmUgPSAvKD86XFwuKFtcXHctXSspKD86XFxbKC4rKVxcXSk/KT8vO1xyXG5cclxuXHRcdFx0Ly8gUHJvcGVydHkgYW5kIGFjY2Vzc29yLiBNYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5XHJcblx0XHRcdC8vIGNvbnRhaW4gYW55IG5vbi1icmFja2V0IGNoYXJhY3RlcnMuXHJcblx0XHRcdHZhciBwcm9wZXJ0eVJlID0gL1xcLihbXFx3LV0rKSg/OlxcWyguKylcXF0pPy87XHJcblxyXG5cdFx0XHR2YXIgdHJhY2tSZSA9IG5ldyBSZWdFeHAoICcnXHJcblx0XHRcdFx0KyAnXidcclxuXHRcdFx0XHQrIGRpcmVjdG9yeVJlLnNvdXJjZVxyXG5cdFx0XHRcdCsgbm9kZVJlLnNvdXJjZVxyXG5cdFx0XHRcdCsgb2JqZWN0UmUuc291cmNlXHJcblx0XHRcdFx0KyBwcm9wZXJ0eVJlLnNvdXJjZVxyXG5cdFx0XHRcdCsgJyQnXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHR2YXIgc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbICdtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnIF07XHJcblxyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0cmFja05hbWUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBtYXRjaGVzID0gdHJhY2tSZS5leGVjKCB0cmFja05hbWUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIG1hdGNoZXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHJlc3VsdHMgPSB7XHJcblx0XHRcdFx0XHQvLyBkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWyAxIF0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxyXG5cdFx0XHRcdFx0bm9kZU5hbWU6IG1hdGNoZXNbIDIgXSxcclxuXHRcdFx0XHRcdG9iamVjdE5hbWU6IG1hdGNoZXNbIDMgXSxcclxuXHRcdFx0XHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWyA0IF0sXHJcblx0XHRcdFx0XHRwcm9wZXJ0eU5hbWU6IG1hdGNoZXNbIDUgXSwgLy8gcmVxdWlyZWRcclxuXHRcdFx0XHRcdHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbIDYgXVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHZhciBsYXN0RG90ID0gcmVzdWx0cy5ub2RlTmFtZSAmJiByZXN1bHRzLm5vZGVOYW1lLmxhc3RJbmRleE9mKCAnLicgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBsYXN0RG90ICE9PSB1bmRlZmluZWQgJiYgbGFzdERvdCAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBvYmplY3ROYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIGxhc3REb3QgKyAxICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGEgd2hpdGVsaXN0LiBPdGhlcndpc2UsIHRoZXJlXHJcblx0XHRcdFx0XHQvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcclxuXHRcdFx0XHRcdC8vICdiYXInIGNvdWxkIGJlIHRoZSBvYmplY3ROYW1lLCBvciBwYXJ0IG9mIGEgbm9kZU5hbWUgKHdoaWNoIGNhblxyXG5cdFx0XHRcdFx0Ly8gaW5jbHVkZSAnLicgY2hhcmFjdGVycykuXHJcblx0XHRcdFx0XHRpZiAoIHN1cHBvcnRlZE9iamVjdE5hbWVzLmluZGV4T2YoIG9iamVjdE5hbWUgKSAhPT0gLSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cmVzdWx0cy5ub2RlTmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKCAwLCBsYXN0RG90ICk7XHJcblx0XHRcdFx0XHRcdHJlc3VsdHMub2JqZWN0TmFtZSA9IG9iamVjdE5hbWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6ICcgKyB0cmFja05hbWUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cclxuXHRcdGZpbmROb2RlOiBmdW5jdGlvbiAoIHJvb3QsIG5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIG5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSBcIlwiIHx8IG5vZGVOYW1lID09PSBcInJvb3RcIiB8fCBub2RlTmFtZSA9PT0gXCIuXCIgfHwgbm9kZU5hbWUgPT09IC0gMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiByb290O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXHJcblx0XHRcdGlmICggcm9vdC5za2VsZXRvbiApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24gKCBza2VsZXRvbiApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBza2VsZXRvbi5ib25lcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGJvbmUubmFtZSA9PT0gbm9kZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBib25lO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0dmFyIGJvbmUgPSBzZWFyY2hTa2VsZXRvbiggcm9vdC5za2VsZXRvbiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJvbmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNlYXJjaCBpbnRvIG5vZGUgc3VidHJlZS5cclxuXHRcdFx0aWYgKCByb290LmNoaWxkcmVuICkge1xyXG5cclxuXHRcdFx0XHR2YXIgc2VhcmNoTm9kZVN1YnRyZWUgPSBmdW5jdGlvbiAoIGNoaWxkcmVuICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlblsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2hpbGROb2RlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XHJcblxyXG5cdFx0XHRcdGlmICggc3ViVHJlZU5vZGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSwgeyAvLyBwcm90b3R5cGUsIGNvbnRpbnVlZFxyXG5cclxuXHRcdC8vIHRoZXNlIGFyZSB1c2VkIHRvIFwiYmluZFwiIGEgbm9uZXhpc3RlbnQgcHJvcGVydHlcclxuXHRcdF9nZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24gKCkge30sXHJcblx0XHRfc2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uICgpIHt9LFxyXG5cclxuXHRcdEJpbmRpbmdUeXBlOiB7XHJcblx0XHRcdERpcmVjdDogMCxcclxuXHRcdFx0RW50aXJlQXJyYXk6IDEsXHJcblx0XHRcdEFycmF5RWxlbWVudDogMixcclxuXHRcdFx0SGFzRnJvbVRvQXJyYXk6IDNcclxuXHRcdH0sXHJcblxyXG5cdFx0VmVyc2lvbmluZzoge1xyXG5cdFx0XHROb25lOiAwLFxyXG5cdFx0XHROZWVkc1VwZGF0ZTogMSxcclxuXHRcdFx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxyXG5cdFx0fSxcclxuXHJcblx0XHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdO1xyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRidWZmZXJbIG9mZnNldCArKyBdID0gc291cmNlWyBpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmdW5jdGlvbiBnZXRWYWx1ZV90b0FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSxcclxuXHJcblx0XHRTZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZzogW1xyXG5cclxuXHRcdFx0W1xyXG5cdFx0XHRcdC8vIERpcmVjdFxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcclxuXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XSwgW1xyXG5cclxuXHRcdFx0XHQvLyBFbnRpcmVBcnJheVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRdLCBbXHJcblxyXG5cdFx0XHRcdC8vIEFycmF5RWxlbWVudFxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xyXG5cdFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XHJcblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XSwgW1xyXG5cclxuXHRcdFx0XHQvLyBIYXNUb0Zyb21BcnJheVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcclxuXHRcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XHJcblx0XHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XVxyXG5cclxuXHRcdF0sXHJcblxyXG5cdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHRhcmdldEFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJpbmQoKTtcclxuXHRcdFx0dGhpcy5nZXRWYWx1ZSggdGFyZ2V0QXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdFx0Ly8gTm90ZTogVGhpcyBjbGFzcyB1c2VzIGEgU3RhdGUgcGF0dGVybiBvbiBhIHBlci1tZXRob2QgYmFzaXM6XHJcblx0XHRcdC8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXHJcblx0XHRcdC8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXHJcblx0XHRcdC8vIHRoZSBib3VuZCBzdGF0ZS4gV2hlbiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB0aGUgbWV0aG9kc1xyXG5cdFx0XHQvLyBiZWNvbWUgbm8tb3BzLlxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHNvdXJjZUFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJpbmQoKTtcclxuXHRcdFx0dGhpcy5zZXRWYWx1ZSggc291cmNlQXJyYXksIG9mZnNldCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3JlYXRlIGdldHRlciAvIHNldHRlciBwYWlyIGZvciBhIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaFxyXG5cdFx0YmluZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZSxcclxuXHRcdFx0XHRwYXJzZWRQYXRoID0gdGhpcy5wYXJzZWRQYXRoLFxyXG5cclxuXHRcdFx0XHRvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lLFxyXG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lLFxyXG5cdFx0XHRcdHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XHJcblxyXG5cdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHR0YXJnZXRPYmplY3QgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHRoaXMucm9vdE5vZGUsIHBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCB0aGlzLnJvb3ROb2RlO1xyXG5cclxuXHRcdFx0XHR0aGlzLm5vZGUgPSB0YXJnZXRPYmplY3Q7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgZmFpbCBzdGF0ZSBzbyB3ZSBjYW4ganVzdCAncmV0dXJuJyBvbiBlcnJvclxyXG5cdFx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5hdmFpbGFibGU7XHJcblx0XHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcclxuXHJcblx0XHRcdC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcclxuXHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdE5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XHJcblxyXG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cclxuXHRcdFx0XHRzd2l0Y2ggKCBvYmplY3ROYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuJywgdGhpcyApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheS4nLCB0aGlzICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscztcclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgJ2JvbmVzJzpcclxuXHJcblx0XHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3Quc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4nLCB0aGlzICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxyXG5cdFx0XHRcdFx0XHQvLyBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXHJcblxyXG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBpIF0ubmFtZSA9PT0gb2JqZWN0SW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0SW5kZXggPSBpO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUgdW5kZWZpbmVkLicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVzb2x2ZSBwcm9wZXJ0eVxyXG5cdFx0XHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcclxuXHJcblx0XHRcdGlmICggbm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBub2RlTmFtZSA9IHBhcnNlZFBhdGgubm9kZU5hbWU7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiAnICsgbm9kZU5hbWUgK1xyXG5cdFx0XHRcdFx0Jy4nICsgcHJvcGVydHlOYW1lICsgJyBidXQgaXQgd2FzblxcJ3QgZm91bmQuJywgdGFyZ2V0T2JqZWN0ICk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXHJcblx0XHRcdHZhciB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XHJcblxyXG5cdFx0XHRpZiAoIHRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBtYXRlcmlhbFxyXG5cclxuXHRcdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbm9kZSB0cmFuc2Zvcm1cclxuXHJcblx0XHRcdFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5NYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZGV0ZXJtaW5lIGhvdyB0aGUgcHJvcGVydHkgZ2V0cyBib3VuZFxyXG5cdFx0XHR2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcclxuXHJcblx0XHRcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcclxuXHJcblx0XHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09IFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXHJcblxyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxyXG5cdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS4nLCB0aGlzICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLicsIHRoaXMgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGUuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpIF0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eUluZGV4ID0gaTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy4nLCB0aGlzICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlJbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50O1xyXG5cclxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5mcm9tQXJyYXkgIT09IHVuZGVmaW5lZCAmJiBub2RlUHJvcGVydHkudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHQvLyBtdXN0IHVzZSBjb3B5IGZvciBPYmplY3QzRC5FdWxlci9RdWF0ZXJuaW9uXHJcblxyXG5cdFx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggbm9kZVByb3BlcnR5ICkgKSB7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcclxuXHJcblx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXHJcblx0XHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XHJcblx0XHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nWyBiaW5kaW5nVHlwZSBdWyB2ZXJzaW9uaW5nIF07XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMubm9kZSA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXHJcblx0XHRcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xyXG5cdFx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcclxuXHRcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8vIVxcIERFQ0xBUkUgQUxJQVMgQUZURVIgYXNzaWduIHByb3RvdHlwZSAhXHJcblx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdC8vIGluaXRpYWwgc3RhdGUgb2YgdGhlc2UgbWV0aG9kcyB0aGF0IGNhbGxzICdiaW5kJ1xyXG5cdFx0X2dldFZhbHVlX3VuYm91bmQ6IFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuZ2V0VmFsdWUsXHJcblx0XHRfc2V0VmFsdWVfdW5ib3VuZDogUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5zZXRWYWx1ZSxcclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEEgZ3JvdXAgb2Ygb2JqZWN0cyB0aGF0IHJlY2VpdmVzIGEgc2hhcmVkIGFuaW1hdGlvbiBzdGF0ZS5cclxuXHQgKlxyXG5cdCAqIFVzYWdlOlxyXG5cdCAqXHJcblx0ICogXHQtXHRBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxyXG5cdCAqIFx0XHRjb25zdHJ1Y3RvciBvciB0aGUgLmNsaXBBY3Rpb24gbWV0aG9kIG9mIEFuaW1hdGlvbk1peGVyLlxyXG5cdCAqXHJcblx0ICogXHQtXHRJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxyXG5cdCAqXHJcblx0ICogXHQtXHRZb3UgY2FuIGFsc28gYWRkIGFuZCByZW1vdmUgb2JqZWN0cyBsYXRlciB3aGVuIHRoZSBtaXhlclxyXG5cdCAqIFx0XHRpcyBydW5uaW5nLlxyXG5cdCAqXHJcblx0ICogTm90ZTpcclxuXHQgKlxyXG5cdCAqICBcdE9iamVjdHMgb2YgdGhpcyBjbGFzcyBhcHBlYXIgYXMgb25lIG9iamVjdCB0byB0aGUgbWl4ZXIsXHJcblx0ICogIFx0c28gY2FjaGUgY29udHJvbCBvZiB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG11c3QgYmUgZG9uZVxyXG5cdCAqICBcdG9uIHRoZSBncm91cC5cclxuXHQgKlxyXG5cdCAqIExpbWl0YXRpb246XHJcblx0ICpcclxuXHQgKiBcdC0gXHRUaGUgYW5pbWF0ZWQgcHJvcGVydGllcyBtdXN0IGJlIGNvbXBhdGlibGUgYW1vbmcgdGhlXHJcblx0ICogXHRcdGFsbCBvYmplY3RzIGluIHRoZSBncm91cC5cclxuXHQgKlxyXG5cdCAqICAtXHRBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXHJcblx0ICogIFx0dGFyZ2V0IGdyb3VwIG9yIGRpcmVjdGx5LCBidXQgbm90IGJvdGguXHJcblx0ICpcclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEFuaW1hdGlvbk9iamVjdEdyb3VwKCkge1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xyXG5cdFx0dGhpcy5fb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHJcblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IDA7XHRcdFx0Ly8gdGhyZXNob2xkXHJcblx0XHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IHt9O1xyXG5cdFx0dGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7XHRcdC8vIGZvciBib29ra2VlcGluZ1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRpbmRpY2VzWyBhcmd1bWVudHNbIGkgXS51dWlkIF0gPSBpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9wYXRocyA9IFtdO1x0XHRcdFx0XHQvLyBpbnNpZGU6IHN0cmluZ1xyXG5cdFx0dGhpcy5fcGFyc2VkUGF0aHMgPSBbXTtcdFx0XHRcdC8vIGluc2lkZTogeyB3ZSBkb24ndCBjYXJlLCBoZXJlIH1cclxuXHRcdHRoaXMuX2JpbmRpbmdzID0gW107IFx0XHRcdFx0Ly8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cclxuXHRcdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyBcdC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdHRoaXMuc3RhdHMgPSB7XHJcblxyXG5cdFx0XHRvYmplY3RzOiB7XHJcblx0XHRcdFx0Z2V0IHRvdGFsKCkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBzY29wZS5fb2JqZWN0cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0IGluVXNlKCkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGdldCBiaW5kaW5nc1Blck9iamVjdCgpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25PYmplY3RHcm91cC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc0FuaW1hdGlvbk9iamVjdEdyb3VwOiB0cnVlLFxyXG5cclxuXHRcdGFkZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxyXG5cdFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXHJcblx0XHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcclxuXHRcdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxyXG5cdFx0XHRcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXHJcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXHJcblx0XHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXHJcblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXSxcclxuXHRcdFx0XHRcdGtub3duT2JqZWN0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXHJcblxyXG5cdFx0XHRcdFx0aW5kZXggPSBuT2JqZWN0cyArKztcclxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGluZGV4O1xyXG5cdFx0XHRcdFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZ3NbIGogXS5wdXNoKCBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdFx0XHRrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cclxuXHJcblx0XHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxyXG5cdFx0XHRcdFx0XHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XHJcblx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xyXG5cdFx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcclxuXHRcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0sXHJcblx0XHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXHJcblx0XHRcdFx0XHRcdFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcclxuXHRcdFx0XHRcdFx0XHQvLyBvciBtYXkgbm90IGV4aXN0XHJcblxyXG5cdFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdHNbIGluZGV4IF0gIT09IGtub3duT2JqZWN0ICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cDogRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEICcgK1xyXG5cdFx0XHRcdFx0XHRcdCdkZXRlY3RlZC4gQ2xlYW4gdGhlIGNhY2hlcyBvciByZWNyZWF0ZSB5b3VyIGluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4nICk7XHJcblxyXG5cdFx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxyXG5cclxuXHRcdFx0fSAvLyBmb3IgYXJndW1lbnRzXHJcblxyXG5cdFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXHJcblx0XHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcclxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcclxuXHRcdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcclxuXHRcdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxyXG5cclxuXHRcdFx0XHRcdHZhciBsYXN0Q2FjaGVkSW5kZXggPSBuQ2FjaGVkT2JqZWN0cyArKyxcclxuXHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmVPYmplY3QgPSBvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBsYXN0Q2FjaGVkSW5kZXg7XHJcblx0XHRcdFx0XHRvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxyXG5cdFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZTtcclxuXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSA9IGJpbmRpbmc7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IC8vIGZvciBhcmd1bWVudHNcclxuXHJcblx0XHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyByZW1vdmUgJiBmb3JnZXRcclxuXHRcdHVuY2FjaGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcclxuXHRcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxyXG5cdFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXHJcblx0XHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXHJcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXHJcblx0XHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXHJcblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGRlbGV0ZSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGNhY2hlZCwgc2hyaW5rIHRoZSBDQUNIRUQgcmVnaW9uXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxyXG5cdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0sXHJcblx0XHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXHJcblx0XHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2VcclxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXHJcblx0XHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcclxuXHRcdFx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdE9iamVjdDtcclxuXHRcdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXHJcblx0XHRcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0sXHJcblx0XHRcdFx0XHRcdFx0XHRsYXN0ID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcclxuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XHJcblx0XHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBvYmplY3QgaXMgYWN0aXZlLCBqdXN0IHN3YXAgd2l0aCB0aGUgbGFzdCBhbmQgcG9wXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXHJcblx0XHRcdFx0XHRcdFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBpbmRleDtcclxuXHRcdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XHJcblx0XHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xyXG5cdFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcclxuXHJcblx0XHRcdFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cclxuXHJcblx0XHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xyXG5cclxuXHRcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEludGVybmFsIGludGVyZmFjZSB1c2VkIGJ5IGJlZnJpZW5kZWQgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZTpcclxuXHJcblx0XHRzdWJzY3JpYmVfOiBmdW5jdGlvbiAoIHBhdGgsIHBhcnNlZFBhdGggKSB7XHJcblxyXG5cdFx0XHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcclxuXHRcdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb250YWluZWQgb2JqZWN0cyBpbiB0aGUgZ3JvdXBcclxuXHJcblx0XHRcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxyXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdLFxyXG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XHJcblxyXG5cdFx0XHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcclxuXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxyXG5cdFx0XHRcdG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxyXG5cdFx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXHJcblx0XHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcclxuXHRcdFx0XHRiaW5kaW5nc0ZvclBhdGggPSBuZXcgQXJyYXkoIG5PYmplY3RzICk7XHJcblxyXG5cdFx0XHRpbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcclxuXHJcblx0XHRcdGluZGljZXNCeVBhdGhbIHBhdGggXSA9IGluZGV4O1xyXG5cclxuXHRcdFx0cGF0aHMucHVzaCggcGF0aCApO1xyXG5cdFx0XHRwYXJzZWRQYXRocy5wdXNoKCBwYXJzZWRQYXRoICk7XHJcblx0XHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xyXG5cdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaSBdID0gbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYmluZGluZ3NGb3JQYXRoO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dW5zdWJzY3JpYmVfOiBmdW5jdGlvbiAoIHBhdGggKSB7XHJcblxyXG5cdFx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXHJcblx0XHRcdC8vIHVwZGF0ZSB0aGUgYXJyYXkgcHJldmlvdXNseSBvYnRhaW5lZCB3aXRoICdzdWJzY3JpYmVfJ1xyXG5cclxuXHRcdFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXHJcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwYXRocyA9IHRoaXMuX3BhdGhzLFxyXG5cdFx0XHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcclxuXHRcdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdFx0XHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXHJcblx0XHRcdFx0XHRsYXN0QmluZGluZ3MgPSBiaW5kaW5nc1sgbGFzdEJpbmRpbmdzSW5kZXggXSxcclxuXHRcdFx0XHRcdGxhc3RCaW5kaW5nc1BhdGggPSBwYXRoWyBsYXN0QmluZGluZ3NJbmRleCBdO1xyXG5cclxuXHRcdFx0XHRpbmRpY2VzQnlQYXRoWyBsYXN0QmluZGluZ3NQYXRoIF0gPSBpbmRleDtcclxuXHJcblx0XHRcdFx0YmluZGluZ3NbIGluZGV4IF0gPSBsYXN0QmluZGluZ3M7XHJcblx0XHRcdFx0YmluZGluZ3MucG9wKCk7XHJcblxyXG5cdFx0XHRcdHBhcnNlZFBhdGhzWyBpbmRleCBdID0gcGFyc2VkUGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XHJcblx0XHRcdFx0cGFyc2VkUGF0aHMucG9wKCk7XHJcblxyXG5cdFx0XHRcdHBhdGhzWyBpbmRleCBdID0gcGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XHJcblx0XHRcdFx0cGF0aHMucG9wKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqXHJcblx0ICogQWN0aW9uIHByb3ZpZGVkIGJ5IEFuaW1hdGlvbk1peGVyIGZvciBzY2hlZHVsaW5nIGNsaXAgcGxheWJhY2sgb24gc3BlY2lmaWNcclxuXHQgKiBvYmplY3RzLlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICpcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQW5pbWF0aW9uQWN0aW9uKCBtaXhlciwgY2xpcCwgbG9jYWxSb290ICkge1xyXG5cclxuXHRcdHRoaXMuX21peGVyID0gbWl4ZXI7XHJcblx0XHR0aGlzLl9jbGlwID0gY2xpcDtcclxuXHRcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdCB8fCBudWxsO1xyXG5cclxuXHRcdHZhciB0cmFja3MgPSBjbGlwLnRyYWNrcyxcclxuXHRcdFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXHJcblx0XHRcdGludGVycG9sYW50cyA9IG5ldyBBcnJheSggblRyYWNrcyApO1xyXG5cclxuXHRcdHZhciBpbnRlcnBvbGFudFNldHRpbmdzID0ge1xyXG5cdFx0XHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcclxuXHRcdFx0ZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXHJcblx0XHR9O1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRyYWNrc1sgaSBdLmNyZWF0ZUludGVycG9sYW50KCBudWxsICk7XHJcblx0XHRcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XHJcblx0XHRcdGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XHJcblxyXG5cdFx0dGhpcy5faW50ZXJwb2xhbnRzID0gaW50ZXJwb2xhbnRzO1x0Ly8gYm91bmQgYnkgdGhlIG1peGVyXHJcblxyXG5cdFx0Ly8gaW5zaWRlOiBQcm9wZXJ0eU1peGVyIChtYW5hZ2VkIGJ5IHRoZSBtaXhlcilcclxuXHRcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcclxuXHJcblx0XHR0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDtcdFx0XHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXHJcblx0XHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxyXG5cclxuXHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcclxuXHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xyXG5cdFx0dGhpcy5fbG9vcENvdW50ID0gLSAxO1xyXG5cclxuXHRcdC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXHJcblx0XHQvLyBpdCdzIHNldCBiYWNrIHRvICdudWxsJyB1cG9uIHN0YXJ0IG9mIHRoZSBhY3Rpb25cclxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XHJcblxyXG5cdFx0Ly8gc2NhbGVkIGxvY2FsIHRpbWUgb2YgdGhlIGFjdGlvblxyXG5cdFx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxyXG5cdFx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0XHR0aGlzLnRpbWVTY2FsZSA9IDE7XHJcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xyXG5cclxuXHRcdHRoaXMud2VpZ2h0ID0gMTtcclxuXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XHJcblxyXG5cdFx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyBcdFx0Ly8gbm8uIG9mIHJlcGV0aXRpb25zIHdoZW4gbG9vcGluZ1xyXG5cclxuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XHRcdFx0XHQvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcclxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHRcdFx0XHQvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB3ZWlnaHRcclxuXHJcblx0XHR0aGlzLmNsYW1wV2hlbkZpbmlzaGVkIFx0PSBmYWxzZTtcdC8vIGtlZXAgZmVlZGluZyB0aGUgbGFzdCBmcmFtZT9cclxuXHJcblx0XHR0aGlzLnplcm9TbG9wZUF0U3RhcnQgXHQ9IHRydWU7XHRcdC8vIGZvciBzbW9vdGggaW50ZXJwb2xhdGlvbiB3L28gc2VwYXJhdGVcclxuXHRcdHRoaXMuemVyb1Nsb3BlQXRFbmRcdFx0PSB0cnVlO1x0XHQvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkFjdGlvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0XHQvLyBTdGF0ZSAmIFNjaGVkdWxpbmdcclxuXHJcblx0XHRwbGF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5fbWl4ZXIuX2RlYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnJlc2V0KCk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZXNldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcblx0XHRcdHRoaXMudGltZSA9IDA7XHRcdFx0Ly8gcmVzdGFydCBjbGlwXHJcblx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IC0gMTtcdC8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xyXG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1x0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKS5zdG9wV2FycGluZygpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aXNSdW5uaW5nOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcclxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcclxuXHRcdGlzU2NoZWR1bGVkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdGFydEF0OiBmdW5jdGlvbiAoIHRpbWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRMb29wOiBmdW5jdGlvbiAoIG1vZGUsIHJlcGV0aXRpb25zICkge1xyXG5cclxuXHRcdFx0dGhpcy5sb29wID0gbW9kZTtcclxuXHRcdFx0dGhpcy5yZXBldGl0aW9ucyA9IHJlcGV0aXRpb25zO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBXZWlnaHRcclxuXHJcblx0XHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xyXG5cdFx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXHJcblx0XHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLmVuYWJsZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXHJcblx0XHRzZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uICggd2VpZ2h0ICkge1xyXG5cclxuXHRcdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdFx0XHQvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXHJcblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyByZXR1cm4gdGhlIHdlaWdodCBjb25zaWRlcmluZyBmYWRpbmcgYW5kIC5lbmFibGVkXHJcblx0XHRnZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVXZWlnaHQ7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmYWRlSW46IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAwLCAxICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRmYWRlT3V0OiBmdW5jdGlvbiAoIGR1cmF0aW9uICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMSwgMCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y3Jvc3NGYWRlRnJvbTogZnVuY3Rpb24gKCBmYWRlT3V0QWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcclxuXHJcblx0XHRcdGZhZGVPdXRBY3Rpb24uZmFkZU91dCggZHVyYXRpb24gKTtcclxuXHRcdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIHdhcnAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBmYWRlSW5EdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXHJcblx0XHRcdFx0XHRmYWRlT3V0RHVyYXRpb24gPSBmYWRlT3V0QWN0aW9uLl9jbGlwLmR1cmF0aW9uLFxyXG5cclxuXHRcdFx0XHRcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcclxuXHRcdFx0XHRcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcclxuXHJcblx0XHRcdFx0ZmFkZU91dEFjdGlvbi53YXJwKCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XHJcblx0XHRcdFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNyb3NzRmFkZVRvOiBmdW5jdGlvbiAoIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFkZUluQWN0aW9uLmNyb3NzRmFkZUZyb20oIHRoaXMsIGR1cmF0aW9uLCB3YXJwICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdG9wRmFkaW5nOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcclxuXHJcblx0XHRcdGlmICggd2VpZ2h0SW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcclxuXHRcdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHdlaWdodEludGVycG9sYW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIFRpbWUgU2NhbGUgQ29udHJvbFxyXG5cclxuXHRcdC8vIHNldCB0aGUgdGltZSBzY2FsZSBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcclxuXHRcdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXHJcblx0XHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLnBhdXNlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcclxuXHRcdHNldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24gKCB0aW1lU2NhbGUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuXHRcdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHJldHVybiB0aGUgdGltZSBzY2FsZSBjb25zaWRlcmluZyB3YXJwaW5nIGFuZCAucGF1c2VkXHJcblx0XHRnZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREdXJhdGlvbjogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdHRoaXMudGltZVNjYWxlID0gdGhpcy5fY2xpcC5kdXJhdGlvbiAvIGR1cmF0aW9uO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHN5bmNXaXRoOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcclxuXHJcblx0XHRcdHRoaXMudGltZSA9IGFjdGlvbi50aW1lO1xyXG5cdFx0XHR0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aGFsdDogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLndhcnAoIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSwgMCwgZHVyYXRpb24gKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHdhcnA6IGZ1bmN0aW9uICggc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XHJcblxyXG5cdFx0XHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcclxuXHRcdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxyXG5cclxuXHRcdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcclxuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxyXG5cdFx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcclxuXHJcblx0XHRcdHRpbWVzWyAwIF0gPSBub3c7XHJcblx0XHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcclxuXHJcblx0XHRcdHZhbHVlc1sgMCBdID0gc3RhcnRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XHJcblx0XHRcdHZhbHVlc1sgMSBdID0gZW5kVGltZVNjYWxlIC8gdGltZVNjYWxlO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzdG9wV2FycGluZzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIHRpbWVTY2FsZUludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0XHRpZiAoIHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XHJcblx0XHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB0aW1lU2NhbGVJbnRlcnBvbGFudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBPYmplY3QgQWNjZXNzb3JzXHJcblxyXG5cdFx0Z2V0TWl4ZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9taXhlcjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldENsaXA6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9jbGlwO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0Um9vdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuX2xvY2FsUm9vdCB8fCB0aGlzLl9taXhlci5fcm9vdDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEludGVybmFcclxuXHJcblx0XHRfdXBkYXRlOiBmdW5jdGlvbiAoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICkge1xyXG5cclxuXHRcdFx0Ly8gY2FsbGVkIGJ5IHRoZSBtaXhlclxyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gY2FsbCAuX3VwZGF0ZVdlaWdodCgpIHRvIHVwZGF0ZSAuX2VmZmVjdGl2ZVdlaWdodFxyXG5cclxuXHRcdFx0XHR0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xyXG5cclxuXHRcdFx0aWYgKCBzdGFydFRpbWUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGZvciBzY2hlZHVsZWQgc3RhcnQgb2YgYWN0aW9uXHJcblxyXG5cdFx0XHRcdHZhciB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcclxuXHRcdFx0XHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybjsgLy8geWV0IHRvIGNvbWUgLyBkb24ndCBkZWNpZGUgd2hlbiBkZWx0YSA9IDBcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBzdGFydFxyXG5cclxuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXHJcblx0XHRcdFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXHJcblxyXG5cdFx0XHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XHJcblx0XHRcdHZhciBjbGlwVGltZSA9IHRoaXMuX3VwZGF0ZVRpbWUoIGRlbHRhVGltZSApO1xyXG5cclxuXHRcdFx0Ly8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cclxuXHRcdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXHJcblxyXG5cdFx0XHR2YXIgd2VpZ2h0ID0gdGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XHJcblxyXG5cdFx0XHRpZiAoIHdlaWdodCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XHJcblx0XHRcdFx0dmFyIHByb3BlcnR5TWl4ZXJzID0gdGhpcy5fcHJvcGVydHlCaW5kaW5ncztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKysgaiApIHtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnBvbGFudHNbIGogXS5ldmFsdWF0ZSggY2xpcFRpbWUgKTtcclxuXHRcdFx0XHRcdHByb3BlcnR5TWl4ZXJzWyBqIF0uYWNjdW11bGF0ZSggYWNjdUluZGV4LCB3ZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0X3VwZGF0ZVdlaWdodDogZnVuY3Rpb24gKCB0aW1lICkge1xyXG5cclxuXHRcdFx0dmFyIHdlaWdodCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZW5hYmxlZCApIHtcclxuXHJcblx0XHRcdFx0d2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XHJcblx0XHRcdFx0dmFyIGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XHJcblxyXG5cdFx0XHRcdFx0d2VpZ2h0ICo9IGludGVycG9sYW50VmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0b3BGYWRpbmcoKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggaW50ZXJwb2xhbnRWYWx1ZSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XHJcblx0XHRcdHJldHVybiB3ZWlnaHQ7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiAoIHRpbWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGltZVNjYWxlID0gMDtcclxuXHJcblx0XHRcdGlmICggISB0aGlzLnBhdXNlZCApIHtcclxuXHJcblx0XHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XHJcblxyXG5cdFx0XHRcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xyXG5cclxuXHRcdFx0XHRpZiAoIGludGVycG9sYW50ICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xyXG5cclxuXHRcdFx0XHRcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sgMSBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5zdG9wV2FycGluZygpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIG1vdGlvbiBoYXMgaGFsdGVkLCBwYXVzZVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcclxuXHRcdFx0cmV0dXJuIHRpbWVTY2FsZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF91cGRhdGVUaW1lOiBmdW5jdGlvbiAoIGRlbHRhVGltZSApIHtcclxuXHJcblx0XHRcdHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xyXG5cclxuXHRcdFx0aWYgKCBkZWx0YVRpbWUgPT09IDAgKSByZXR1cm4gdGltZTtcclxuXHJcblx0XHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXHJcblxyXG5cdFx0XHRcdGxvb3AgPSB0aGlzLmxvb3AsXHJcblx0XHRcdFx0bG9vcENvdW50ID0gdGhpcy5fbG9vcENvdW50O1xyXG5cclxuXHRcdFx0aWYgKCBsb29wID09PSBMb29wT25jZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBqdXN0IHN0YXJ0ZWRcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9sb29wQ291bnQgPSAwO1xyXG5cdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdHJ1ZSwgZmFsc2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRoYW5kbGVfc3RvcDoge1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBicmVhayBoYW5kbGVfc3RvcDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcclxuXHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxyXG5cdFx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA8IDAgPyAtIDEgOiAxXHJcblx0XHRcdFx0XHR9ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7IC8vIHJlcGV0aXRpdmUgUmVwZWF0IG9yIFBpbmdQb25nXHJcblxyXG5cdFx0XHRcdHZhciBwaW5nUG9uZyA9ICggbG9vcCA9PT0gTG9vcFBpbmdQb25nICk7XHJcblxyXG5cdFx0XHRcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBkZWx0YVRpbWUgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGxvb3BDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXHJcblx0XHRcdFx0XHRcdC8vIHRyYW5zaXRpb24gdGhyb3VnaCB6ZXJvIGNvdW50cyBhcyBhIHJlcGV0aXRpb24sXHJcblx0XHRcdFx0XHRcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy5fc2V0RW5kaW5ncyggdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHdyYXAgYXJvdW5kXHJcblxyXG5cdFx0XHRcdFx0dmFyIGxvb3BEZWx0YSA9IE1hdGguZmxvb3IoIHRpbWUgLyBkdXJhdGlvbiApOyAvLyBzaWduZWRcclxuXHRcdFx0XHRcdHRpbWUgLT0gZHVyYXRpb24gKiBsb29wRGVsdGE7XHJcblxyXG5cdFx0XHRcdFx0bG9vcENvdW50ICs9IE1hdGguYWJzKCBsb29wRGVsdGEgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwZW5kaW5nIDwgMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGhhdmUgdG8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxyXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtIDFcclxuXHRcdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBrZWVwIHJ1bm5pbmdcclxuXHJcblx0XHRcdFx0XHRcdGlmICggcGVuZGluZyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZW50ZXJpbmcgdGhlIGxhc3Qgcm91bmRcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcclxuXHRcdFx0XHRcdFx0fSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGludmVydCB0aW1lIGZvciB0aGUgXCJwb25nIHJvdW5kXCJcclxuXHJcblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy50aW1lID0gdGltZTtcclxuXHRcdFx0cmV0dXJuIHRpbWU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfc2V0RW5kaW5nczogZnVuY3Rpb24gKCBhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcgKSB7XHJcblxyXG5cdFx0XHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xyXG5cclxuXHRcdFx0aWYgKCBwaW5nUG9uZyApIHtcclxuXHJcblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgXHQ9IFplcm9TbG9wZUVuZGluZztcclxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmRcdFx0PSBaZXJvU2xvcGVFbmRpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBhc3N1bWluZyBmb3IgTG9vcE9uY2UgYXRTdGFydCA9PSBhdEVuZCA9PSB0cnVlXHJcblxyXG5cdFx0XHRcdGlmICggYXRTdGFydCApIHtcclxuXHJcblx0XHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IHRoaXMuemVyb1Nsb3BlQXRTdGFydCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBXcmFwQXJvdW5kRW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYXRFbmQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kIFx0ID0gV3JhcEFyb3VuZEVuZGluZztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiAoIGR1cmF0aW9uLCB3ZWlnaHROb3csIHdlaWdodFRoZW4gKSB7XHJcblxyXG5cdFx0XHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcclxuXHRcdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xyXG5cclxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xyXG5cdFx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXHJcblx0XHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xyXG5cclxuXHRcdFx0dGltZXNbIDAgXSA9IG5vdzsgXHRcdFx0XHR2YWx1ZXNbIDAgXSA9IHdlaWdodE5vdztcclxuXHRcdFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1x0dmFsdWVzWyAxIF0gPSB3ZWlnaHRUaGVuO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqXHJcblx0ICogUGxheWVyIGZvciBBbmltYXRpb25DbGlwcy5cclxuXHQgKlxyXG5cdCAqXHJcblx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cclxuXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cclxuXHQgKiBAYXV0aG9yIHRzY2h3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEFuaW1hdGlvbk1peGVyKCByb290ICkge1xyXG5cclxuXHRcdHRoaXMuX3Jvb3QgPSByb290O1xyXG5cdFx0dGhpcy5faW5pdE1lbW9yeU1hbmFnZXIoKTtcclxuXHRcdHRoaXMuX2FjY3VJbmRleCA9IDA7XHJcblxyXG5cdFx0dGhpcy50aW1lID0gMDtcclxuXHJcblx0XHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcclxuXHJcblx0fVxyXG5cclxuXHRBbmltYXRpb25NaXhlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uTWl4ZXIsXHJcblxyXG5cdFx0X2JpbmRBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKSB7XHJcblxyXG5cdFx0XHR2YXIgcm9vdCA9IGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QsXHJcblx0XHRcdFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcclxuXHRcdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcclxuXHRcdFx0XHRiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncyxcclxuXHRcdFx0XHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcclxuXHRcdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcclxuXHRcdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcclxuXHRcdFx0XHRiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBiaW5kaW5nc0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc0J5TmFtZSA9IHt9O1xyXG5cdFx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdLFxyXG5cdFx0XHRcdFx0dHJhY2tOYW1lID0gdHJhY2submFtZSxcclxuXHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0J5TmFtZVsgdHJhY2tOYW1lIF07XHJcblxyXG5cdFx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZXhpc3RpbmcgYmluZGluZywgbWFrZSBzdXJlIHRoZSBjYWNoZSBrbm93c1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cclxuXHRcdFx0XHRcdFx0X3Byb3BlcnR5QmluZGluZ3NbIGkgXS5iaW5kaW5nLnBhcnNlZFBhdGg7XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eU1peGVyKFxyXG5cdFx0XHRcdFx0XHRQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlKCByb290LCB0cmFja05hbWUsIHBhdGggKSxcclxuXHRcdFx0XHRcdFx0dHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkgKTtcclxuXHJcblx0XHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xyXG5cdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XHJcblxyXG5cdFx0XHRcdFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhY3Rpb24uX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXHJcblx0XHRcdFx0XHQvLyBhcHBlYXJzIHRvIGJlIHN0aWxsIHVzaW5nIGl0IC0+IHJlYmluZFxyXG5cclxuXHRcdFx0XHRcdHZhciByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXHJcblx0XHRcdFx0XHRcdGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXHJcblx0XHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcclxuXHJcblx0XHRcdFx0XHR0aGlzLl9iaW5kQWN0aW9uKCBhY3Rpb24sXHJcblx0XHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwICYmIGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xyXG5cclxuXHRcdFx0XHQvLyBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xyXG5cdFx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0X2RlYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcclxuXHJcblx0XHRcdFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAtLSBiaW5kaW5nLnVzZUNvdW50ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gTWVtb3J5IG1hbmFnZXJcclxuXHJcblx0XHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXHJcblx0XHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcclxuXHJcblx0XHRcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTtcclxuXHRcdFx0Ly8gaW5zaWRlOlxyXG5cdFx0XHQvLyB7XHJcblx0XHRcdC8vIFx0XHRrbm93bkFjdGlvbnM6IEFycmF5PCBBbmltYXRpb25BY3Rpb24gPlx0LSB1c2VkIGFzIHByb3RvdHlwZXNcclxuXHRcdFx0Ly8gXHRcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uXHRcdFx0LSBsb29rdXBcclxuXHRcdFx0Ly8gfVxyXG5cclxuXHJcblx0XHRcdHRoaXMuX2JpbmRpbmdzID0gW107IC8vICduQWN0aXZlQmluZGluZ3MnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcclxuXHRcdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcclxuXHJcblx0XHRcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XHJcblxyXG5cclxuXHRcdFx0dGhpcy5fY29udHJvbEludGVycG9sYW50cyA9IFtdOyAvLyBzYW1lIGdhbWUgYXMgYWJvdmVcclxuXHRcdFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xyXG5cclxuXHRcdFx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0XHRcdHRoaXMuc3RhdHMgPSB7XHJcblxyXG5cdFx0XHRcdGFjdGlvbnM6IHtcclxuXHRcdFx0XHRcdGdldCB0b3RhbCgpIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fYWN0aW9ucy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdGdldCBpblVzZSgpIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0YmluZGluZ3M6IHtcclxuXHRcdFx0XHRcdGdldCB0b3RhbCgpIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5ncztcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRjb250cm9sSW50ZXJwb2xhbnRzOiB7XHJcblx0XHRcdFx0XHRnZXQgdG90YWwoKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRnZXQgaW5Vc2UoKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzXHJcblxyXG5cdFx0X2lzQWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcclxuXHRcdFx0cmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4IDwgdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfYWRkSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXHJcblx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHtcclxuXHJcblx0XHRcdFx0XHRrbm93bkFjdGlvbnM6IFsgYWN0aW9uIF0sXHJcblx0XHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XHJcblxyXG5cdFx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0gPSBhY3Rpb25zRm9yQ2xpcDtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XHJcblxyXG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XHJcblx0XHRcdFx0a25vd25BY3Rpb25zLnB1c2goIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XHJcblx0XHRcdGFjdGlvbnMucHVzaCggYWN0aW9uICk7XHJcblxyXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gPSBhY3Rpb247XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xyXG5cclxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdLFxyXG5cdFx0XHRcdGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XHJcblxyXG5cdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xyXG5cdFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XHJcblx0XHRcdGFjdGlvbnMucG9wKCk7XHJcblxyXG5cdFx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xyXG5cclxuXHJcblx0XHRcdHZhciBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxyXG5cdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcclxuXHRcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zLFxyXG5cclxuXHRcdFx0XHRsYXN0S25vd25BY3Rpb24gPVxyXG5cdFx0XHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggLSAxIF0sXHJcblxyXG5cdFx0XHRcdGJ5Q2xpcENhY2hlSW5kZXggPSBhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXg7XHJcblxyXG5cdFx0XHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xyXG5cdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBieUNsaXBDYWNoZUluZGV4IF0gPSBsYXN0S25vd25BY3Rpb247XHJcblx0XHRcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XHJcblxyXG5cdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xyXG5cclxuXHJcblx0XHRcdHZhciBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3QsXHJcblx0XHRcdFx0cm9vdFV1aWQgPSAoIGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QgKS51dWlkO1xyXG5cclxuXHRcdFx0ZGVsZXRlIGFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHRcdGlmICgga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIC0tIGJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF9sZW5kQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcclxuXHJcblx0XHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cclxuXHRcdFx0Ly8gICAgICAgICAgICAgICAgIHMgICAgICAgIGFcclxuXHRcdFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxyXG5cdFx0XHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xyXG5cclxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMgKyssXHJcblxyXG5cdFx0XHRcdGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcclxuXHRcdFx0YWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBhY3Rpb247XHJcblxyXG5cdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfdGFrZUJhY2tBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xyXG5cclxuXHRcdFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgIHwgaW5hY3RpdmUgYWN0aW9ucyBdXHJcblx0XHRcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfDwgaW5hY3RpdmUgYWN0aW9ucyAgXVxyXG5cdFx0XHQvLyAgICAgICAgYSAgICAgICAgc1xyXG5cdFx0XHQvLyAgICAgICAgIDwtc3dhcC0+XHJcblx0XHRcdC8vICAgICAgICBzICAgICAgICBhXHJcblxyXG5cdFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXHJcblx0XHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxyXG5cclxuXHRcdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcclxuXHJcblx0XHRcdFx0bGFzdEFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xyXG5cdFx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUFjdGlvbjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBQcm9wZXJ0eU1peGVyIG9iamVjdHNcclxuXHJcblx0XHRfYWRkSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKSB7XHJcblxyXG5cdFx0XHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXHJcblx0XHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxyXG5cclxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xyXG5cclxuXHRcdFx0aWYgKCBiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGJpbmRpbmdCeU5hbWUgPSB7fTtcclxuXHRcdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdCeU5hbWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXSA9IGJpbmRpbmc7XHJcblxyXG5cdFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xyXG5cdFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0XHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcclxuXHRcdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXHJcblx0XHRcdFx0dHJhY2tOYW1lID0gcHJvcEJpbmRpbmcucGF0aCxcclxuXHRcdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcclxuXHRcdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXHJcblxyXG5cdFx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxyXG5cdFx0XHRcdGNhY2hlSW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4O1xyXG5cclxuXHRcdFx0bGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XHJcblx0XHRcdGJpbmRpbmdzWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVCaW5kaW5nO1xyXG5cdFx0XHRiaW5kaW5ncy5wb3AoKTtcclxuXHJcblx0XHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcclxuXHJcblx0XHRcdHJlbW92ZV9lbXB0eV9tYXA6IHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIF8gaW4gYmluZGluZ0J5TmFtZSApIGJyZWFrIHJlbW92ZV9lbXB0eV9tYXA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuXHJcblx0XHRcdFx0ZGVsZXRlIGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0X2xlbmRCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XHJcblxyXG5cdFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcclxuXHRcdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxyXG5cclxuXHRcdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXHJcblxyXG5cdFx0XHRcdGZpcnN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdO1xyXG5cclxuXHRcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcclxuXHRcdFx0YmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcclxuXHJcblx0XHRcdGZpcnN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xyXG5cdFx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQmluZGluZztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF90YWtlQmFja0JpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZyApIHtcclxuXHJcblx0XHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXHJcblxyXG5cdFx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVCaW5kaW5ncyxcclxuXHJcblx0XHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xyXG5cdFx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xyXG5cclxuXHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVCaW5kaW5nO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXHJcblxyXG5cdFx0X2xlbmRDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxyXG5cdFx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzICsrLFxyXG5cdFx0XHRcdGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXTtcclxuXHJcblx0XHRcdGlmICggaW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgTGluZWFySW50ZXJwb2xhbnQoXHJcblx0XHRcdFx0XHRuZXcgRmxvYXQzMkFycmF5KCAyICksIG5ldyBGbG9hdDMyQXJyYXkoIDIgKSxcclxuXHRcdFx0XHRcdDEsIHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgKTtcclxuXHJcblx0XHRcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xyXG5cdFx0XHRcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbnRlcnBvbGFudDtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCBpbnRlcnBvbGFudCApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxyXG5cdFx0XHRcdHByZXZJbmRleCA9IGludGVycG9sYW50Ll9fY2FjaGVJbmRleCxcclxuXHJcblx0XHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMsXHJcblxyXG5cdFx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XHJcblxyXG5cdFx0XHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XHJcblx0XHRcdGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcclxuXHJcblx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XHJcblx0XHRcdGludGVycG9sYW50c1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRfY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheSggMSApLFxyXG5cclxuXHRcdC8vIHJldHVybiBhbiBhY3Rpb24gZm9yIGEgY2xpcCBvcHRpb25hbGx5IHVzaW5nIGEgY3VzdG9tIHJvb3QgdGFyZ2V0XHJcblx0XHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcclxuXHRcdC8vIHByZXZpb3VzbHkgdW5rbm93biBjbGlwL3Jvb3QgY29tYmluYXRpb24gaXMgc3BlY2lmaWVkKVxyXG5cdFx0Y2xpcEFjdGlvbjogZnVuY3Rpb24gKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxyXG5cdFx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxyXG5cclxuXHRcdFx0XHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cclxuXHRcdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcclxuXHJcblx0XHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ICE9PSBudWxsID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcclxuXHJcblx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLFxyXG5cdFx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBleGlzdGluZ0FjdGlvbiA9XHJcblx0XHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBleGlzdGluZ0FjdGlvbjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyB3ZSBrbm93IHRoZSBjbGlwLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHBhcnNlIGFsbFxyXG5cdFx0XHRcdC8vIHRoZSBiaW5kaW5ncyBhZ2FpbiBidXQgY2FuIGp1c3QgY29weVxyXG5cdFx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xyXG5cclxuXHRcdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cclxuXHRcdFx0XHRpZiAoIGNsaXBPYmplY3QgPT09IG51bGwgKVxyXG5cdFx0XHRcdFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNsaXAgbXVzdCBiZSBrbm93biB3aGVuIHNwZWNpZmllZCB2aWEgc3RyaW5nXHJcblx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0Ly8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcclxuXHRcdFx0dmFyIG5ld0FjdGlvbiA9IG5ldyBBbmltYXRpb25BY3Rpb24oIHRoaXMsIGNsaXBPYmplY3QsIG9wdGlvbmFsUm9vdCApO1xyXG5cclxuXHRcdFx0dGhpcy5fYmluZEFjdGlvbiggbmV3QWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKTtcclxuXHJcblx0XHRcdC8vIGFuZCBtYWtlIHRoZSBhY3Rpb24ga25vd24gdG8gdGhlIG1lbW9yeSBtYW5hZ2VyXHJcblx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBuZXdBY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ld0FjdGlvbjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGdldCBhbiBleGlzdGluZyBhY3Rpb25cclxuXHRcdGV4aXN0aW5nQWN0aW9uOiBmdW5jdGlvbiAoIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcclxuXHJcblx0XHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXHJcblx0XHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXHJcblxyXG5cdFx0XHRcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgP1xyXG5cdFx0XHRcdFx0QW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwLFxyXG5cclxuXHRcdFx0XHRjbGlwVXVpZCA9IGNsaXBPYmplY3QgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwLFxyXG5cclxuXHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XHJcblxyXG5cdFx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gfHwgbnVsbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcclxuXHRcdHN0b3BBbGxBY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcclxuXHRcdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxyXG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXHJcblx0XHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xyXG5cclxuXHRcdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xyXG5cdFx0XHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YWN0aW9uc1sgaSBdLnJlc2V0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0YmluZGluZ3NbIGkgXS51c2VDb3VudCA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXHJcblx0XHR1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGFUaW1lICkge1xyXG5cclxuXHRcdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xyXG5cclxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXHJcblxyXG5cdFx0XHRcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxyXG5cdFx0XHRcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxyXG5cclxuXHRcdFx0XHRhY2N1SW5kZXggPSB0aGlzLl9hY2N1SW5kZXggXj0gMTtcclxuXHJcblx0XHRcdC8vIHJ1biBhY3RpdmUgYWN0aW9uc1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFjdGlvbiA9IGFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRcdFx0YWN0aW9uLl91cGRhdGUoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcclxuXHJcblx0XHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxyXG5cdFx0XHRcdG5CaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdLmFwcGx5KCBhY2N1SW5kZXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcmV0dXJuIHRoaXMgbWl4ZXIncyByb290IHRhcmdldCBvYmplY3RcclxuXHRcdGdldFJvb3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLl9yb290O1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXHJcblx0XHR1bmNhY2hlQ2xpcDogZnVuY3Rpb24gKCBjbGlwICkge1xyXG5cclxuXHRcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxyXG5cdFx0XHRcdGNsaXBVdWlkID0gY2xpcC51dWlkLFxyXG5cdFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxyXG5cdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcclxuXHJcblx0XHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxyXG5cdFx0XHRcdC8vIGl0ZXJhdGlvbiBzdGF0ZSBhbmQgYWxzbyByZXF1aXJlIHVwZGF0aW5nIHRoZSBzdGF0ZSB3ZSBjYW5cclxuXHRcdFx0XHQvLyBqdXN0IHRocm93IGF3YXlcclxuXHJcblx0XHRcdFx0dmFyIGFjdGlvbnNUb1JlbW92ZSA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucztcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYWN0aW9uc1RvUmVtb3ZlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYWN0aW9uID0gYWN0aW9uc1RvUmVtb3ZlWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXHJcblx0XHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHRcdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XHJcblx0XHRcdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XHJcblx0XHRcdFx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XHJcblx0XHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciByb290IHRhcmdldCBvYmplY3RcclxuXHRcdHVuY2FjaGVSb290OiBmdW5jdGlvbiAoIHJvb3QgKSB7XHJcblxyXG5cdFx0XHR2YXIgcm9vdFV1aWQgPSByb290LnV1aWQsXHJcblx0XHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgY2xpcFV1aWQgaW4gYWN0aW9uc0J5Q2xpcCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0uYWN0aW9uQnlSb290LFxyXG5cdFx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGFjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xyXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXHJcblx0XHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xyXG5cclxuXHRcdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xyXG5cdFx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xyXG5cdFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHJlbW92ZSBhIHRhcmdldGVkIGNsaXAgZnJvbSB0aGUgY2FjaGVcclxuXHRcdHVuY2FjaGVBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xyXG5cclxuXHRcdFx0dmFyIGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xyXG5cclxuXHRcdFx0aWYgKCBhY3Rpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gVW5pZm9ybSggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogVHlwZSBwYXJhbWV0ZXIgaXMgbm8gbG9uZ2VyIG5lZWRlZC4nICk7XHJcblx0XHRcdHZhbHVlID0gYXJndW1lbnRzWyAxIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRVbmlmb3JtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFVuaWZvcm0oIHRoaXMudmFsdWUuY2xvbmUgPT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmNsb25lKCkgKTtcclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkge1xyXG5cclxuXHRcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknO1xyXG5cdFx0dGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHVuZGVmaW5lZDtcclxuXHJcblx0fVxyXG5cclxuXHRJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSxcclxuXHJcblx0XHRpc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5OiB0cnVlLFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gc291cmNlLm1heEluc3RhbmNlZENvdW50O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBub3JtYWxpemVkICkge1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xyXG5cdFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xyXG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Y291bnQ6IHtcclxuXHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0YXJyYXk6IHtcclxuXHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxyXG5cclxuXHRcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcclxuXHJcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcclxuXHJcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcclxuXHJcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xyXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcclxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xyXG5cclxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XHJcblx0XHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xyXG5cdFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcclxuXHRcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlICkge1xyXG5cclxuXHRcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xyXG5cclxuXHRcdHRoaXMuYXJyYXkgPSBhcnJheTtcclxuXHRcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xyXG5cdFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyBzdHJpZGUgOiAwO1xyXG5cclxuXHRcdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cdFx0dGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XHJcblxyXG5cdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdFx0dGhpcy52ZXJzaW9uID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSwgJ25lZWRzVXBkYXRlJywge1xyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGlzSW50ZXJsZWF2ZWRCdWZmZXI6IHRydWUsXHJcblxyXG5cdFx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XHJcblxyXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGUgOiAwO1xyXG5cdFx0XHR0aGlzLmFycmF5ID0gYXJyYXk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0dGhpcy5keW5hbWljID0gdmFsdWU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xyXG5cdFx0XHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xyXG5cdFx0XHR0aGlzLnN0cmlkZSA9IHNvdXJjZS5zdHJpZGU7XHJcblx0XHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcclxuXHJcblx0XHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcclxuXHRcdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5zdHJpZGU7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdG9uVXBsb2FkOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdEludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcclxuXHJcblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XHJcblxyXG5cdH1cclxuXHJcblx0SW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICksIHtcclxuXHJcblx0XHRjb25zdHJ1Y3RvcjogSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsXHJcblxyXG5cdFx0aXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjogdHJ1ZSxcclxuXHJcblx0XHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcclxuXHJcblx0XHRcdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xyXG5cclxuXHRcdFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xyXG5cclxuXHRcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcblx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XHJcblxyXG5cdH1cclxuXHJcblx0SW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKSwge1xyXG5cclxuXHRcdGNvbnN0cnVjdG9yOiBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsXHJcblxyXG5cdFx0aXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XHJcblxyXG5cdFx0XHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXHJcblx0ICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFJheWNhc3Rlciggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHR0aGlzLnJheSA9IG5ldyBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblx0XHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxyXG5cclxuXHRcdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcclxuXHRcdHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xyXG5cclxuXHRcdHRoaXMucGFyYW1zID0ge1xyXG5cdFx0XHRNZXNoOiB7fSxcclxuXHRcdFx0TGluZToge30sXHJcblx0XHRcdExPRDoge30sXHJcblx0XHRcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcclxuXHRcdFx0U3ByaXRlOiB7fVxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcclxuXHRcdFx0UG9pbnRDbG91ZDoge1xyXG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3RlcjogcGFyYW1zLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBwYXJhbXMuUG9pbnRzLicgKTtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLlBvaW50cztcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYXNjU29ydCggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIFJheWNhc3Rlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRsaW5lUHJlY2lzaW9uOiAxLFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcclxuXHJcblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXHJcblxyXG5cdFx0XHR0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCAoIGNhbWVyYSAmJiBjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSApICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoICggY2FtZXJhICYmIGNhbWVyYS5pc09ydGhvZ3JhcGhpY0NhbWVyYSApICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksICggY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyICkgLyAoIGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhciApICkudW5wcm9qZWN0KCBjYW1lcmEgKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcclxuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtIDEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0aW50ZXJzZWN0T2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xyXG5cclxuXHRcdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XHJcblxyXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XHJcblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIENsb2NrKCBhdXRvU3RhcnQgKSB7XHJcblxyXG5cdFx0dGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xyXG5cclxuXHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcclxuXHRcdHRoaXMub2xkVGltZSA9IDA7XHJcblx0XHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcclxuXHJcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBDbG9jay5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzdGFydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSAoIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UgKS5ub3coKTsgLy8gc2VlICMxMDczMlxyXG5cclxuXHRcdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcblx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xyXG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xyXG5cdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdldERlbHRhKCk7XHJcblx0XHRcdHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciBkaWZmID0gMDtcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc3RhcnQoKTtcclxuXHRcdFx0XHRyZXR1cm4gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbmV3VGltZSA9ICggdHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyA/IERhdGUgOiBwZXJmb3JtYW5jZSApLm5vdygpO1xyXG5cclxuXHRcdFx0XHRkaWZmID0gKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICkgLyAxMDAwO1xyXG5cdFx0XHRcdHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XHJcblxyXG5cdFx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkaWZmO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICpcclxuXHQgKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxyXG5cdCAqXHJcblx0ICogVGhlIHBvbGVzIChwaGkpIGFyZSBhdCB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHkgYXhpcy5cclxuXHQgKiBUaGUgZXF1YXRvciBzdGFydHMgYXQgcG9zaXRpdmUgei5cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gU3BoZXJpY2FsKCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XHJcblxyXG5cdFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAxLjA7XHJcblx0XHR0aGlzLnBoaSA9ICggcGhpICE9PSB1bmRlZmluZWQgKSA/IHBoaSA6IDA7IC8vIHVwIC8gZG93biB0b3dhcmRzIHRvcCBhbmQgYm90dG9tIHBvbGVcclxuXHRcdHRoaXMudGhldGEgPSAoIHRoZXRhICE9PSB1bmRlZmluZWQgKSA/IHRoZXRhIDogMDsgLy8gYXJvdW5kIHRoZSBlcXVhdG9yIG9mIHRoZSBzcGhlcmVcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fVxyXG5cclxuXHRPYmplY3QuYXNzaWduKCBTcGhlcmljYWwucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcclxuXHJcblx0XHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cdFx0XHR0aGlzLnBoaSA9IHBoaTtcclxuXHRcdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcclxuXHJcblx0XHRcdHRoaXMucmFkaXVzID0gb3RoZXIucmFkaXVzO1xyXG5cdFx0XHR0aGlzLnBoaSA9IG90aGVyLnBoaTtcclxuXHRcdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlIEVQUyBhbmQgUEktRVBTXHJcblx0XHRtYWtlU2FmZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xyXG5cdFx0XHR0aGlzLnBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCB0aGlzLnBoaSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHZlYzMgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IHZlYzMubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMucmFkaXVzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRoZXRhID0gMDtcclxuXHRcdFx0XHR0aGlzLnBoaSA9IDA7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggdmVjMy54LCB2ZWMzLnogKTsgLy8gZXF1YXRvciBhbmdsZSBhcm91bmQgeS11cCBheGlzXHJcblx0XHRcdFx0dGhpcy5waGkgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB2ZWMzLnkgLyB0aGlzLnJhZGl1cywgLSAxLCAxICkgKTsgLy8gcG9sYXIgYW5nbGVcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqXHJcblx0ICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxyXG5cdCAqXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEN5bGluZHJpY2FsKCByYWRpdXMsIHRoZXRhLCB5ICkge1xyXG5cclxuXHRcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXHJcblx0XHR0aGlzLnRoZXRhID0gKCB0aGV0YSAhPT0gdW5kZWZpbmVkICkgPyB0aGV0YSA6IDA7IC8vIGNvdW50ZXJjbG9ja3dpc2UgYW5nbGUgaW4gdGhlIHgteiBwbGFuZSBtZWFzdXJlZCBpbiByYWRpYW5zIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpc1xyXG5cdFx0dGhpcy55ID0gKCB5ICE9PSB1bmRlZmluZWQgKSA/IHkgOiAwOyAvLyBoZWlnaHQgYWJvdmUgdGhlIHgteiBwbGFuZVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEN5bGluZHJpY2FsLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xyXG5cclxuXHRcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcblx0XHRcdHRoaXMudGhldGEgPSB0aGV0YTtcclxuXHRcdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGNvcHk6IGZ1bmN0aW9uICggb3RoZXIgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcclxuXHRcdFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xyXG5cdFx0XHR0aGlzLnkgPSBvdGhlci55O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2ZWMzICkge1xyXG5cclxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIHZlYzMueCAqIHZlYzMueCArIHZlYzMueiAqIHZlYzMueiApO1xyXG5cdFx0XHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggdmVjMy54LCB2ZWMzLnogKTtcclxuXHRcdFx0dGhpcy55ID0gdmVjMy55O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEltbWVkaWF0ZVJlbmRlck9iamVjdCggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCAvKiByZW5kZXJDYWxsYmFjayAqLyApIHt9O1xyXG5cclxuXHR9XHJcblxyXG5cdEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHRJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xyXG5cclxuXHRJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gdHJ1ZTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gVmVydGV4Tm9ybWFsc0hlbHBlciggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcclxuXHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XHJcblxyXG5cdFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBuTm9ybWFscyA9IDA7XHJcblxyXG5cdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XHJcblxyXG5cdFx0aWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGggKiAzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRuTm9ybWFscyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsLmNvdW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XHJcblxyXG5cdFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuXHRWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlcnRleE5vcm1hbHNIZWxwZXI7XHJcblxyXG5cdFZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcblx0XHRcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XHJcblxyXG5cdFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0aWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XHJcblxyXG5cdFx0XHRcdHZhciBpZHggPSAwO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0djEuY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcclxuXHJcblx0XHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuXHRcdFx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBvYmpQb3MgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqTm9ybSA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xyXG5cclxuXHRcdFx0XHR2YXIgaWR4ID0gMDtcclxuXHJcblx0XHRcdFx0Ly8gZm9yIHNpbXBsaWNpdHksIGlnbm9yZSBpbmRleCBhbmQgZHJhd2NhbGxzLCBhbmQgcmVuZGVyIGV2ZXJ5IG5vcm1hbFxyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gb2JqUG9zLmNvdW50OyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0djEuc2V0KCBvYmpQb3MuZ2V0WCggaiApLCBvYmpQb3MuZ2V0WSggaiApLCBvYmpQb3MuZ2V0WiggaiApICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdHYyLnNldCggb2JqTm9ybS5nZXRYKCBqICksIG9iak5vcm0uZ2V0WSggaiApLCBvYmpOb3JtLmdldFooIGogKSApO1xyXG5cclxuXHRcdFx0XHRcdHYyLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcclxuXHJcblx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XHJcblxyXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcclxuXHJcblx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpICk7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gU3BvdExpZ2h0SGVscGVyKCBsaWdodCwgY29sb3IgKSB7XHJcblxyXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbnMgPSBbXHJcblx0XHRcdDAsIDAsIDAsIFx0MCwgMCwgMSxcclxuXHRcdFx0MCwgMCwgMCwgXHQxLCAwLCAxLFxyXG5cdFx0XHQwLCAwLCAwLFx0LSAxLCAwLCAxLFxyXG5cdFx0XHQwLCAwLCAwLCBcdDAsIDEsIDEsXHJcblx0XHRcdDAsIDAsIDAsIFx0MCwgLSAxLCAxXHJcblx0XHRdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDEsIGwgPSAzMjsgaSA8IGw7IGkgKyssIGogKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcclxuXHRcdFx0dmFyIHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0XHRwb3NpdGlvbnMucHVzaChcclxuXHRcdFx0XHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXHJcblx0XHRcdFx0TWF0aC5jb3MoIHAyICksIE1hdGguc2luKCBwMiApLCAxXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xyXG5cclxuXHRcdHRoaXMuY29uZSA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cdFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcG90TGlnaHRIZWxwZXI7XHJcblxyXG5cdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5jb25lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0fTtcclxuXHJcblx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcblx0XHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwO1xyXG5cdFx0XHR2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xyXG5cclxuXHRcdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHR2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxyXG5cdCAqIEBhdXRob3IgTWljaGFlbCBHdWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBnZXRCb25lTGlzdCggb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBib25lTGlzdCA9IFtdO1xyXG5cclxuXHRcdGlmICggb2JqZWN0ICYmIG9iamVjdC5pc0JvbmUgKSB7XHJcblxyXG5cdFx0XHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCBnZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYm9uZUxpc3Q7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gU2tlbGV0b25IZWxwZXIoIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgYm9uZXMgPSBnZXRCb25lTGlzdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzID0gW107XHJcblx0XHR2YXIgY29sb3JzID0gW107XHJcblxyXG5cdFx0dmFyIGNvbG9yMSA9IG5ldyBDb2xvciggMCwgMCwgMSApO1xyXG5cdFx0dmFyIGNvbG9yMiA9IG5ldyBDb2xvciggMCwgMSwgMCApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBib25lID0gYm9uZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xyXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iICk7XHJcblx0XHRcdFx0Y29sb3JzLnB1c2goIGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG5cdFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdHRoaXMucm9vdCA9IG9iamVjdDtcclxuXHRcdHRoaXMuYm9uZXMgPSBib25lcztcclxuXHJcblx0XHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR9XHJcblxyXG5cdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTa2VsZXRvbkhlbHBlcjtcclxuXHJcblx0U2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBib25lTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuXHRcdHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBNYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcclxuXHJcblx0XHRcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XHJcblxyXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcclxuXHJcblx0XHRcdG1hdHJpeFdvcmxkSW52LmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGJvbmUgPSBib25lc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcclxuXHJcblx0XHRcdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdFx0XHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XHJcblx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGosIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcclxuXHJcblx0XHRcdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xyXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBqICsgMSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xyXG5cclxuXHRcdFx0XHRcdGogKz0gMjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIFBvaW50TGlnaHRIZWxwZXIoIGxpZ2h0LCBzcGhlcmVTaXplLCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBTcGhlcmVCdWZmZXJHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XHJcblxyXG5cdFx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHJcblx0XHQvKlxyXG5cdFx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xyXG5cdFx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xyXG5cclxuXHRcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcclxuXHRcdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XHJcblxyXG5cdFx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcclxuXHJcblx0XHRpZiAoIGQgPT09IDAuMCApIHtcclxuXHJcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xyXG5cdFx0Ki9cclxuXHJcblx0fVxyXG5cclxuXHRQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2gucHJvdG90eXBlICk7XHJcblx0UG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0SGVscGVyO1xyXG5cclxuXHRQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0dmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xyXG5cclxuXHRcdGlmICggZCA9PT0gMC4wICkge1xyXG5cclxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdFx0fVxyXG5cdFx0Ki9cclxuXHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gUmVjdEFyZWFMaWdodEhlbHBlciggbGlnaHQsIGNvbG9yICkge1xyXG5cclxuXHRcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblx0XHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMuY29sb3IgPSBjb2xvcjtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA1ICogMyApLCAzICkgKTtcclxuXHJcblx0XHR0aGlzLmxpbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XHJcblxyXG5cclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0UmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHRSZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY3RBcmVhTGlnaHRIZWxwZXI7XHJcblxyXG5cdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgb2YgdGhlIGhlbHBlclxyXG5cclxuXHRcdHZhciBoeCA9IHRoaXMubGlnaHQud2lkdGggKiAwLjU7XHJcblx0XHR2YXIgaHkgPSB0aGlzLmxpZ2h0LmhlaWdodCAqIDAuNTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmxpbmUuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB2ZXJ0aWNlc1xyXG5cclxuXHRcdGFycmF5WyAwIF0gPSBoeDsgYXJyYXlbIDEgXSA9IC0gaHk7IGFycmF5WyAyIF0gPSAwO1xyXG5cdFx0YXJyYXlbIDMgXSA9IGh4OyBhcnJheVsgNCBdID0gaHk7IGFycmF5WyA1IF0gPSAwO1xyXG5cdFx0YXJyYXlbIDYgXSA9IC0gaHg7IGFycmF5WyA3IF0gPSBoeTsgYXJyYXlbIDggXSA9IDA7XHJcblx0XHRhcnJheVsgOSBdID0gLSBoeDsgYXJyYXlbIDEwIF0gPSAtIGh5OyBhcnJheVsgMTEgXSA9IDA7XHJcblx0XHRhcnJheVsgMTIgXSA9IGh4OyBhcnJheVsgMTMgXSA9IC0gaHk7IGFycmF5WyAxNCBdID0gMDtcclxuXHJcblx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gSGVtaXNwaGVyZUxpZ2h0SGVscGVyKCBsaWdodCwgc2l6ZSwgY29sb3IgKSB7XHJcblxyXG5cdFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRcdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHRcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xyXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHNpemUgKTtcclxuXHRcdGdlb21ldHJ5LnJvdGF0ZVkoIE1hdGguUEkgKiAwLjUgKTtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XHJcblx0XHRpZiAoIHRoaXMuY29sb3IgPT09IHVuZGVmaW5lZCApIHRoaXMubWF0ZXJpYWwudmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xyXG5cdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uLmNvdW50ICogMyApO1xyXG5cclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkgKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xyXG5cclxuXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMuY2hpbGRyZW5bIDAgXS5tYXRlcmlhbC5kaXNwb3NlKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHZhciBjb2xvcjEgPSBuZXcgQ29sb3IoKTtcclxuXHRcdHZhciBjb2xvcjIgPSBuZXcgQ29sb3IoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdFx0dmFyIG1lc2ggPSB0aGlzLmNoaWxkcmVuWyAwIF07XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHZhciBjb2xvcnMgPSBtZXNoLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ2NvbG9yJyApO1xyXG5cclxuXHRcdFx0XHRjb2xvcjEuY29weSggdGhpcy5saWdodC5jb2xvciApO1xyXG5cdFx0XHRcdGNvbG9yMi5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gKCBpIDwgKCBsIC8gMiApICkgPyBjb2xvcjEgOiBjb2xvcjI7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtZXNoLmxvb2tBdCggdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBHcmlkSGVscGVyKCBzaXplLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xyXG5cclxuXHRcdHNpemUgPSBzaXplIHx8IDEwO1xyXG5cdFx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEwO1xyXG5cdFx0Y29sb3IxID0gbmV3IENvbG9yKCBjb2xvcjEgIT09IHVuZGVmaW5lZCA/IGNvbG9yMSA6IDB4NDQ0NDQ0ICk7XHJcblx0XHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiAhPT0gdW5kZWZpbmVkID8gY29sb3IyIDogMHg4ODg4ODggKTtcclxuXHJcblx0XHR2YXIgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcclxuXHRcdHZhciBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcclxuXHRcdHZhciBoYWxmU2l6ZSA9IHNpemUgLyAyO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdLCBjb2xvcnMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBrID0gLSBoYWxmU2l6ZTsgaSA8PSBkaXZpc2lvbnM7IGkgKyssIGsgKz0gc3RlcCApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzLnB1c2goIC0gaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrICk7XHJcblx0XHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gaGFsZlNpemUsIGssIDAsIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSBpID09PSBjZW50ZXIgPyBjb2xvcjEgOiBjb2xvcjI7XHJcblxyXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xyXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xyXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xyXG5cdFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzIH0gKTtcclxuXHJcblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblx0R3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblx0R3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkSGVscGVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcclxuXHQgKiBAYXV0aG9yIEhlY3RhdGUgLyBodHRwOi8vd3d3LmdpdGh1Yi5jb20vSGVjdGF0ZVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBQb2xhckdyaWRIZWxwZXIoIHJhZGl1cywgcmFkaWFscywgY2lyY2xlcywgZGl2aXNpb25zLCBjb2xvcjEsIGNvbG9yMiApIHtcclxuXHJcblx0XHRyYWRpdXMgPSByYWRpdXMgfHwgMTA7XHJcblx0XHRyYWRpYWxzID0gcmFkaWFscyB8fCAxNjtcclxuXHRcdGNpcmNsZXMgPSBjaXJjbGVzIHx8IDg7XHJcblx0XHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgNjQ7XHJcblx0XHRjb2xvcjEgPSBuZXcgQ29sb3IoIGNvbG9yMSAhPT0gdW5kZWZpbmVkID8gY29sb3IxIDogMHg0NDQ0NDQgKTtcclxuXHRcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICE9PSB1bmRlZmluZWQgPyBjb2xvcjIgOiAweDg4ODg4OCApO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIGNvbG9ycyA9IFtdO1xyXG5cclxuXHRcdHZhciB4LCB6O1xyXG5cdFx0dmFyIHYsIGksIGosIHIsIGNvbG9yO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSB0aGUgcmFkaWFsc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDw9IHJhZGlhbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ID0gKCBpIC8gcmFkaWFscyApICogKCBNYXRoLlBJICogMiApO1xyXG5cclxuXHRcdFx0eCA9IE1hdGguc2luKCB2ICkgKiByYWRpdXM7XHJcblx0XHRcdHogPSBNYXRoLmNvcyggdiApICogcmFkaXVzO1xyXG5cclxuXHRcdFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XHJcblxyXG5cdFx0XHRjb2xvciA9ICggaSAmIDEgKSA/IGNvbG9yMSA6IGNvbG9yMjtcclxuXHJcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XHJcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNyZWF0ZSB0aGUgY2lyY2xlc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDw9IGNpcmNsZXM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRjb2xvciA9ICggaSAmIDEgKSA/IGNvbG9yMSA6IGNvbG9yMjtcclxuXHJcblx0XHRcdHIgPSByYWRpdXMgLSAoIHJhZGl1cyAvIGNpcmNsZXMgKiBpICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMDsgaiA8IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gZmlyc3QgdmVydGV4XHJcblxyXG5cdFx0XHRcdHYgPSAoIGogLyBkaXZpc2lvbnMgKSAqICggTWF0aC5QSSAqIDIgKTtcclxuXHJcblx0XHRcdFx0eCA9IE1hdGguc2luKCB2ICkgKiByO1xyXG5cdFx0XHRcdHogPSBNYXRoLmNvcyggdiApICogcjtcclxuXHJcblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xyXG5cdFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdC8vIHNlY29uZCB2ZXJ0ZXhcclxuXHJcblx0XHRcdFx0diA9ICggKCBqICsgMSApIC8gZGl2aXNpb25zICkgKiAoIE1hdGguUEkgKiAyICk7XHJcblxyXG5cdFx0XHRcdHggPSBNYXRoLnNpbiggdiApICogcjtcclxuXHRcdFx0XHR6ID0gTWF0aC5jb3MoIHYgKSAqIHI7XHJcblxyXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcclxuXHRcdFx0XHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzIH0gKTtcclxuXHJcblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdH1cclxuXHJcblx0UG9sYXJHcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuXHRQb2xhckdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9sYXJHcmlkSGVscGVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBGYWNlTm9ybWFsc0hlbHBlciggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcclxuXHJcblx0XHQvLyBGYWNlTm9ybWFsc0hlbHBlciBvbmx5IHN1cHBvcnRzIFRIUkVFLkdlb21ldHJ5XHJcblxyXG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdFx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xyXG5cclxuXHRcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgbk5vcm1hbHMgPSAwO1xyXG5cclxuXHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdGlmICggb2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHJcblx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xyXG5cclxuXHRcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XHJcblx0RmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmFjZU5vcm1hbHNIZWxwZXI7XHJcblxyXG5cdEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xyXG5cclxuXHRcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xyXG5cclxuXHRcdFx0Ly9cclxuXHJcblx0XHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0XHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcclxuXHJcblx0XHRcdHZhciBpZHggPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XHJcblxyXG5cdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApXHJcblx0XHRcdFx0XHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxyXG5cdFx0XHRcdFx0LmFkZCggdmVydGljZXNbIGZhY2UuYyBdIClcclxuXHRcdFx0XHRcdC5kaXZpZGVTY2FsYXIoIDMgKVxyXG5cdFx0XHRcdFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xyXG5cclxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xyXG5cclxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSApO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcblx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIoIGxpZ2h0LCBzaXplLCBjb2xvciApIHtcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cdFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cclxuXHRcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XHJcblxyXG5cdFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFtcclxuXHRcdFx0LSBzaXplLCBzaXplLCAwLFxyXG5cdFx0XHRzaXplLCBzaXplLCAwLFxyXG5cdFx0XHRzaXplLCAtIHNpemUsIDAsXHJcblx0XHRcdC0gc2l6ZSwgLSBzaXplLCAwLFxyXG5cdFx0XHQtIHNpemUsIHNpemUsIDBcclxuXHRcdF0sIDMgKSApO1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcclxuXHJcblx0XHR0aGlzLmxpZ2h0UGxhbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XHJcblxyXG5cdFx0Z2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMCwgMSBdLCAzICkgKTtcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblx0XHR0aGlzLmFkZCggdGhpcy50YXJnZXRMaW5lICk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHREaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cdERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcclxuXHJcblx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0UGxhbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHREaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcclxuXHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgdjMgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHR2My5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcclxuXHJcblx0XHRcdHRoaXMubGlnaHRQbGFuZS5sb29rQXQoIHYzICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xyXG5cdFx0XHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XHJcblx0XHRcdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5sb29rQXQoIHYzICk7XHJcblx0XHRcdHRoaXMudGFyZ2V0TGluZS5zY2FsZS56ID0gdjMubGVuZ3RoKCk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpO1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG5cdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICpcclxuXHQgKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXHJcblx0ICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xyXG5cdCAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxyXG5cdCAqXHRcdGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQ2FtZXJhSGVscGVyKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IEZhY2VDb2xvcnMgfSApO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG5cdFx0dmFyIGNvbG9ycyA9IFtdO1xyXG5cclxuXHRcdHZhciBwb2ludE1hcCA9IHt9O1xyXG5cclxuXHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdHZhciBjb2xvckZydXN0dW0gPSBuZXcgQ29sb3IoIDB4ZmZhYTAwICk7XHJcblx0XHR2YXIgY29sb3JDb25lID0gbmV3IENvbG9yKCAweGZmMDAwMCApO1xyXG5cdFx0dmFyIGNvbG9yVXAgPSBuZXcgQ29sb3IoIDB4MDBhYWZmICk7XHJcblx0XHR2YXIgY29sb3JUYXJnZXQgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0XHR2YXIgY29sb3JDcm9zcyA9IG5ldyBDb2xvciggMHgzMzMzMzMgKTtcclxuXHJcblx0XHQvLyBuZWFyXHJcblxyXG5cdFx0YWRkTGluZSggJ24xJywgJ24yJywgY29sb3JGcnVzdHVtICk7XHJcblx0XHRhZGRMaW5lKCAnbjInLCAnbjQnLCBjb2xvckZydXN0dW0gKTtcclxuXHRcdGFkZExpbmUoICduNCcsICduMycsIGNvbG9yRnJ1c3R1bSApO1xyXG5cdFx0YWRkTGluZSggJ24zJywgJ24xJywgY29sb3JGcnVzdHVtICk7XHJcblxyXG5cdFx0Ly8gZmFyXHJcblxyXG5cdFx0YWRkTGluZSggJ2YxJywgJ2YyJywgY29sb3JGcnVzdHVtICk7XHJcblx0XHRhZGRMaW5lKCAnZjInLCAnZjQnLCBjb2xvckZydXN0dW0gKTtcclxuXHRcdGFkZExpbmUoICdmNCcsICdmMycsIGNvbG9yRnJ1c3R1bSApO1xyXG5cdFx0YWRkTGluZSggJ2YzJywgJ2YxJywgY29sb3JGcnVzdHVtICk7XHJcblxyXG5cdFx0Ly8gc2lkZXNcclxuXHJcblx0XHRhZGRMaW5lKCAnbjEnLCAnZjEnLCBjb2xvckZydXN0dW0gKTtcclxuXHRcdGFkZExpbmUoICduMicsICdmMicsIGNvbG9yRnJ1c3R1bSApO1xyXG5cdFx0YWRkTGluZSggJ24zJywgJ2YzJywgY29sb3JGcnVzdHVtICk7XHJcblx0XHRhZGRMaW5lKCAnbjQnLCAnZjQnLCBjb2xvckZydXN0dW0gKTtcclxuXHJcblx0XHQvLyBjb25lXHJcblxyXG5cdFx0YWRkTGluZSggJ3AnLCAnbjEnLCBjb2xvckNvbmUgKTtcclxuXHRcdGFkZExpbmUoICdwJywgJ24yJywgY29sb3JDb25lICk7XHJcblx0XHRhZGRMaW5lKCAncCcsICduMycsIGNvbG9yQ29uZSApO1xyXG5cdFx0YWRkTGluZSggJ3AnLCAnbjQnLCBjb2xvckNvbmUgKTtcclxuXHJcblx0XHQvLyB1cFxyXG5cclxuXHRcdGFkZExpbmUoICd1MScsICd1MicsIGNvbG9yVXAgKTtcclxuXHRcdGFkZExpbmUoICd1MicsICd1MycsIGNvbG9yVXAgKTtcclxuXHRcdGFkZExpbmUoICd1MycsICd1MScsIGNvbG9yVXAgKTtcclxuXHJcblx0XHQvLyB0YXJnZXRcclxuXHJcblx0XHRhZGRMaW5lKCAnYycsICd0JywgY29sb3JUYXJnZXQgKTtcclxuXHRcdGFkZExpbmUoICdwJywgJ2MnLCBjb2xvckNyb3NzICk7XHJcblxyXG5cdFx0Ly8gY3Jvc3NcclxuXHJcblx0XHRhZGRMaW5lKCAnY24xJywgJ2NuMicsIGNvbG9yQ3Jvc3MgKTtcclxuXHRcdGFkZExpbmUoICdjbjMnLCAnY240JywgY29sb3JDcm9zcyApO1xyXG5cclxuXHRcdGFkZExpbmUoICdjZjEnLCAnY2YyJywgY29sb3JDcm9zcyApO1xyXG5cdFx0YWRkTGluZSggJ2NmMycsICdjZjQnLCBjb2xvckNyb3NzICk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgY29sb3IgKSB7XHJcblxyXG5cdFx0XHRhZGRQb2ludCggYSwgY29sb3IgKTtcclxuXHRcdFx0YWRkUG9pbnQoIGIsIGNvbG9yICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgY29sb3IgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XHJcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50TWFwWyBpZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb2ludE1hcFsgaWQgXS5wdXNoKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSAtIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcblx0XHRpZiAoIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggKSB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XHJcblx0XHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRDYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5cdENhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW1lcmFIZWxwZXI7XHJcblxyXG5cdENhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XHJcblxyXG5cdFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XHJcblx0XHR2YXIgY2FtZXJhID0gbmV3IENhbWVyYSgpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgeCwgeSwgeiApIHtcclxuXHJcblx0XHRcdHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0dmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggcG9pbnRzWyBpIF0sIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG5cdFx0XHRwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XHJcblxyXG5cdFx0XHR2YXIgdyA9IDEsIGggPSAxO1xyXG5cclxuXHRcdFx0Ly8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxyXG5cdFx0XHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxyXG5cclxuXHRcdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ly8gY2VudGVyIC8gdGFyZ2V0XHJcblxyXG5cdFx0XHRzZXRQb2ludCggJ2MnLCAwLCAwLCAtIDEgKTtcclxuXHRcdFx0c2V0UG9pbnQoICd0JywgMCwgMCwgMSApO1xyXG5cclxuXHRcdFx0Ly8gbmVhclxyXG5cclxuXHRcdFx0c2V0UG9pbnQoICduMScsIC0gdywgLSBoLCAtIDEgKTtcclxuXHRcdFx0c2V0UG9pbnQoICduMicsIHcsIC0gaCwgLSAxICk7XHJcblx0XHRcdHNldFBvaW50KCAnbjMnLCAtIHcsIGgsIC0gMSApO1xyXG5cdFx0XHRzZXRQb2ludCggJ240JywgdywgaCwgLSAxICk7XHJcblxyXG5cdFx0XHQvLyBmYXJcclxuXHJcblx0XHRcdHNldFBvaW50KCAnZjEnLCAtIHcsIC0gaCwgMSApO1xyXG5cdFx0XHRzZXRQb2ludCggJ2YyJywgdywgLSBoLCAxICk7XHJcblx0XHRcdHNldFBvaW50KCAnZjMnLCAtIHcsIGgsIDEgKTtcclxuXHRcdFx0c2V0UG9pbnQoICdmNCcsIHcsIGgsIDEgKTtcclxuXHJcblx0XHRcdC8vIHVwXHJcblxyXG5cdFx0XHRzZXRQb2ludCggJ3UxJywgdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XHJcblx0XHRcdHNldFBvaW50KCAndTInLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xyXG5cdFx0XHRzZXRQb2ludCggJ3UzJywgMCwgaCAqIDIsIC0gMSApO1xyXG5cclxuXHRcdFx0Ly8gY3Jvc3NcclxuXHJcblx0XHRcdHNldFBvaW50KCAnY2YxJywgLSB3LCAwLCAxICk7XHJcblx0XHRcdHNldFBvaW50KCAnY2YyJywgdywgMCwgMSApO1xyXG5cdFx0XHRzZXRQb2ludCggJ2NmMycsIDAsIC0gaCwgMSApO1xyXG5cdFx0XHRzZXRQb2ludCggJ2NmNCcsIDAsIGgsIDEgKTtcclxuXHJcblx0XHRcdHNldFBvaW50KCAnY24xJywgLSB3LCAwLCAtIDEgKTtcclxuXHRcdFx0c2V0UG9pbnQoICdjbjInLCB3LCAwLCAtIDEgKTtcclxuXHRcdFx0c2V0UG9pbnQoICdjbjMnLCAwLCAtIGgsIC0gMSApO1xyXG5cdFx0XHRzZXRQb2ludCggJ2NuNCcsIDAsIGgsIC0gMSApO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKTtcclxuXHJcblx0LyoqXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwOi8vZ2l0aHViLmNvbS9NdWdlbjg3XHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEJveEhlbHBlciggb2JqZWN0LCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xyXG5cclxuXHRcdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICk7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XHJcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblxyXG5cdFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cclxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Qm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuXHRCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94SGVscGVyO1xyXG5cclxuXHRCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBib3ggPSBuZXcgQm94MygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGhpcy5vYmplY3QgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Ym94LnNldEZyb21PYmplY3QoIHRoaXMub2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XHJcblxyXG5cdFx0XHR2YXIgbWluID0gYm94Lm1pbjtcclxuXHRcdFx0dmFyIG1heCA9IGJveC5tYXg7XHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHQgIDVfX19fNFxyXG5cdFx0XHQxL19fXzAvfFxyXG5cdFx0XHR8IDZfX3xfN1xyXG5cdFx0XHQyL19fXzMvXHJcblxyXG5cdFx0XHQwOiBtYXgueCwgbWF4LnksIG1heC56XHJcblx0XHRcdDE6IG1pbi54LCBtYXgueSwgbWF4LnpcclxuXHRcdFx0MjogbWluLngsIG1pbi55LCBtYXguelxyXG5cdFx0XHQzOiBtYXgueCwgbWluLnksIG1heC56XHJcblx0XHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcclxuXHRcdFx0NTogbWluLngsIG1heC55LCBtaW4uelxyXG5cdFx0XHQ2OiBtaW4ueCwgbWluLnksIG1pbi56XHJcblx0XHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcclxuXHRcdFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XHJcblxyXG5cdFx0XHRhcnJheVsgMCBdID0gbWF4Lng7IGFycmF5WyAxIF0gPSBtYXgueTsgYXJyYXlbIDIgXSA9IG1heC56O1xyXG5cdFx0XHRhcnJheVsgMyBdID0gbWluLng7IGFycmF5WyA0IF0gPSBtYXgueTsgYXJyYXlbIDUgXSA9IG1heC56O1xyXG5cdFx0XHRhcnJheVsgNiBdID0gbWluLng7IGFycmF5WyA3IF0gPSBtaW4ueTsgYXJyYXlbIDggXSA9IG1heC56O1xyXG5cdFx0XHRhcnJheVsgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XHJcblx0XHRcdGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XHJcblx0XHRcdGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XHJcblx0XHRcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XHJcblx0XHRcdGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XHJcblxyXG5cdFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0gKSgpO1xyXG5cclxuXHRCb3hIZWxwZXIucHJvdG90eXBlLnNldEZyb21PYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHR0aGlzLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBCb3gzSGVscGVyKCBib3gsIGhleCApIHtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnQm94M0hlbHBlcic7XHJcblxyXG5cdFx0dGhpcy5ib3ggPSBib3g7XHJcblxyXG5cdFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XHJcblxyXG5cdFx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IFsgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSBdO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xyXG5cclxuXHRcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcclxuXHJcblx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdEJveDNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xyXG5cdEJveDNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94M0hlbHBlcjtcclxuXHJcblx0Qm94M0hlbHBlci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiAoIGZvcmNlICkge1xyXG5cclxuXHRcdHZhciBib3ggPSB0aGlzLmJveDtcclxuXHJcblx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XHJcblxyXG5cdFx0Ym94LmdldENlbnRlciggdGhpcy5wb3NpdGlvbiApO1xyXG5cclxuXHRcdGJveC5nZXRTaXplKCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdFx0dGhpcy5zY2FsZS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBQbGFuZUhlbHBlciggcGxhbmUsIHNpemUsIGhleCApIHtcclxuXHJcblx0XHR0aGlzLnR5cGUgPSAnUGxhbmVIZWxwZXInO1xyXG5cclxuXHRcdHRoaXMucGxhbmUgPSBwbGFuZTtcclxuXHJcblx0XHR0aGlzLnNpemUgPSAoIHNpemUgPT09IHVuZGVmaW5lZCApID8gMSA6IHNpemU7XHJcblxyXG5cdFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IFsgMSwgLSAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDAsIDAsIDAgXTtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuXHRcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcclxuXHJcblx0XHRMaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uczIgPSBbIDEsIDEsIDEsIC0gMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEgXTtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XHJcblx0XHRnZW9tZXRyeTIuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zMiwgMyApICk7XHJcblx0XHRnZW9tZXRyeTIuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeTIsIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuMiwgdHJhbnNwYXJlbnQ6IHRydWUsIGRlcHRoV3JpdGU6IGZhbHNlIH0gKSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0UGxhbmVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZS5wcm90b3R5cGUgKTtcclxuXHRQbGFuZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZUhlbHBlcjtcclxuXHJcblx0UGxhbmVIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0XHR2YXIgc2NhbGUgPSAtIHRoaXMucGxhbmUuY29uc3RhbnQ7XHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggc2NhbGUgKSA8IDFlLTggKSBzY2FsZSA9IDFlLTg7IC8vIHNpZ24gZG9lcyBub3QgbWF0dGVyXHJcblxyXG5cdFx0dGhpcy5zY2FsZS5zZXQoIDAuNSAqIHRoaXMuc2l6ZSwgMC41ICogdGhpcy5zaXplLCBzY2FsZSApO1xyXG5cclxuXHRcdHRoaXMubG9va0F0KCB0aGlzLnBsYW5lLm5vcm1hbCApO1xyXG5cclxuXHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vZ2l0aHViLmNvbS96ejg1XHJcblx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xyXG5cdCAqXHJcblx0ICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xyXG5cdCAqXHJcblx0ICogUGFyYW1ldGVyczpcclxuXHQgKiAgZGlyIC0gVmVjdG9yM1xyXG5cdCAqICBvcmlnaW4gLSBWZWN0b3IzXHJcblx0ICogIGxlbmd0aCAtIE51bWJlclxyXG5cdCAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxyXG5cdCAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXHJcblx0ICogIGhlYWRXaWR0aCAtIE51bWJlclxyXG5cdCAqL1xyXG5cclxuXHR2YXIgbGluZUdlb21ldHJ5O1xyXG5cdHZhciBjb25lR2VvbWV0cnk7XHJcblxyXG5cdGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xyXG5cclxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcclxuXHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xyXG5cdFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xyXG5cdFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XHJcblxyXG5cdFx0aWYgKCBsaW5lR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGxpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0XHRsaW5lR2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAxLCAwIF0sIDMgKSApO1xyXG5cclxuXHRcdFx0Y29uZUdlb21ldHJ5ID0gbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIDAsIDAuNSwgMSwgNSwgMSApO1xyXG5cdFx0XHRjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xyXG5cclxuXHRcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblx0XHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xyXG5cclxuXHRcdHRoaXMuY29uZSA9IG5ldyBNZXNoKCBjb25lR2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XHJcblx0XHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuXHRcdHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcclxuXHRcdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdEFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cdEFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycm93SGVscGVyO1xyXG5cclxuXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGF4aXMgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0dmFyIHJhZGlhbnM7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xyXG5cclxuXHRcdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdFx0aWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXQoIDAsIDAsIDAsIDEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGRpci55IDwgLSAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRheGlzLnNldCggZGlyLnosIDAsIC0gZGlyLnggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0cmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcclxuXHJcblx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCkgKTtcclxuXHJcblx0QXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uICggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XHJcblxyXG5cdFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xyXG5cdFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XHJcblxyXG5cdFx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAsIGxlbmd0aCAtIGhlYWRMZW5ndGggKSwgMSApO1xyXG5cdFx0dGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XHJcblx0XHR0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcclxuXHRcdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0fTtcclxuXHJcblx0QXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3IuY29weSggY29sb3IgKTtcclxuXHRcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXHJcblx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuXHQgKi9cclxuXHJcblx0ZnVuY3Rpb24gQXhlc0hlbHBlciggc2l6ZSApIHtcclxuXHJcblx0XHRzaXplID0gc2l6ZSB8fCAxO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdFx0MCwgMCwgMCxcdHNpemUsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDAsXHQwLCBzaXplLCAwLFxyXG5cdFx0XHQwLCAwLCAwLFx0MCwgMCwgc2l6ZVxyXG5cdFx0XTtcclxuXHJcblx0XHR2YXIgY29sb3JzID0gW1xyXG5cdFx0XHQxLCAwLCAwLFx0MSwgMC42LCAwLFxyXG5cdFx0XHQwLCAxLCAwLFx0MC42LCAxLCAwLFxyXG5cdFx0XHQwLCAwLCAxLFx0MCwgMC42LCAxXHJcblx0XHRdO1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xyXG5cdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuXHRcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRBeGVzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcclxuXHRBeGVzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF4ZXNIZWxwZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcblx0ICovXHJcblxyXG5cdHZhciBTY2VuZVV0aWxzID0ge1xyXG5cclxuXHRcdGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcclxuXHJcblx0XHRcdHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGdyb3VwLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZ3JvdXA7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRkZXRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHBhcmVudCwgc2NlbmUgKSB7XHJcblxyXG5cdFx0XHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XHJcblx0XHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGF0dGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgc2NlbmUsIHBhcmVudCApIHtcclxuXHJcblx0XHRcdGNoaWxkLmFwcGx5TWF0cml4KCBuZXcgTWF0cml4NCgpLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApICk7XHJcblxyXG5cdFx0XHRzY2VuZS5yZW1vdmUoIGNoaWxkICk7XHJcblx0XHRcdHBhcmVudC5hZGQoIGNoaWxkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG5cdCAqL1xyXG5cclxuXHRmdW5jdGlvbiBGYWNlNCggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgTGluZVN0cmlwID0gMDtcclxuXHJcblx0dmFyIExpbmVQaWVjZXMgPSAxO1xyXG5cclxuXHRmdW5jdGlvbiBNZXNoRmFjZU1hdGVyaWFsKCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIE11bHRpTWF0ZXJpYWwoIG1hdGVyaWFscyApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFscyA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxzID0gW107XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTXVsdGlNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nICk7XHJcblx0XHRtYXRlcmlhbHMuaXNNdWx0aU1hdGVyaWFsID0gdHJ1ZTtcclxuXHRcdG1hdGVyaWFscy5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XHJcblx0XHRtYXRlcmlhbHMuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzLnNsaWNlKCk7XHJcblxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBtYXRlcmlhbHM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUG9pbnRDbG91ZCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFBhcnRpY2xlKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlNwcml0ZS4nICk7XHJcblx0XHRyZXR1cm4gbmV3IFNwcml0ZSggbWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbSggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcclxuXHRcdHJldHVybiBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBQb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFBhcnRpY2xlQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XHJcblx0XHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUGFydGljbGVTeXN0ZW1NYXRlcmlhbCggcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFZlcnRleCggeCwgeSwgeiApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZXJ0ZXggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLlZlY3RvcjMgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gbmV3IFZlY3RvcjMoIHgsIHksIHogKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBEeW5hbWljQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSgpLnNldER5bmFtaWMoIHRydWUgKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gSW50OEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQ4QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gbmV3IEludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFVpbnQ4QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50OEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBVaW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gVWludDhDbGFtcGVkQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gSW50MTZBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gbmV3IEludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBVaW50MTZBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgVWludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBJbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgSW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFVpbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEZsb2F0MzJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5GbG9hdDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBGbG9hdDY0QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmxvYXQ2NEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0Q3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3QsIGdldFBvaW50ICkge1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuQ3VydmUuY3JlYXRlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCcgKTtcclxuXHJcblx0XHRjb25zdHJ1Y3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XHJcblx0XHRjb25zdHJ1Y3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0O1xyXG5cdFx0Y29uc3RydWN0LnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50O1xyXG5cclxuXHRcdHJldHVybiBjb25zdHJ1Y3Q7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIEN1cnZlUGF0aC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjcmVhdGVQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVQb2ludHNHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdC8vIGdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBvaW50cyBvYmplY3RzKVxyXG5cclxuXHRcdFx0dmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmVQYXRoOiAuY3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHQvLyBnZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW50IHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXHJcblxyXG5cdFx0XHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRjcmVhdGVHZW9tZXRyeTogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBQYXRoLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGF0aDogLmZyb21Qb2ludHMoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tUG9pbnRzKCkuJyApO1xyXG5cdFx0XHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBDbG9zZWRTcGxpbmVDdXJ2ZTMoIHBvaW50cyApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0Q2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcclxuXHRcdHRoaXMudHlwZSA9ICdjYXRtdWxscm9tJztcclxuXHRcdHRoaXMuY2xvc2VkID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRDbG9zZWRTcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gU3BsaW5lQ3VydmUzKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XHJcblx0XHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XHJcblxyXG5cdH1cclxuXHJcblx0U3BsaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIFNwbGluZSggcG9pbnRzICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHRDYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xyXG5cdFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xyXG5cclxuXHR9XHJcblxyXG5cdFNwbGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBTcGxpbmUucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0aW5pdEZyb21BcnJheTogZnVuY3Rpb24gKCAvKiBhICovICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLmluaXRGcm9tQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0Z2V0Q29udHJvbFBvaW50c0FycmF5OiBmdW5jdGlvbiAoIC8qIG9wdGlvbmFsVGFyZ2V0ICovICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLmdldENvbnRyb2xQb2ludHNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRyZXBhcmFtZXRyaXplQnlBcmNMZW5ndGg6IGZ1bmN0aW9uICggLyogc2FtcGxpbmdDb2VmICovICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBBeGlzSGVscGVyKCBzaXplICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF4aXNIZWxwZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5BeGVzSGVscGVyLicgKTtcclxuXHRcdHJldHVybiBuZXcgQXhlc0hlbHBlciggc2l6ZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEJvdW5kaW5nQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJvdW5kaW5nQm94SGVscGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIENyZWF0aW5nIGEgVEhSRUUuQm94SGVscGVyIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIG5ldyBCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBFZGdlc0hlbHBlciggb2JqZWN0LCBoZXggKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRWRnZXNIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkVkZ2VzR2VvbWV0cnkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggbmV3IEVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0R3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HcmlkSGVscGVyOiBzZXRDb2xvcnMoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwYXNzIHRoZW0gaW4gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQuJyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Ta2VsZXRvbkhlbHBlcjogdXBkYXRlKCkgbm8gbG9uZ2VyIG5lZWRzIHRvIGJlIGNhbGxlZC4nICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIFdpcmVmcmFtZUhlbHBlciggb2JqZWN0LCBoZXggKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2lyZWZyYW1lSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBuZXcgV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggTG9hZGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlcjogLmV4dHJhY3RVcmxCYXNlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkxvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdGZ1bmN0aW9uIFhIUkxvYWRlciggbWFuYWdlciApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5YSFJMb2FkZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5GaWxlTG9hZGVyLicgKTtcclxuXHRcdHJldHVybiBuZXcgRmlsZUxvYWRlciggbWFuYWdlciApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEJpbmFyeVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyLicgKTtcclxuXHRcdHJldHVybiBuZXcgRGF0YVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBCb3gyLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuc2l6ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFNpemUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldFNpemUoIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggQm94My5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuZW1wdHkoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pc0VtcHR5KCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0XHR9XHJcblx0fSApO1xyXG5cclxuXHRMaW5lMy5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaW5lMzogLmNlbnRlcigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldENlbnRlcigpLicgKTtcclxuXHRcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggX01hdGgsIHtcclxuXHJcblx0XHRyYW5kb20xNjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aDogLnJhbmRvbTE2KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIE1hdGgucmFuZG9tKCkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0bmVhcmVzdFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoOiAubmVhcmVzdFBvd2VyT2ZUd28oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mbG9vclBvd2VyT2ZUd28oKS4nICk7XHJcblx0XHRcdHJldHVybiBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIHZhbHVlICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5uZXh0UG93ZXJPZlR3bygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNlaWxQb3dlck9mVHdvKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gX01hdGguY2VpbFBvd2VyT2ZUd28oIHZhbHVlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIE1hdHJpeDMucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRyaXgzOiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlwiICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGEgKi8gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICggYnVmZmVyIC8qLCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5hcHBseVRvQnVmZmVyKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYnVmZmVyICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYXJyYXksIG9mZnNldCwgbGVuZ3RoICovICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZXh0cmFjdFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY29weVBvc2l0aW9uKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRyaXg0OiAuZmxhdHRlblRvQXJyYXlPZmZzZXQoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLnRvQXJyYXkoKSBpbnN0ZWFkLlwiICk7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHZhciB2MTtcclxuXHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcclxuXHJcblx0XHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDMgKTtcclxuXHJcblx0XHRcdH07XHJcblxyXG5cdFx0fSgpLFxyXG5cdFx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlUb0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRtdWx0aXBseVZlY3RvcjQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYSAqLyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHR2LnRyYW5zZm9ybURpcmVjdGlvbiggdGhpcyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0cm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoIGJ1ZmZlciAvKiwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb0J1ZmZlcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlciApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGFycmF5LCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb1ZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRtYWtlRnJ1c3R1bTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlRnJ1c3R1bSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdFBsYW5lLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbkxpbmUgPSBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGxhbmU6IC5pc0ludGVyc2VjdGlvbkxpbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzTGluZSgpLicgKTtcclxuXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XHJcblxyXG5cdH07XHJcblxyXG5cdFF1YXRlcm5pb24ucHJvdG90eXBlLm11bHRpcGx5VmVjdG9yMyA9IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XHJcblxyXG5cdH07XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIFJheS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRpc0ludGVyc2VjdGlvblBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuYXNzaWduKCBTaGFwZS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRleHRyYWN0QWxsUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAuZXh0cmFjdEFsbFBvaW50cygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuZXh0cmFjdFBvaW50cygpIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHRyYWN0UG9pbnRzKCBkaXZpc2lvbnMgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0ZXh0cnVkZTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGU6IC5leHRydWRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV4dHJ1ZGVHZW9tZXRyeSgpIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRtYWtlR2VvbWV0cnk6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAubWFrZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFNoYXBlR2VvbWV0cnkoKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIFZlY3RvcjIucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRkaXN0YW5jZVRvTWFuaGF0dGFuOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGdldFBvc2l0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbWF0cml4LCBpbmRleCApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseVByb2plY3Rpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmFwcGx5TWF0cml4NCggbSApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG0gKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRkaXN0YW5jZVRvTWFuaGF0dGFuOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggVmVjdG9yNC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLmxlbmd0aE1hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkxlbmd0aCgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdEdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlVGFuZ2VudHMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0fTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggT2JqZWN0M0QucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0Z2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZSggbmFtZSApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRyZW5kZXJEZXB0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5yZW5kZXJEZXB0aCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnJlbmRlck9yZGVyLCBpbnN0ZWFkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIGRpc3RhbmNlLCBheGlzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggT2JqZWN0M0QucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0ZXVsZXJPcmRlcjoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XHJcblx0XHRcdFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHVzZVF1YXRlcm5pb246IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExPRC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRvYmplY3RzOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubGV2ZWxzO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggU2tlbGV0b24ucHJvdG90eXBlLCAndXNlVmVydGV4VGV4dHVyZScsIHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiB1c2VWZXJ0ZXhUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiB1c2VWZXJ0ZXhUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEN1cnZlLnByb3RvdHlwZSwgJ19fYXJjTGVuZ3RoRGl2aXNpb25zJywge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5fX2FyY0xlbmd0aERpdmlzaW9ucyBpcyBub3cgLmFyY0xlbmd0aERpdmlzaW9ucy4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcclxuXHJcblx0XHR9LFxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5fX2FyY0xlbmd0aERpdmlzaW9ucyBpcyBub3cgLmFyY0xlbmd0aERpdmlzaW9ucy4nICk7XHJcblx0XHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zID0gZnVuY3Rpb24gKCBmb2NhbExlbmd0aCwgZmlsbUdhdWdlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5zZXRMZW5zIGlzIGRlcHJlY2F0ZWQuIFwiICtcclxuXHRcdFx0XHRcIlVzZSAuc2V0Rm9jYWxMZW5ndGggYW5kIC5maWxtR2F1Z2UgZm9yIGEgcGhvdG9ncmFwaGljIHNldHVwLlwiICk7XHJcblxyXG5cdFx0aWYgKCBmaWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIHRoaXMuZmlsbUdhdWdlID0gZmlsbUdhdWdlO1xyXG5cdFx0dGhpcy5zZXRGb2NhbExlbmd0aCggZm9jYWxMZW5ndGggKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpZ2h0LnByb3RvdHlwZSwge1xyXG5cdFx0b25seVNoYWRvdzoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHNoYWRvd0NhbWVyYUZvdjoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuJyApO1xyXG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzaGFkb3dDYW1lcmFMZWZ0OiB7XHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFMZWZ0IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5sZWZ0LicgKTtcclxuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHNoYWRvd0NhbWVyYVJpZ2h0OiB7XHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFSaWdodCBpcyBub3cgLnNoYWRvdy5jYW1lcmEucmlnaHQuJyApO1xyXG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHNoYWRvd0NhbWVyYVRvcDoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuJyApO1xyXG5cdFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzaGFkb3dDYW1lcmFCb3R0b206IHtcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUJvdHRvbSBpcyBub3cgLnNoYWRvdy5jYW1lcmEuYm90dG9tLicgKTtcclxuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93Q2FtZXJhTmVhcjoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTmVhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEubmVhci4nICk7XHJcblx0XHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzaGFkb3dDYW1lcmFGYXI6IHtcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLicgKTtcclxuXHRcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93Qmlhczoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93QmlhcyBpcyBub3cgLnNoYWRvdy5iaWFzLicgKTtcclxuXHRcdFx0XHR0aGlzLnNoYWRvdy5iaWFzID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93RGFya25lc3M6IHtcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93RGFya25lc3MgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93TWFwV2lkdGg6IHtcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcFdpZHRoIGlzIG5vdyAuc2hhZG93Lm1hcFNpemUud2lkdGguJyApO1xyXG5cdFx0XHRcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzaGFkb3dNYXBIZWlnaHQ6IHtcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcEhlaWdodCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLmhlaWdodC4nICk7XHJcblx0XHRcdFx0dGhpcy5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9ICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0bGVuZ3RoOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5jb3VudCBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0YWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XHJcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGFkZERyYXdDYWxsOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcclxuXHRcdFx0dGhpcy5hZGRHcm91cCggc3RhcnQsIGNvdW50ICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGNsZWFyRHJhd0NhbGxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcclxuXHRcdFx0dGhpcy5jbGVhckdyb3VwcygpO1xyXG5cclxuXHRcdH0sXHJcblx0XHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVPZmZzZXRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRkcmF3Y2FsbHM6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmdyb3VwcztcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRvZmZzZXRzOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5ncm91cHM7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0Ly9cclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFVuaWZvcm0ucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0ZHluYW1pYzoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogLmR5bmFtaWMgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG9iamVjdC5vbkJlZm9yZVJlbmRlcigpIGluc3RlYWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9uVXBkYXRlOiB7XHJcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVuaWZvcm06IC5vblVwZGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBvYmplY3Qub25CZWZvcmVSZW5kZXIoKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWF0ZXJpYWwucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0d3JhcEFyb3VuZDoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWw6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiAud3JhcEFyb3VuZCBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHR3cmFwUkdCOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbDogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcigpO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHRzaGFkaW5nOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xyXG5cdFx0XHRcdHRoaXMuZmxhdFNoYWRpbmcgPSAoIHZhbHVlID09PSBGbGF0U2hhZGluZyApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRtZXRhbDoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsOiAubWV0YWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsIGluc3RlYWQnICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGRlcml2YXRpdmVzOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4gU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nICk7XHJcblx0XHRcdFx0dGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0Ly9cclxuXHJcblx0T2JqZWN0LmFzc2lnbiggV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRnZXRDdXJyZW50UmVuZGVyVGFyZ2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0Q3VycmVudFJlbmRlclRhcmdldCgpIGlzIG5vdyAuZ2V0UmVuZGVyVGFyZ2V0KCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSZW5kZXJUYXJnZXQoKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldE1heEFuaXNvdHJvcHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRNYXhBbmlzb3Ryb3B5KCkgaXMgbm93IC5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGdldFByZWNpc2lvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldFByZWNpc2lvbigpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnByZWNpc2lvbi4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy5wcmVjaXNpb247XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRyZXNldEdMU3RhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5yZXNldEdMU3RhdGUoKSBpcyBub3cgLnN0YXRlLnJlc2V0KCkuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5yZXNldCgpO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c3VwcG9ydHNGbG9hdFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfZmxvYXRcXCcgKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRzdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXCcgKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRzdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcXCcgKS4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHN1cHBvcnRzQmxlbmRNaW5NYXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnRVhUX2JsZW5kX21pbm1heFxcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcygpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xyXG5cclxuXHRcdH0sXHJcblx0XHRzdXBwb3J0c0luc3RhbmNlZEFycmF5czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnQU5HTEVfaW5zdGFuY2VkX2FycmF5c1xcJyApLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRlbmFibGVTY2lzc29yVGVzdDogZnVuY3Rpb24gKCBib29sZWFuICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcclxuXHRcdFx0dGhpcy5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xyXG5cclxuXHRcdH0sXHJcblx0XHRpbml0TWF0ZXJpYWw6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHR9LFxyXG5cdFx0YWRkUHJlUGx1Z2luOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdGFkZFBvc3RQbHVnaW46IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHRcdHVwZGF0ZVNoYWRvd01hcDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzaGFkb3dNYXBFbmFibGVkOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuZW5hYmxlZDtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XHJcblx0XHRcdFx0dGhpcy5zaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHNoYWRvd01hcFR5cGU6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC50eXBlO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcclxuXHRcdFx0XHR0aGlzLnNoYWRvd01hcC50eXBlID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC5jdWxsRmFjZTtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGlzIG5vdyAuc2hhZG93TWFwLmN1bGxGYWNlLicgKTtcclxuXHRcdFx0XHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMU2hhZG93TWFwLnByb3RvdHlwZSwge1xyXG5cclxuXHRcdGN1bGxGYWNlOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPyBDdWxsRmFjZUZyb250IDogQ3VsbEZhY2VCYWNrO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIGN1bGxGYWNlICkge1xyXG5cclxuXHRcdFx0XHR2YXIgdmFsdWUgPSAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZUJhY2sgKTtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5jdWxsRmFjZSBpcyBkZXByZWNhdGVkLiBTZXQgLnNoYWRvd01hcC5yZW5kZXJSZXZlcnNlU2lkZWQgdG8gXCIgKyB2YWx1ZSArIFwiLlwiICk7XHJcblx0XHRcdFx0dGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fSApO1xyXG5cclxuXHQvL1xyXG5cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XHJcblxyXG5cdFx0d3JhcFM6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XHJcblx0XHRcdFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0d3JhcFQ6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XHJcblx0XHRcdFx0dGhpcy50ZXh0dXJlLndyYXBUID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0bWFnRmlsdGVyOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XHJcblx0XHRcdFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG1pbkZpbHRlcjoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xyXG5cdFx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRhbmlzb3Ryb3B5OiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcclxuXHRcdFx0XHR0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdG9mZnNldDoge1xyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXQ7XHJcblxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xyXG5cdFx0XHRcdHRoaXMudGV4dHVyZS5vZmZzZXQgPSB2YWx1ZTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRyZXBlYXQ6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcclxuXHRcdFx0XHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Zm9ybWF0OiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XHJcblx0XHRcdFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdHR5cGU6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS50eXBlO1xyXG5cclxuXHRcdFx0fSxcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xyXG5cdFx0XHRcdHRoaXMudGV4dHVyZS50eXBlID0gdmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Z2VuZXJhdGVNaXBtYXBzOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcclxuXHJcblx0XHRcdH0sXHJcblx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XHJcblx0XHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdE9iamVjdC5hc3NpZ24oIFdlYlZSTWFuYWdlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRnZXRTdGFuZGluZ01hdHJpeDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViVlJNYW5hZ2VyOiAuZ2V0U3RhbmRpbmdNYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gKTtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYlZSTWFuYWdlci5wcm90b3R5cGUsIHtcclxuXHJcblx0XHRzdGFuZGluZzoge1xyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uICggLyogdmFsdWUgKi8gKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYlZSTWFuYWdlcjogLnN0YW5kaW5nIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9ICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdEF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiAubG9hZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQXVkaW9Mb2FkZXIgaW5zdGVhZC4nICk7XHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdFx0dmFyIGF1ZGlvTG9hZGVyID0gbmV3IEF1ZGlvTG9hZGVyKCk7XHJcblx0XHRhdWRpb0xvYWRlci5sb2FkKCBmaWxlLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcclxuXHJcblx0XHRcdHNjb3BlLnNldEJ1ZmZlciggYnVmZmVyICk7XHJcblxyXG5cdFx0fSApO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH07XHJcblxyXG5cdEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW9BbmFseXNlcjogLmdldERhdGEoKSBpcyBub3cgLmdldEZyZXF1ZW5jeURhdGEoKS4nICk7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRGcmVxdWVuY3lEYXRhKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdEN1YmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5DdWJlQ2FtZXJhOiAudXBkYXRlQ3ViZU1hcCgpIGlzIG5vdyAudXBkYXRlKCkuJyApO1xyXG5cdFx0cmV0dXJuIHRoaXMudXBkYXRlKCByZW5kZXJlciwgc2NlbmUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0dmFyIEdlb21ldHJ5VXRpbHMgPSB7XHJcblxyXG5cdFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnkxLCBnZW9tZXRyeTIsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xyXG5cdFx0XHR2YXIgbWF0cml4O1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeTIuaXNNZXNoICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRcdG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XHJcblx0XHRcdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkyLmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkxLm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLmNlbnRlcigpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkuY2VudGVyKCkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBJbWFnZVV0aWxzID0ge1xyXG5cclxuXHRcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5UZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcclxuXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hcHBpbmcgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggdXJscywgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IEN1YmVUZXh0dXJlTG9hZGVyKCk7XHJcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xyXG5cclxuXHRcdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcclxuXHJcblx0XHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBQcm9qZWN0b3IoKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XHJcblx0XHRcdHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xyXG5cdFx0XHR2ZWN0b3IudW5wcm9qZWN0KCBjYW1lcmEgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0ZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XHJcblxyXG5cdFx0dGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XHJcblx0XHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge307XHJcblx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XHJcblx0XHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcblx0fVxyXG5cclxuXHRleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcclxuXHRleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0ID0gV2ViR0xSZW5kZXJUYXJnZXQ7XHJcblx0ZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gV2ViR0xSZW5kZXJlcjtcclxuXHRleHBvcnRzLlNoYWRlckxpYiA9IFNoYWRlckxpYjtcclxuXHRleHBvcnRzLlVuaWZvcm1zTGliID0gVW5pZm9ybXNMaWI7XHJcblx0ZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzID0gVW5pZm9ybXNVdGlscztcclxuXHRleHBvcnRzLlNoYWRlckNodW5rID0gU2hhZGVyQ2h1bms7XHJcblx0ZXhwb3J0cy5Gb2dFeHAyID0gRm9nRXhwMjtcclxuXHRleHBvcnRzLkZvZyA9IEZvZztcclxuXHRleHBvcnRzLlNjZW5lID0gU2NlbmU7XHJcblx0ZXhwb3J0cy5MZW5zRmxhcmUgPSBMZW5zRmxhcmU7XHJcblx0ZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XHJcblx0ZXhwb3J0cy5MT0QgPSBMT0Q7XHJcblx0ZXhwb3J0cy5Ta2lubmVkTWVzaCA9IFNraW5uZWRNZXNoO1xyXG5cdGV4cG9ydHMuU2tlbGV0b24gPSBTa2VsZXRvbjtcclxuXHRleHBvcnRzLkJvbmUgPSBCb25lO1xyXG5cdGV4cG9ydHMuTWVzaCA9IE1lc2g7XHJcblx0ZXhwb3J0cy5MaW5lU2VnbWVudHMgPSBMaW5lU2VnbWVudHM7XHJcblx0ZXhwb3J0cy5MaW5lTG9vcCA9IExpbmVMb29wO1xyXG5cdGV4cG9ydHMuTGluZSA9IExpbmU7XHJcblx0ZXhwb3J0cy5Qb2ludHMgPSBQb2ludHM7XHJcblx0ZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xyXG5cdGV4cG9ydHMuVmlkZW9UZXh0dXJlID0gVmlkZW9UZXh0dXJlO1xyXG5cdGV4cG9ydHMuRGF0YVRleHR1cmUgPSBEYXRhVGV4dHVyZTtcclxuXHRleHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlID0gQ29tcHJlc3NlZFRleHR1cmU7XHJcblx0ZXhwb3J0cy5DdWJlVGV4dHVyZSA9IEN1YmVUZXh0dXJlO1xyXG5cdGV4cG9ydHMuQ2FudmFzVGV4dHVyZSA9IENhbnZhc1RleHR1cmU7XHJcblx0ZXhwb3J0cy5EZXB0aFRleHR1cmUgPSBEZXB0aFRleHR1cmU7XHJcblx0ZXhwb3J0cy5UZXh0dXJlID0gVGV4dHVyZTtcclxuXHRleHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXI7XHJcblx0ZXhwb3J0cy5EYXRhVGV4dHVyZUxvYWRlciA9IERhdGFUZXh0dXJlTG9hZGVyO1xyXG5cdGV4cG9ydHMuQ3ViZVRleHR1cmVMb2FkZXIgPSBDdWJlVGV4dHVyZUxvYWRlcjtcclxuXHRleHBvcnRzLlRleHR1cmVMb2FkZXIgPSBUZXh0dXJlTG9hZGVyO1xyXG5cdGV4cG9ydHMuT2JqZWN0TG9hZGVyID0gT2JqZWN0TG9hZGVyO1xyXG5cdGV4cG9ydHMuTWF0ZXJpYWxMb2FkZXIgPSBNYXRlcmlhbExvYWRlcjtcclxuXHRleHBvcnRzLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gQnVmZmVyR2VvbWV0cnlMb2FkZXI7XHJcblx0ZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XHJcblx0ZXhwb3J0cy5Mb2FkaW5nTWFuYWdlciA9IExvYWRpbmdNYW5hZ2VyO1xyXG5cdGV4cG9ydHMuSlNPTkxvYWRlciA9IEpTT05Mb2FkZXI7XHJcblx0ZXhwb3J0cy5JbWFnZUxvYWRlciA9IEltYWdlTG9hZGVyO1xyXG5cdGV4cG9ydHMuSW1hZ2VCaXRtYXBMb2FkZXIgPSBJbWFnZUJpdG1hcExvYWRlcjtcclxuXHRleHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xyXG5cdGV4cG9ydHMuRmlsZUxvYWRlciA9IEZpbGVMb2FkZXI7XHJcblx0ZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XHJcblx0ZXhwb3J0cy5Mb2FkZXJVdGlscyA9IExvYWRlclV0aWxzO1xyXG5cdGV4cG9ydHMuQ2FjaGUgPSBDYWNoZTtcclxuXHRleHBvcnRzLkF1ZGlvTG9hZGVyID0gQXVkaW9Mb2FkZXI7XHJcblx0ZXhwb3J0cy5TcG90TGlnaHRTaGFkb3cgPSBTcG90TGlnaHRTaGFkb3c7XHJcblx0ZXhwb3J0cy5TcG90TGlnaHQgPSBTcG90TGlnaHQ7XHJcblx0ZXhwb3J0cy5Qb2ludExpZ2h0ID0gUG9pbnRMaWdodDtcclxuXHRleHBvcnRzLlJlY3RBcmVhTGlnaHQgPSBSZWN0QXJlYUxpZ2h0O1xyXG5cdGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0ID0gSGVtaXNwaGVyZUxpZ2h0O1xyXG5cdGV4cG9ydHMuRGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IERpcmVjdGlvbmFsTGlnaHRTaGFkb3c7XHJcblx0ZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0ID0gRGlyZWN0aW9uYWxMaWdodDtcclxuXHRleHBvcnRzLkFtYmllbnRMaWdodCA9IEFtYmllbnRMaWdodDtcclxuXHRleHBvcnRzLkxpZ2h0U2hhZG93ID0gTGlnaHRTaGFkb3c7XHJcblx0ZXhwb3J0cy5MaWdodCA9IExpZ2h0O1xyXG5cdGV4cG9ydHMuU3RlcmVvQ2FtZXJhID0gU3RlcmVvQ2FtZXJhO1xyXG5cdGV4cG9ydHMuUGVyc3BlY3RpdmVDYW1lcmEgPSBQZXJzcGVjdGl2ZUNhbWVyYTtcclxuXHRleHBvcnRzLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IE9ydGhvZ3JhcGhpY0NhbWVyYTtcclxuXHRleHBvcnRzLkN1YmVDYW1lcmEgPSBDdWJlQ2FtZXJhO1xyXG5cdGV4cG9ydHMuQXJyYXlDYW1lcmEgPSBBcnJheUNhbWVyYTtcclxuXHRleHBvcnRzLkNhbWVyYSA9IENhbWVyYTtcclxuXHRleHBvcnRzLkF1ZGlvTGlzdGVuZXIgPSBBdWRpb0xpc3RlbmVyO1xyXG5cdGV4cG9ydHMuUG9zaXRpb25hbEF1ZGlvID0gUG9zaXRpb25hbEF1ZGlvO1xyXG5cdGV4cG9ydHMuQXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0O1xyXG5cdGV4cG9ydHMuQXVkaW9BbmFseXNlciA9IEF1ZGlvQW5hbHlzZXI7XHJcblx0ZXhwb3J0cy5BdWRpbyA9IEF1ZGlvO1xyXG5cdGV4cG9ydHMuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XHJcblx0ZXhwb3J0cy5TdHJpbmdLZXlmcmFtZVRyYWNrID0gU3RyaW5nS2V5ZnJhbWVUcmFjaztcclxuXHRleHBvcnRzLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XHJcblx0ZXhwb3J0cy5OdW1iZXJLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcclxuXHRleHBvcnRzLkNvbG9yS2V5ZnJhbWVUcmFjayA9IENvbG9yS2V5ZnJhbWVUcmFjaztcclxuXHRleHBvcnRzLkJvb2xlYW5LZXlmcmFtZVRyYWNrID0gQm9vbGVhbktleWZyYW1lVHJhY2s7XHJcblx0ZXhwb3J0cy5Qcm9wZXJ0eU1peGVyID0gUHJvcGVydHlNaXhlcjtcclxuXHRleHBvcnRzLlByb3BlcnR5QmluZGluZyA9IFByb3BlcnR5QmluZGluZztcclxuXHRleHBvcnRzLktleWZyYW1lVHJhY2sgPSBLZXlmcmFtZVRyYWNrO1xyXG5cdGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMgPSBBbmltYXRpb25VdGlscztcclxuXHRleHBvcnRzLkFuaW1hdGlvbk9iamVjdEdyb3VwID0gQW5pbWF0aW9uT2JqZWN0R3JvdXA7XHJcblx0ZXhwb3J0cy5BbmltYXRpb25NaXhlciA9IEFuaW1hdGlvbk1peGVyO1xyXG5cdGV4cG9ydHMuQW5pbWF0aW9uQ2xpcCA9IEFuaW1hdGlvbkNsaXA7XHJcblx0ZXhwb3J0cy5Vbmlmb3JtID0gVW5pZm9ybTtcclxuXHRleHBvcnRzLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5CdWZmZXJHZW9tZXRyeSA9IEJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcclxuXHRleHBvcnRzLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xyXG5cdGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnRlcmxlYXZlZEJ1ZmZlcjtcclxuXHRleHBvcnRzLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLkZhY2UzID0gRmFjZTM7XHJcblx0ZXhwb3J0cy5PYmplY3QzRCA9IE9iamVjdDNEO1xyXG5cdGV4cG9ydHMuUmF5Y2FzdGVyID0gUmF5Y2FzdGVyO1xyXG5cdGV4cG9ydHMuTGF5ZXJzID0gTGF5ZXJzO1xyXG5cdGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG5cdGV4cG9ydHMuQ2xvY2sgPSBDbG9jaztcclxuXHRleHBvcnRzLlF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCA9IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudDtcclxuXHRleHBvcnRzLkxpbmVhckludGVycG9sYW50ID0gTGluZWFySW50ZXJwb2xhbnQ7XHJcblx0ZXhwb3J0cy5EaXNjcmV0ZUludGVycG9sYW50ID0gRGlzY3JldGVJbnRlcnBvbGFudDtcclxuXHRleHBvcnRzLkN1YmljSW50ZXJwb2xhbnQgPSBDdWJpY0ludGVycG9sYW50O1xyXG5cdGV4cG9ydHMuSW50ZXJwb2xhbnQgPSBJbnRlcnBvbGFudDtcclxuXHRleHBvcnRzLlRyaWFuZ2xlID0gVHJpYW5nbGU7XHJcblx0ZXhwb3J0cy5NYXRoID0gX01hdGg7XHJcblx0ZXhwb3J0cy5TcGhlcmljYWwgPSBTcGhlcmljYWw7XHJcblx0ZXhwb3J0cy5DeWxpbmRyaWNhbCA9IEN5bGluZHJpY2FsO1xyXG5cdGV4cG9ydHMuUGxhbmUgPSBQbGFuZTtcclxuXHRleHBvcnRzLkZydXN0dW0gPSBGcnVzdHVtO1xyXG5cdGV4cG9ydHMuU3BoZXJlID0gU3BoZXJlO1xyXG5cdGV4cG9ydHMuUmF5ID0gUmF5O1xyXG5cdGV4cG9ydHMuTWF0cml4NCA9IE1hdHJpeDQ7XHJcblx0ZXhwb3J0cy5NYXRyaXgzID0gTWF0cml4MztcclxuXHRleHBvcnRzLkJveDMgPSBCb3gzO1xyXG5cdGV4cG9ydHMuQm94MiA9IEJveDI7XHJcblx0ZXhwb3J0cy5MaW5lMyA9IExpbmUzO1xyXG5cdGV4cG9ydHMuRXVsZXIgPSBFdWxlcjtcclxuXHRleHBvcnRzLlZlY3RvcjQgPSBWZWN0b3I0O1xyXG5cdGV4cG9ydHMuVmVjdG9yMyA9IFZlY3RvcjM7XHJcblx0ZXhwb3J0cy5WZWN0b3IyID0gVmVjdG9yMjtcclxuXHRleHBvcnRzLlF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uO1xyXG5cdGV4cG9ydHMuQ29sb3IgPSBDb2xvcjtcclxuXHRleHBvcnRzLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IEltbWVkaWF0ZVJlbmRlck9iamVjdDtcclxuXHRleHBvcnRzLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xyXG5cdGV4cG9ydHMuU3BvdExpZ2h0SGVscGVyID0gU3BvdExpZ2h0SGVscGVyO1xyXG5cdGV4cG9ydHMuU2tlbGV0b25IZWxwZXIgPSBTa2VsZXRvbkhlbHBlcjtcclxuXHRleHBvcnRzLlBvaW50TGlnaHRIZWxwZXIgPSBQb2ludExpZ2h0SGVscGVyO1xyXG5cdGV4cG9ydHMuUmVjdEFyZWFMaWdodEhlbHBlciA9IFJlY3RBcmVhTGlnaHRIZWxwZXI7XHJcblx0ZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XHJcblx0ZXhwb3J0cy5HcmlkSGVscGVyID0gR3JpZEhlbHBlcjtcclxuXHRleHBvcnRzLlBvbGFyR3JpZEhlbHBlciA9IFBvbGFyR3JpZEhlbHBlcjtcclxuXHRleHBvcnRzLkZhY2VOb3JtYWxzSGVscGVyID0gRmFjZU5vcm1hbHNIZWxwZXI7XHJcblx0ZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcclxuXHRleHBvcnRzLkNhbWVyYUhlbHBlciA9IENhbWVyYUhlbHBlcjtcclxuXHRleHBvcnRzLkJveEhlbHBlciA9IEJveEhlbHBlcjtcclxuXHRleHBvcnRzLkJveDNIZWxwZXIgPSBCb3gzSGVscGVyO1xyXG5cdGV4cG9ydHMuUGxhbmVIZWxwZXIgPSBQbGFuZUhlbHBlcjtcclxuXHRleHBvcnRzLkFycm93SGVscGVyID0gQXJyb3dIZWxwZXI7XHJcblx0ZXhwb3J0cy5BeGVzSGVscGVyID0gQXhlc0hlbHBlcjtcclxuXHRleHBvcnRzLlNoYXBlID0gU2hhcGU7XHJcblx0ZXhwb3J0cy5QYXRoID0gUGF0aDtcclxuXHRleHBvcnRzLlNoYXBlUGF0aCA9IFNoYXBlUGF0aDtcclxuXHRleHBvcnRzLkZvbnQgPSBGb250O1xyXG5cdGV4cG9ydHMuQ3VydmVQYXRoID0gQ3VydmVQYXRoO1xyXG5cdGV4cG9ydHMuQ3VydmUgPSBDdXJ2ZTtcclxuXHRleHBvcnRzLlNoYXBlVXRpbHMgPSBTaGFwZVV0aWxzO1xyXG5cdGV4cG9ydHMuU2NlbmVVdGlscyA9IFNjZW5lVXRpbHM7XHJcblx0ZXhwb3J0cy5XZWJHTFV0aWxzID0gV2ViR0xVdGlscztcclxuXHRleHBvcnRzLldpcmVmcmFtZUdlb21ldHJ5ID0gV2lyZWZyYW1lR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5QYXJhbWV0cmljR2VvbWV0cnkgPSBQYXJhbWV0cmljR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5QYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkgPSBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcclxuXHRleHBvcnRzLlRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuT2N0YWhlZHJvbkdlb21ldHJ5ID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuSWNvc2FoZWRyb25HZW9tZXRyeSA9IEljb3NhaGVkcm9uR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcclxuXHRleHBvcnRzLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5Eb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSA9IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuUG9seWhlZHJvbkdlb21ldHJ5ID0gUG9seWhlZHJvbkdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuVHViZUdlb21ldHJ5ID0gVHViZUdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuVHViZUJ1ZmZlckdlb21ldHJ5ID0gVHViZUJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuVG9ydXNLbm90R2VvbWV0cnkgPSBUb3J1c0tub3RHZW9tZXRyeTtcclxuXHRleHBvcnRzLlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5ID0gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5Ub3J1c0dlb21ldHJ5ID0gVG9ydXNHZW9tZXRyeTtcclxuXHRleHBvcnRzLlRvcnVzQnVmZmVyR2VvbWV0cnkgPSBUb3J1c0J1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuVGV4dEdlb21ldHJ5ID0gVGV4dEdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuVGV4dEJ1ZmZlckdlb21ldHJ5ID0gVGV4dEJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuU3BoZXJlR2VvbWV0cnkgPSBTcGhlcmVHZW9tZXRyeTtcclxuXHRleHBvcnRzLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5SaW5nR2VvbWV0cnkgPSBSaW5nR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5SaW5nQnVmZmVyR2VvbWV0cnkgPSBSaW5nQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcclxuXHRleHBvcnRzLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuTGF0aGVHZW9tZXRyeSA9IExhdGhlR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5MYXRoZUJ1ZmZlckdlb21ldHJ5ID0gTGF0aGVCdWZmZXJHZW9tZXRyeTtcclxuXHRleHBvcnRzLlNoYXBlR2VvbWV0cnkgPSBTaGFwZUdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuU2hhcGVCdWZmZXJHZW9tZXRyeSA9IFNoYXBlQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5FeHRydWRlR2VvbWV0cnkgPSBFeHRydWRlR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5FeHRydWRlQnVmZmVyR2VvbWV0cnkgPSBFeHRydWRlQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5FZGdlc0dlb21ldHJ5ID0gRWRnZXNHZW9tZXRyeTtcclxuXHRleHBvcnRzLkNvbmVHZW9tZXRyeSA9IENvbmVHZW9tZXRyeTtcclxuXHRleHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVCdWZmZXJHZW9tZXRyeTtcclxuXHRleHBvcnRzLkN5bGluZGVyR2VvbWV0cnkgPSBDeWxpbmRlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSA9IEN5bGluZGVyQnVmZmVyR2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5DaXJjbGVHZW9tZXRyeSA9IENpcmNsZUdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBDaXJjbGVCdWZmZXJHZW9tZXRyeTtcclxuXHRleHBvcnRzLkJveEdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5Cb3hCdWZmZXJHZW9tZXRyeSA9IEJveEJ1ZmZlckdlb21ldHJ5O1xyXG5cdGV4cG9ydHMuU2hhZG93TWF0ZXJpYWwgPSBTaGFkb3dNYXRlcmlhbDtcclxuXHRleHBvcnRzLlNwcml0ZU1hdGVyaWFsID0gU3ByaXRlTWF0ZXJpYWw7XHJcblx0ZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xyXG5cdGV4cG9ydHMuU2hhZGVyTWF0ZXJpYWwgPSBTaGFkZXJNYXRlcmlhbDtcclxuXHRleHBvcnRzLlBvaW50c01hdGVyaWFsID0gUG9pbnRzTWF0ZXJpYWw7XHJcblx0ZXhwb3J0cy5NZXNoUGh5c2ljYWxNYXRlcmlhbCA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xyXG5cdGV4cG9ydHMuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcclxuXHRleHBvcnRzLk1lc2hQaG9uZ01hdGVyaWFsID0gTWVzaFBob25nTWF0ZXJpYWw7XHJcblx0ZXhwb3J0cy5NZXNoVG9vbk1hdGVyaWFsID0gTWVzaFRvb25NYXRlcmlhbDtcclxuXHRleHBvcnRzLk1lc2hOb3JtYWxNYXRlcmlhbCA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcclxuXHRleHBvcnRzLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xyXG5cdGV4cG9ydHMuTWVzaERlcHRoTWF0ZXJpYWwgPSBNZXNoRGVwdGhNYXRlcmlhbDtcclxuXHRleHBvcnRzLk1lc2hEaXN0YW5jZU1hdGVyaWFsID0gTWVzaERpc3RhbmNlTWF0ZXJpYWw7XHJcblx0ZXhwb3J0cy5NZXNoQmFzaWNNYXRlcmlhbCA9IE1lc2hCYXNpY01hdGVyaWFsO1xyXG5cdGV4cG9ydHMuTGluZURhc2hlZE1hdGVyaWFsID0gTGluZURhc2hlZE1hdGVyaWFsO1xyXG5cdGV4cG9ydHMuTGluZUJhc2ljTWF0ZXJpYWwgPSBMaW5lQmFzaWNNYXRlcmlhbDtcclxuXHRleHBvcnRzLk1hdGVyaWFsID0gTWF0ZXJpYWw7XHJcblx0ZXhwb3J0cy5GbG9hdDY0QnVmZmVyQXR0cmlidXRlID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgPSBGbG9hdDMyQnVmZmVyQXR0cmlidXRlO1xyXG5cdGV4cG9ydHMuVWludDMyQnVmZmVyQXR0cmlidXRlID0gVWludDMyQnVmZmVyQXR0cmlidXRlO1xyXG5cdGV4cG9ydHMuSW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBJbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLlVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLkludDE2QnVmZmVyQXR0cmlidXRlID0gSW50MTZCdWZmZXJBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5VaW50OEJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQ4QnVmZmVyQXR0cmlidXRlO1xyXG5cdGV4cG9ydHMuSW50OEJ1ZmZlckF0dHJpYnV0ZSA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5CdWZmZXJBdHRyaWJ1dGUgPSBCdWZmZXJBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5BcmNDdXJ2ZSA9IEFyY0N1cnZlO1xyXG5cdGV4cG9ydHMuQ2F0bXVsbFJvbUN1cnZlMyA9IENhdG11bGxSb21DdXJ2ZTM7XHJcblx0ZXhwb3J0cy5DdWJpY0JlemllckN1cnZlID0gQ3ViaWNCZXppZXJDdXJ2ZTtcclxuXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUzID0gQ3ViaWNCZXppZXJDdXJ2ZTM7XHJcblx0ZXhwb3J0cy5FbGxpcHNlQ3VydmUgPSBFbGxpcHNlQ3VydmU7XHJcblx0ZXhwb3J0cy5MaW5lQ3VydmUgPSBMaW5lQ3VydmU7XHJcblx0ZXhwb3J0cy5MaW5lQ3VydmUzID0gTGluZUN1cnZlMztcclxuXHRleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XHJcblx0ZXhwb3J0cy5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XHJcblx0ZXhwb3J0cy5TcGxpbmVDdXJ2ZSA9IFNwbGluZUN1cnZlO1xyXG5cdGV4cG9ydHMuUkVWSVNJT04gPSBSRVZJU0lPTjtcclxuXHRleHBvcnRzLk1PVVNFID0gTU9VU0U7XHJcblx0ZXhwb3J0cy5DdWxsRmFjZU5vbmUgPSBDdWxsRmFjZU5vbmU7XHJcblx0ZXhwb3J0cy5DdWxsRmFjZUJhY2sgPSBDdWxsRmFjZUJhY2s7XHJcblx0ZXhwb3J0cy5DdWxsRmFjZUZyb250ID0gQ3VsbEZhY2VGcm9udDtcclxuXHRleHBvcnRzLkN1bGxGYWNlRnJvbnRCYWNrID0gQ3VsbEZhY2VGcm9udEJhY2s7XHJcblx0ZXhwb3J0cy5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IEZyb250RmFjZURpcmVjdGlvbkNXO1xyXG5cdGV4cG9ydHMuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gRnJvbnRGYWNlRGlyZWN0aW9uQ0NXO1xyXG5cdGV4cG9ydHMuQmFzaWNTaGFkb3dNYXAgPSBCYXNpY1NoYWRvd01hcDtcclxuXHRleHBvcnRzLlBDRlNoYWRvd01hcCA9IFBDRlNoYWRvd01hcDtcclxuXHRleHBvcnRzLlBDRlNvZnRTaGFkb3dNYXAgPSBQQ0ZTb2Z0U2hhZG93TWFwO1xyXG5cdGV4cG9ydHMuRnJvbnRTaWRlID0gRnJvbnRTaWRlO1xyXG5cdGV4cG9ydHMuQmFja1NpZGUgPSBCYWNrU2lkZTtcclxuXHRleHBvcnRzLkRvdWJsZVNpZGUgPSBEb3VibGVTaWRlO1xyXG5cdGV4cG9ydHMuRmxhdFNoYWRpbmcgPSBGbGF0U2hhZGluZztcclxuXHRleHBvcnRzLlNtb290aFNoYWRpbmcgPSBTbW9vdGhTaGFkaW5nO1xyXG5cdGV4cG9ydHMuTm9Db2xvcnMgPSBOb0NvbG9ycztcclxuXHRleHBvcnRzLkZhY2VDb2xvcnMgPSBGYWNlQ29sb3JzO1xyXG5cdGV4cG9ydHMuVmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xyXG5cdGV4cG9ydHMuTm9CbGVuZGluZyA9IE5vQmxlbmRpbmc7XHJcblx0ZXhwb3J0cy5Ob3JtYWxCbGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xyXG5cdGV4cG9ydHMuQWRkaXRpdmVCbGVuZGluZyA9IEFkZGl0aXZlQmxlbmRpbmc7XHJcblx0ZXhwb3J0cy5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gU3VidHJhY3RpdmVCbGVuZGluZztcclxuXHRleHBvcnRzLk11bHRpcGx5QmxlbmRpbmcgPSBNdWx0aXBseUJsZW5kaW5nO1xyXG5cdGV4cG9ydHMuQ3VzdG9tQmxlbmRpbmcgPSBDdXN0b21CbGVuZGluZztcclxuXHRleHBvcnRzLkFkZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XHJcblx0ZXhwb3J0cy5TdWJ0cmFjdEVxdWF0aW9uID0gU3VidHJhY3RFcXVhdGlvbjtcclxuXHRleHBvcnRzLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb247XHJcblx0ZXhwb3J0cy5NaW5FcXVhdGlvbiA9IE1pbkVxdWF0aW9uO1xyXG5cdGV4cG9ydHMuTWF4RXF1YXRpb24gPSBNYXhFcXVhdGlvbjtcclxuXHRleHBvcnRzLlplcm9GYWN0b3IgPSBaZXJvRmFjdG9yO1xyXG5cdGV4cG9ydHMuT25lRmFjdG9yID0gT25lRmFjdG9yO1xyXG5cdGV4cG9ydHMuU3JjQ29sb3JGYWN0b3IgPSBTcmNDb2xvckZhY3RvcjtcclxuXHRleHBvcnRzLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yO1xyXG5cdGV4cG9ydHMuU3JjQWxwaGFGYWN0b3IgPSBTcmNBbHBoYUZhY3RvcjtcclxuXHRleHBvcnRzLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xyXG5cdGV4cG9ydHMuRHN0QWxwaGFGYWN0b3IgPSBEc3RBbHBoYUZhY3RvcjtcclxuXHRleHBvcnRzLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSBPbmVNaW51c0RzdEFscGhhRmFjdG9yO1xyXG5cdGV4cG9ydHMuRHN0Q29sb3JGYWN0b3IgPSBEc3RDb2xvckZhY3RvcjtcclxuXHRleHBvcnRzLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSBPbmVNaW51c0RzdENvbG9yRmFjdG9yO1xyXG5cdGV4cG9ydHMuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IFNyY0FscGhhU2F0dXJhdGVGYWN0b3I7XHJcblx0ZXhwb3J0cy5OZXZlckRlcHRoID0gTmV2ZXJEZXB0aDtcclxuXHRleHBvcnRzLkFsd2F5c0RlcHRoID0gQWx3YXlzRGVwdGg7XHJcblx0ZXhwb3J0cy5MZXNzRGVwdGggPSBMZXNzRGVwdGg7XHJcblx0ZXhwb3J0cy5MZXNzRXF1YWxEZXB0aCA9IExlc3NFcXVhbERlcHRoO1xyXG5cdGV4cG9ydHMuRXF1YWxEZXB0aCA9IEVxdWFsRGVwdGg7XHJcblx0ZXhwb3J0cy5HcmVhdGVyRXF1YWxEZXB0aCA9IEdyZWF0ZXJFcXVhbERlcHRoO1xyXG5cdGV4cG9ydHMuR3JlYXRlckRlcHRoID0gR3JlYXRlckRlcHRoO1xyXG5cdGV4cG9ydHMuTm90RXF1YWxEZXB0aCA9IE5vdEVxdWFsRGVwdGg7XHJcblx0ZXhwb3J0cy5NdWx0aXBseU9wZXJhdGlvbiA9IE11bHRpcGx5T3BlcmF0aW9uO1xyXG5cdGV4cG9ydHMuTWl4T3BlcmF0aW9uID0gTWl4T3BlcmF0aW9uO1xyXG5cdGV4cG9ydHMuQWRkT3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uO1xyXG5cdGV4cG9ydHMuTm9Ub25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XHJcblx0ZXhwb3J0cy5MaW5lYXJUb25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nO1xyXG5cdGV4cG9ydHMuUmVpbmhhcmRUb25lTWFwcGluZyA9IFJlaW5oYXJkVG9uZU1hcHBpbmc7XHJcblx0ZXhwb3J0cy5VbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc7XHJcblx0ZXhwb3J0cy5DaW5lb25Ub25lTWFwcGluZyA9IENpbmVvblRvbmVNYXBwaW5nO1xyXG5cdGV4cG9ydHMuVVZNYXBwaW5nID0gVVZNYXBwaW5nO1xyXG5cdGV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xyXG5cdGV4cG9ydHMuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xyXG5cdGV4cG9ydHMuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcclxuXHRleHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc7XHJcblx0ZXhwb3J0cy5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nO1xyXG5cdGV4cG9ydHMuQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcclxuXHRleHBvcnRzLkN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc7XHJcblx0ZXhwb3J0cy5SZXBlYXRXcmFwcGluZyA9IFJlcGVhdFdyYXBwaW5nO1xyXG5cdGV4cG9ydHMuQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0ZXhwb3J0cy5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcclxuXHRleHBvcnRzLk5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG5cdGV4cG9ydHMuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjtcclxuXHRleHBvcnRzLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyO1xyXG5cdGV4cG9ydHMuTGluZWFyRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cdGV4cG9ydHMuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI7XHJcblx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XHJcblx0ZXhwb3J0cy5VbnNpZ25lZEJ5dGVUeXBlID0gVW5zaWduZWRCeXRlVHlwZTtcclxuXHRleHBvcnRzLkJ5dGVUeXBlID0gQnl0ZVR5cGU7XHJcblx0ZXhwb3J0cy5TaG9ydFR5cGUgPSBTaG9ydFR5cGU7XHJcblx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0VHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xyXG5cdGV4cG9ydHMuSW50VHlwZSA9IEludFR5cGU7XHJcblx0ZXhwb3J0cy5VbnNpZ25lZEludFR5cGUgPSBVbnNpZ25lZEludFR5cGU7XHJcblx0ZXhwb3J0cy5GbG9hdFR5cGUgPSBGbG9hdFR5cGU7XHJcblx0ZXhwb3J0cy5IYWxmRmxvYXRUeXBlID0gSGFsZkZsb2F0VHlwZTtcclxuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTtcclxuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTtcclxuXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gVW5zaWduZWRTaG9ydDU2NVR5cGU7XHJcblx0ZXhwb3J0cy5VbnNpZ25lZEludDI0OFR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XHJcblx0ZXhwb3J0cy5BbHBoYUZvcm1hdCA9IEFscGhhRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCRm9ybWF0ID0gUkdCRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XHJcblx0ZXhwb3J0cy5MdW1pbmFuY2VGb3JtYXQgPSBMdW1pbmFuY2VGb3JtYXQ7XHJcblx0ZXhwb3J0cy5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IEx1bWluYW5jZUFscGhhRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCRUZvcm1hdCA9IFJHQkVGb3JtYXQ7XHJcblx0ZXhwb3J0cy5EZXB0aEZvcm1hdCA9IERlcHRoRm9ybWF0O1xyXG5cdGV4cG9ydHMuRGVwdGhTdGVuY2lsRm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcclxuXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdDtcclxuXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdDtcclxuXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDtcclxuXHRleHBvcnRzLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQ7XHJcblx0ZXhwb3J0cy5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0O1xyXG5cdGV4cG9ydHMuUkdCX0VUQzFfRm9ybWF0ID0gUkdCX0VUQzFfRm9ybWF0O1xyXG5cdGV4cG9ydHMuTG9vcE9uY2UgPSBMb29wT25jZTtcclxuXHRleHBvcnRzLkxvb3BSZXBlYXQgPSBMb29wUmVwZWF0O1xyXG5cdGV4cG9ydHMuTG9vcFBpbmdQb25nID0gTG9vcFBpbmdQb25nO1xyXG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IEludGVycG9sYXRlRGlzY3JldGU7XHJcblx0ZXhwb3J0cy5JbnRlcnBvbGF0ZUxpbmVhciA9IEludGVycG9sYXRlTGluZWFyO1xyXG5cdGV4cG9ydHMuSW50ZXJwb2xhdGVTbW9vdGggPSBJbnRlcnBvbGF0ZVNtb290aDtcclxuXHRleHBvcnRzLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSBaZXJvQ3VydmF0dXJlRW5kaW5nO1xyXG5cdGV4cG9ydHMuWmVyb1Nsb3BlRW5kaW5nID0gWmVyb1Nsb3BlRW5kaW5nO1xyXG5cdGV4cG9ydHMuV3JhcEFyb3VuZEVuZGluZyA9IFdyYXBBcm91bmRFbmRpbmc7XHJcblx0ZXhwb3J0cy5UcmlhbmdsZXNEcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xyXG5cdGV4cG9ydHMuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gVHJpYW5nbGVTdHJpcERyYXdNb2RlO1xyXG5cdGV4cG9ydHMuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IFRyaWFuZ2xlRmFuRHJhd01vZGU7XHJcblx0ZXhwb3J0cy5MaW5lYXJFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xyXG5cdGV4cG9ydHMuc1JHQkVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xyXG5cdGV4cG9ydHMuR2FtbWFFbmNvZGluZyA9IEdhbW1hRW5jb2Rpbmc7XHJcblx0ZXhwb3J0cy5SR0JFRW5jb2RpbmcgPSBSR0JFRW5jb2Rpbmc7XHJcblx0ZXhwb3J0cy5Mb2dMdXZFbmNvZGluZyA9IExvZ0x1dkVuY29kaW5nO1xyXG5cdGV4cG9ydHMuUkdCTTdFbmNvZGluZyA9IFJHQk03RW5jb2Rpbmc7XHJcblx0ZXhwb3J0cy5SR0JNMTZFbmNvZGluZyA9IFJHQk0xNkVuY29kaW5nO1xyXG5cdGV4cG9ydHMuUkdCREVuY29kaW5nID0gUkdCREVuY29kaW5nO1xyXG5cdGV4cG9ydHMuQmFzaWNEZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcclxuXHRleHBvcnRzLlJHQkFEZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nO1xyXG5cdGV4cG9ydHMuQ3ViZUdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XHJcblx0ZXhwb3J0cy5GYWNlNCA9IEZhY2U0O1xyXG5cdGV4cG9ydHMuTGluZVN0cmlwID0gTGluZVN0cmlwO1xyXG5cdGV4cG9ydHMuTGluZVBpZWNlcyA9IExpbmVQaWVjZXM7XHJcblx0ZXhwb3J0cy5NZXNoRmFjZU1hdGVyaWFsID0gTWVzaEZhY2VNYXRlcmlhbDtcclxuXHRleHBvcnRzLk11bHRpTWF0ZXJpYWwgPSBNdWx0aU1hdGVyaWFsO1xyXG5cdGV4cG9ydHMuUG9pbnRDbG91ZCA9IFBvaW50Q2xvdWQ7XHJcblx0ZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xyXG5cdGV4cG9ydHMuUGFydGljbGVTeXN0ZW0gPSBQYXJ0aWNsZVN5c3RlbTtcclxuXHRleHBvcnRzLlBvaW50Q2xvdWRNYXRlcmlhbCA9IFBvaW50Q2xvdWRNYXRlcmlhbDtcclxuXHRleHBvcnRzLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFBhcnRpY2xlQmFzaWNNYXRlcmlhbDtcclxuXHRleHBvcnRzLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1xyXG5cdGV4cG9ydHMuVmVydGV4ID0gVmVydGV4O1xyXG5cdGV4cG9ydHMuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IER5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5JbnQ4QXR0cmlidXRlID0gSW50OEF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLlVpbnQ4QXR0cmlidXRlID0gVWludDhBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5JbnQxNkF0dHJpYnV0ZSA9IEludDE2QXR0cmlidXRlO1xyXG5cdGV4cG9ydHMuVWludDE2QXR0cmlidXRlID0gVWludDE2QXR0cmlidXRlO1xyXG5cdGV4cG9ydHMuSW50MzJBdHRyaWJ1dGUgPSBJbnQzMkF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLlVpbnQzMkF0dHJpYnV0ZSA9IFVpbnQzMkF0dHJpYnV0ZTtcclxuXHRleHBvcnRzLkZsb2F0MzJBdHRyaWJ1dGUgPSBGbG9hdDMyQXR0cmlidXRlO1xyXG5cdGV4cG9ydHMuRmxvYXQ2NEF0dHJpYnV0ZSA9IEZsb2F0NjRBdHRyaWJ1dGU7XHJcblx0ZXhwb3J0cy5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBDbG9zZWRTcGxpbmVDdXJ2ZTM7XHJcblx0ZXhwb3J0cy5TcGxpbmVDdXJ2ZTMgPSBTcGxpbmVDdXJ2ZTM7XHJcblx0ZXhwb3J0cy5TcGxpbmUgPSBTcGxpbmU7XHJcblx0ZXhwb3J0cy5BeGlzSGVscGVyID0gQXhpc0hlbHBlcjtcclxuXHRleHBvcnRzLkJvdW5kaW5nQm94SGVscGVyID0gQm91bmRpbmdCb3hIZWxwZXI7XHJcblx0ZXhwb3J0cy5FZGdlc0hlbHBlciA9IEVkZ2VzSGVscGVyO1xyXG5cdGV4cG9ydHMuV2lyZWZyYW1lSGVscGVyID0gV2lyZWZyYW1lSGVscGVyO1xyXG5cdGV4cG9ydHMuWEhSTG9hZGVyID0gWEhSTG9hZGVyO1xyXG5cdGV4cG9ydHMuQmluYXJ5VGV4dHVyZUxvYWRlciA9IEJpbmFyeVRleHR1cmVMb2FkZXI7XHJcblx0ZXhwb3J0cy5HZW9tZXRyeVV0aWxzID0gR2VvbWV0cnlVdGlscztcclxuXHRleHBvcnRzLkltYWdlVXRpbHMgPSBJbWFnZVV0aWxzO1xyXG5cdGV4cG9ydHMuUHJvamVjdG9yID0gUHJvamVjdG9yO1xyXG5cdGV4cG9ydHMuQ2FudmFzUmVuZGVyZXIgPSBDYW52YXNSZW5kZXJlcjtcclxuXHJcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbn0pKSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvbGlicy90aHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ2xpcCBmcm9tICcuL0NsaXAuanMnO1xyXG5cclxuZnVuY3Rpb24gcmVuZGVyKHVybCwgY29udGFpbmVyLCBjYWxsYmFjayl7XHJcbiAgbmV3IENsaXAoKS5yZW5kZXIodXJsLCBjb250YWluZXIsIGNhbGxiYWNrKTtcclxufVxyXG5cclxuZ2xvYmFsLkhNSTNEUmVuZGVyZXIgPSB7XHJcbiAgcmVuZGVyOiByZW5kZXIsXHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQSAzRCBjbGlwXHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAnLi9saWJzL3RocmVlLmpzJztcclxuaW1wb3J0IExvYWQgZnJvbSBcIi4vQmxlbmRMb2FkZXIuanNcIjtcclxuaW1wb3J0IFwiLi9PcmJpdENvbnRyb2xzLmpzXCI7XHJcblxyXG5jb25zdCBDT05UUk9MX01JTl9ESVNUQU5DRSA9IDEwO1xyXG5jb25zdCBDT05UUk9MX01BWF9ESVNUQU5DRSA9IDUwO1xyXG5cclxuZnVuY3Rpb24gQ2xpcCgpIHsgfVxyXG5DbGlwLmVuYWJsZVN0YXRzID0gZmFsc2U7XHJcblxyXG5DbGlwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICB3aWR0aDogdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsXHJcbiAgICBoZWlnaHQ6IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodFxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyBcclxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlci51cmwgOiB0aGUgdXJsIHRvIHRoZSBmaWxlXHJcbiAqIEBwYXJhbSB7ZG9tRWxlbWVudH0gcGFyYW1ldGVycy5jb250YWluZXIgOiB0aGUgY29udGFpbnRlciBvZiB0aGUgQ2xpcFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IHBhcmFtZXRlcnMuc3VjZXNzIDogY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBsb2FkIHN1Y2Nlc3NcclxuICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcil9IHBhcmFtZXRlcnMuZXJyb3IgOiBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGxvYWQgZXJyb3IgIFxyXG4gKi9cclxuQ2xpcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpe1xyXG4gIHRoaXMuY29udGFpbmVyID0gcGFyYW1ldGVycy5jb250YWluZXI7XHJcbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBmaXggdG8gZGlzYWJsZSBcImV4dGVuc2lvbiAnR0xfQVJCX2dwdV9zaGFkZXI1JyBpcyBub3Qgc3VwcG9ydGVkXCIgbG9nXHJcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy85NzE2XHJcbiAgICovXHJcbiAgdGhpcy5yZW5kZXJlci5jb250ZXh0LmdldFNoYWRlckluZm9Mb2cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnJyB9O1xyXG5cclxuICB2YXIgd2lkdGggPSB0aGlzLnNpemUoKS53aWR0aDtcclxuICB2YXIgaGVpZ2h0ID0gdGhpcy5zaXplKCkuaGVpZ2h0O1xyXG4gIHZhciB0aGF0ID0gdGhpcztcclxuICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2lkdGggLyBoZWlnaHQsIDAuMSwgMTAwMCk7XHJcbiAgdmFyIGNvbnRyb2xzID0gbmV3IFRIUkVFLk9yYml0Q29udHJvbHModGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcblxyXG4gIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcblxyXG4gIGNvbnRyb2xzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJICogMC41O1xyXG4gIGNvbnRyb2xzLm1pbkRpc3RhbmNlID0gQ09OVFJPTF9NSU5fRElTVEFOQ0U7XHJcbiAgY29udHJvbHMubWF4RGlzdGFuY2UgPSBDT05UUk9MX01BWF9ESVNUQU5DRTtcclxuXHJcbiAgTG9hZChwYXJhbWV0ZXJzLnVybCwgKHNjZW5lKSA9PiB7XHJcbiAgICB0aGF0LnNjZW5lID0gc2NlbmU7XHJcbiAgICBjb250cm9scy5yZXNldCgpO1xyXG4gICAgdGhhdC5hbmltYXRlKCk7XHJcbiAgICBpZiAocGFyYW1ldGVycy5jYWxsYmFjaykge1xyXG4gICAgICBwYXJhbWV0ZXJzLmNhbGxiYWNrKHRoaXMpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuQ2xpcC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSgpO1xyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUuYmluZCh0aGlzKSk7XHJcbiAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcclxuICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDbGlwXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvQ2xpcC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICcuL2xpYnMvdGhyZWUuanMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9hZChwYXRoLCBjYWxsYmFjaykge1xyXG4gIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuT2JqZWN0TG9hZGVyKCk7XHJcbiAgdmFyIHJlcyA9IG51bGw7XHJcblxyXG4gIGxvYWRlci5sb2FkKFxyXG4gICAgcGF0aCxcclxuICAgIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgY2FsbGJhY2sob2JqKVxyXG4gICAgfSxcclxuICAgIGZ1bmN0aW9uICh4aHIpIHtcclxuICAgICAgLy9jb25zb2xlLmxvZygoeGhyLmxvYWRlZCAvIHhoci50b3RhbCAqIDEwMCkgKyAnJSBsb2FkZWQnKTtcclxuICAgIH0sXHJcbiAgICBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignQW4gZXJyb3IgaGFwcGVuZWQnKTtcclxuICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgfVxyXG4gICk7XHJcbn1cclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvQmxlbmRMb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cclxuICovXHJcblxyXG4vLyBUaGlzIHNldCBvZiBjb250cm9scyBwZXJmb3JtcyBvcmJpdGluZywgZG9sbHlpbmcgKHpvb21pbmcpLCBhbmQgcGFubmluZy5cclxuLy8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cclxuLy9cclxuLy8gICAgT3JiaXQgLSBsZWZ0IG1vdXNlIC8gdG91Y2g6IG9uZSBmaW5nZXIgbW92ZVxyXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxyXG4vLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW5nZXIgc3dpcGVcclxuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAnLi9saWJzL3RocmVlLmpzJztcclxuXHJcblRIUkVFLk9yYml0Q29udHJvbHMgPSBmdW5jdGlvbiAoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcclxuXHJcblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9ICggZG9tRWxlbWVudCAhPT0gdW5kZWZpbmVkICkgPyBkb21FbGVtZW50IDogZG9jdW1lbnQ7XHJcblxyXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxyXG5cdHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcblxyXG5cdC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0Ly8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcclxuXHR0aGlzLm1pbkRpc3RhbmNlID0gMDtcclxuXHR0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XHJcblxyXG5cdC8vIEhvdyBmYXIgeW91IGNhbiB6b29tIGluIGFuZCBvdXQgKCBPcnRob2dyYXBoaWNDYW1lcmEgb25seSApXHJcblx0dGhpcy5taW5ab29tID0gMDtcclxuXHR0aGlzLm1heFpvb20gPSBJbmZpbml0eTtcclxuXHJcblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXHJcblx0Ly8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXHJcblx0dGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xyXG5cdHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcclxuXHJcblx0Ly8gSG93IGZhciB5b3UgY2FuIG9yYml0IGhvcml6b250YWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cclxuXHQvLyBJZiBzZXQsIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgdGhlIGludGVydmFsIFsgLSBNYXRoLlBJLCBNYXRoLlBJIF0uXHJcblx0dGhpcy5taW5BemltdXRoQW5nbGUgPSAtIEluZmluaXR5OyAvLyByYWRpYW5zXHJcblx0dGhpcy5tYXhBemltdXRoQW5nbGUgPSBJbmZpbml0eTsgLy8gcmFkaWFuc1xyXG5cclxuXHQvLyBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgZGFtcGluZyAoaW5lcnRpYSlcclxuXHQvLyBJZiBkYW1waW5nIGlzIGVuYWJsZWQsIHlvdSBtdXN0IGNhbGwgY29udHJvbHMudXBkYXRlKCkgaW4geW91ciBhbmltYXRpb24gbG9vcFxyXG5cdHRoaXMuZW5hYmxlRGFtcGluZyA9IGZhbHNlO1xyXG5cdHRoaXMuZGFtcGluZ0ZhY3RvciA9IDAuMjU7XHJcblxyXG5cdC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xyXG5cdHRoaXMuZW5hYmxlWm9vbSA9IHRydWU7XHJcblx0dGhpcy56b29tU3BlZWQgPSAxLjA7XHJcblxyXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXHJcblx0dGhpcy5lbmFibGVSb3RhdGUgPSB0cnVlO1xyXG5cdHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XHJcblxyXG5cdC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHBhbm5pbmdcclxuXHR0aGlzLmVuYWJsZVBhbiA9IHRydWU7XHJcblx0dGhpcy5rZXlQYW5TcGVlZCA9IDcuMDtcdC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcclxuXHJcblx0Ly8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcclxuXHQvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcclxuXHR0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcclxuXHR0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcclxuXHJcblx0Ly8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXHJcblx0dGhpcy5lbmFibGVLZXlzID0gdHJ1ZTtcclxuXHJcblx0Ly8gVGhlIGZvdXIgYXJyb3cga2V5c1xyXG5cdHRoaXMua2V5cyA9IHsgTEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBCT1RUT006IDQwIH07XHJcblxyXG5cdC8vIE1vdXNlIGJ1dHRvbnNcclxuXHR0aGlzLm1vdXNlQnV0dG9ucyA9IHsgT1JCSVQ6IFRIUkVFLk1PVVNFLkxFRlQsIFpPT006IFRIUkVFLk1PVVNFLk1JRERMRSwgUEFOOiBUSFJFRS5NT1VTRS5SSUdIVCB9O1xyXG5cclxuXHQvLyBmb3IgcmVzZXRcclxuXHR0aGlzLnRhcmdldDAgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xyXG5cdHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcclxuXHR0aGlzLnpvb20wID0gdGhpcy5vYmplY3Quem9vbTtcclxuXHJcblx0Ly9cclxuXHQvLyBwdWJsaWMgbWV0aG9kc1xyXG5cdC8vXHJcblxyXG5cdHRoaXMuZ2V0UG9sYXJBbmdsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJpY2FsLnBoaTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRBemltdXRoYWxBbmdsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gc3BoZXJpY2FsLnRoZXRhO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNhdmVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRzY29wZS50YXJnZXQwLmNvcHkoIHNjb3BlLnRhcmdldCApO1xyXG5cdFx0c2NvcGUucG9zaXRpb24wLmNvcHkoIHNjb3BlLm9iamVjdC5wb3NpdGlvbiApO1xyXG5cdFx0c2NvcGUuem9vbTAgPSBzY29wZS5vYmplY3Quem9vbTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRzY29wZS50YXJnZXQuY29weSggc2NvcGUudGFyZ2V0MCApO1xyXG5cdFx0c2NvcGUub2JqZWN0LnBvc2l0aW9uLmNvcHkoIHNjb3BlLnBvc2l0aW9uMCApO1xyXG5cdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcclxuXHJcblx0XHRzY29wZS5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcclxuXHJcblx0XHRzY29wZS51cGRhdGUoKTtcclxuXHJcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIHRoaXMgbWV0aG9kIGlzIGV4cG9zZWQsIGJ1dCBwZXJoYXBzIGl0IHdvdWxkIGJlIGJldHRlciBpZiB3ZSBjYW4gbWFrZSBpdCBwcml2YXRlLi4uXHJcblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gc28gY2FtZXJhLnVwIGlzIHRoZSBvcmJpdCBheGlzXHJcblx0XHR2YXIgcXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKCBvYmplY3QudXAsIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHRcdHZhciBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnNlKCk7XHJcblxyXG5cdFx0dmFyIGxhc3RQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgbGFzdFF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcblxyXG5cdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XHJcblxyXG5cdFx0XHRvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHNjb3BlLnRhcmdldCApO1xyXG5cclxuXHRcdFx0Ly8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXHJcblx0XHRcdG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXQgKTtcclxuXHJcblx0XHRcdC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcclxuXHRcdFx0c3BoZXJpY2FsLnNldEZyb21WZWN0b3IzKCBvZmZzZXQgKTtcclxuXHJcblx0XHRcdGlmICggc2NvcGUuYXV0b1JvdGF0ZSAmJiBzdGF0ZSA9PT0gU1RBVEUuTk9ORSApIHtcclxuXHJcblx0XHRcdFx0cm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3BoZXJpY2FsLnRoZXRhICs9IHNwaGVyaWNhbERlbHRhLnRoZXRhO1xyXG5cdFx0XHRzcGhlcmljYWwucGhpICs9IHNwaGVyaWNhbERlbHRhLnBoaTtcclxuXHJcblx0XHRcdC8vIHJlc3RyaWN0IHRoZXRhIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcclxuXHRcdFx0c3BoZXJpY2FsLnRoZXRhID0gTWF0aC5tYXgoIHNjb3BlLm1pbkF6aW11dGhBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heEF6aW11dGhBbmdsZSwgc3BoZXJpY2FsLnRoZXRhICkgKTtcclxuXHJcblx0XHRcdC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXHJcblx0XHRcdHNwaGVyaWNhbC5waGkgPSBNYXRoLm1heCggc2NvcGUubWluUG9sYXJBbmdsZSwgTWF0aC5taW4oIHNjb3BlLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkgKSApO1xyXG5cclxuXHRcdFx0c3BoZXJpY2FsLm1ha2VTYWZlKCk7XHJcblxyXG5cclxuXHRcdFx0c3BoZXJpY2FsLnJhZGl1cyAqPSBzY2FsZTtcclxuXHJcblx0XHRcdC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXHJcblx0XHRcdHNwaGVyaWNhbC5yYWRpdXMgPSBNYXRoLm1heCggc2NvcGUubWluRGlzdGFuY2UsIE1hdGgubWluKCBzY29wZS5tYXhEaXN0YW5jZSwgc3BoZXJpY2FsLnJhZGl1cyApICk7XHJcblxyXG5cdFx0XHQvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cclxuXHRcdFx0c2NvcGUudGFyZ2V0LmFkZCggcGFuT2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRvZmZzZXQuc2V0RnJvbVNwaGVyaWNhbCggc3BoZXJpY2FsICk7XHJcblxyXG5cdFx0XHQvLyByb3RhdGUgb2Zmc2V0IGJhY2sgdG8gXCJjYW1lcmEtdXAtdmVjdG9yLWlzLXVwXCIgc3BhY2VcclxuXHRcdFx0b2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcclxuXHJcblx0XHRcdHBvc2l0aW9uLmNvcHkoIHNjb3BlLnRhcmdldCApLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0XHRzY29wZS5vYmplY3QubG9va0F0KCBzY29wZS50YXJnZXQgKTtcclxuXHJcblx0XHRcdGlmICggc2NvcGUuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgKj0gKCAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvciApO1xyXG5cdFx0XHRcdHNwaGVyaWNhbERlbHRhLnBoaSAqPSAoIDEgLSBzY29wZS5kYW1waW5nRmFjdG9yICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRzcGhlcmljYWxEZWx0YS5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjYWxlID0gMTtcclxuXHRcdFx0cGFuT2Zmc2V0LnNldCggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGNvbmRpdGlvbiBpczpcclxuXHRcdFx0Ly8gbWluKGNhbWVyYSBkaXNwbGFjZW1lbnQsIGNhbWVyYSByb3RhdGlvbiBpbiByYWRpYW5zKV4yID4gRVBTXHJcblx0XHRcdC8vIHVzaW5nIHNtYWxsLWFuZ2xlIGFwcHJveGltYXRpb24gY29zKHgvMikgPSAxIC0geF4yIC8gOFxyXG5cclxuXHRcdFx0aWYgKCB6b29tQ2hhbmdlZCB8fFxyXG5cdFx0XHRcdGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggc2NvcGUub2JqZWN0LnBvc2l0aW9uICkgPiBFUFMgfHxcclxuXHRcdFx0XHQ4ICogKCAxIC0gbGFzdFF1YXRlcm5pb24uZG90KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApICkgPiBFUFMgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XHJcblxyXG5cdFx0XHRcdGxhc3RQb3NpdGlvbi5jb3B5KCBzY29wZS5vYmplY3QucG9zaXRpb24gKTtcclxuXHRcdFx0XHRsYXN0UXVhdGVybmlvbi5jb3B5KCBzY29wZS5vYmplY3QucXVhdGVybmlvbiApO1xyXG5cdFx0XHRcdHpvb21DaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKTtcclxuXHJcblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xyXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XHJcblxyXG5cdFx0c2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UgKTtcclxuXHRcdHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xyXG5cclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xyXG5cclxuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcclxuXHJcblx0XHQvL3Njb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTsgLy8gc2hvdWxkIHRoaXMgYmUgYWRkZWQgaGVyZT9cclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHQvLyBpbnRlcm5hbHNcclxuXHQvL1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XHJcblx0dmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCcgfTtcclxuXHR2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnIH07XHJcblxyXG5cdHZhciBTVEFURSA9IHsgTk9ORTogLSAxLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIsIFRPVUNIX1JPVEFURTogMywgVE9VQ0hfRE9MTFk6IDQsIFRPVUNIX1BBTjogNSB9O1xyXG5cclxuXHR2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHR2YXIgRVBTID0gMC4wMDAwMDE7XHJcblxyXG5cdC8vIGN1cnJlbnQgcG9zaXRpb24gaW4gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXHJcblx0dmFyIHNwaGVyaWNhbCA9IG5ldyBUSFJFRS5TcGhlcmljYWwoKTtcclxuXHR2YXIgc3BoZXJpY2FsRGVsdGEgPSBuZXcgVEhSRUUuU3BoZXJpY2FsKCk7XHJcblxyXG5cdHZhciBzY2FsZSA9IDE7XHJcblx0dmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIHpvb21DaGFuZ2VkID0gZmFsc2U7XHJcblxyXG5cdHZhciByb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIHJvdGF0ZUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIHJvdGF0ZURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0dmFyIHBhblN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHR2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0dmFyIGRvbGx5RW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHR2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xyXG5cclxuXHRcdHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnBvdyggMC45NSwgc2NvcGUuem9vbVNwZWVkICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcm90YXRlTGVmdCggYW5nbGUgKSB7XHJcblxyXG5cdFx0c3BoZXJpY2FsRGVsdGEudGhldGEgLT0gYW5nbGU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcm90YXRlVXAoIGFuZ2xlICkge1xyXG5cclxuXHRcdHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgcGFuTGVmdCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhbkxlZnQoIGRpc3RhbmNlLCBvYmplY3RNYXRyaXggKSB7XHJcblxyXG5cdFx0XHR2LnNldEZyb21NYXRyaXhDb2x1bW4oIG9iamVjdE1hdHJpeCwgMCApOyAvLyBnZXQgWCBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XHJcblx0XHRcdHYubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcclxuXHJcblx0XHRcdHBhbk9mZnNldC5hZGQoIHYgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCk7XHJcblxyXG5cdHZhciBwYW5VcCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhblVwKCBkaXN0YW5jZSwgb2JqZWN0TWF0cml4ICkge1xyXG5cclxuXHRcdFx0di5zZXRGcm9tTWF0cml4Q29sdW1uKCBvYmplY3RNYXRyaXgsIDEgKTsgLy8gZ2V0IFkgY29sdW1uIG9mIG9iamVjdE1hdHJpeFxyXG5cdFx0XHR2Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdFx0cGFuT2Zmc2V0LmFkZCggdiApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKTtcclxuXHJcblx0Ly8gZGVsdGFYIGFuZCBkZWx0YVkgYXJlIGluIHBpeGVsczsgcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXHJcblx0dmFyIHBhbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gcGFuKCBkZWx0YVgsIGRlbHRhWSApIHtcclxuXHJcblx0XHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKCBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0Ly8gcGVyc3BlY3RpdmVcclxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XHJcblx0XHRcdFx0b2Zmc2V0LmNvcHkoIHBvc2l0aW9uICkuc3ViKCBzY29wZS50YXJnZXQgKTtcclxuXHRcdFx0XHR2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRcdC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxyXG5cdFx0XHRcdHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKCAoIHNjb3BlLm9iamVjdC5mb3YgLyAyICkgKiBNYXRoLlBJIC8gMTgwLjAgKTtcclxuXHJcblx0XHRcdFx0Ly8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxyXG5cdFx0XHRcdHBhbkxlZnQoIDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XHJcblx0XHRcdFx0cGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdC8vIG9ydGhvZ3JhcGhpY1xyXG5cdFx0XHRcdHBhbkxlZnQoIGRlbHRhWCAqICggc2NvcGUub2JqZWN0LnJpZ2h0IC0gc2NvcGUub2JqZWN0LmxlZnQgKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgc2NvcGUub2JqZWN0Lm1hdHJpeCApO1xyXG5cdFx0XHRcdHBhblVwKCBkZWx0YVkgKiAoIHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tICkgLyBzY29wZS5vYmplY3Quem9vbSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgbm9yIHBlcnNwZWN0aXZlXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicgKTtcclxuXHRcdFx0XHRzY29wZS5lbmFibGVQYW4gPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCk7XHJcblxyXG5cdGZ1bmN0aW9uIGRvbGx5SW4oIGRvbGx5U2NhbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcblx0XHRcdHNjYWxlIC89IGRvbGx5U2NhbGU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tICogZG9sbHlTY2FsZSApICk7XHJcblx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XHJcblx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZG9sbHlPdXQoIGRvbGx5U2NhbGUgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSApIHtcclxuXHJcblx0XHRcdHNjYWxlICo9IGRvbGx5U2NhbGU7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0c2NvcGUub2JqZWN0Lnpvb20gPSBNYXRoLm1heCggc2NvcGUubWluWm9vbSwgTWF0aC5taW4oIHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gZG9sbHlTY2FsZSApICk7XHJcblx0XHRcdHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblx0XHRcdHpvb21DaGFuZ2VkID0gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gZG9sbHkvem9vbSBkaXNhYmxlZC4nICk7XHJcblx0XHRcdHNjb3BlLmVuYWJsZVpvb20gPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHQvLyBldmVudCBjYWxsYmFja3MgLSB1cGRhdGUgdGhlIG9iamVjdCBzdGF0ZVxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93blJvdGF0ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93blJvdGF0ZScgKTtcclxuXHJcblx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Eb2xseSggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlRG93bkRvbGx5JyApO1xyXG5cclxuXHRcdGRvbGx5U3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApIHtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUGFuJyApO1xyXG5cclxuXHRcdHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZU1vdXNlTW92ZVJvdGF0ZScgKTtcclxuXHJcblx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblx0XHRyb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XHJcblxyXG5cdFx0Ly8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxyXG5cdFx0cm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XHJcblxyXG5cdFx0Ly8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXHJcblx0XHRyb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xyXG5cclxuXHRcdHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xyXG5cclxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApIHtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlRG9sbHknICk7XHJcblxyXG5cdFx0ZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XHJcblxyXG5cdFx0ZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xyXG5cclxuXHRcdGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcclxuXHJcblx0XHRcdGRvbGx5SW4oIGdldFpvb21TY2FsZSgpICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZG9sbHlEZWx0YS55IDwgMCApIHtcclxuXHJcblx0XHRcdGRvbGx5T3V0KCBnZXRab29tU2NhbGUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XHJcblxyXG5cdFx0c2NvcGUudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlUGFuKCBldmVudCApIHtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUGFuJyApO1xyXG5cclxuXHRcdHBhbkVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcclxuXHJcblx0XHRwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XHJcblxyXG5cdFx0cGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XHJcblxyXG5cdFx0cGFuU3RhcnQuY29weSggcGFuRW5kICk7XHJcblxyXG5cdFx0c2NvcGUudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VVcCggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coICdoYW5kbGVNb3VzZVVwJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlV2hlZWwoIGV2ZW50ICkge1xyXG5cclxuXHRcdC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VXaGVlbCcgKTtcclxuXHJcblx0XHRpZiAoIGV2ZW50LmRlbHRhWSA8IDAgKSB7XHJcblxyXG5cdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldmVudC5kZWx0YVkgPiAwICkge1xyXG5cclxuXHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c2NvcGUudXBkYXRlKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlS2V5RG93biggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZUtleURvd24nICk7XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQua2V5Q29kZSApIHtcclxuXHJcblx0XHRcdGNhc2Ugc2NvcGUua2V5cy5VUDpcclxuXHRcdFx0XHRwYW4oIDAsIHNjb3BlLmtleVBhblNwZWVkICk7XHJcblx0XHRcdFx0c2NvcGUudXBkYXRlKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLmtleXMuQk9UVE9NOlxyXG5cdFx0XHRcdHBhbiggMCwgLSBzY29wZS5rZXlQYW5TcGVlZCApO1xyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLkxFRlQ6XHJcblx0XHRcdFx0cGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBzY29wZS5rZXlzLlJJR0hUOlxyXG5cdFx0XHRcdHBhbiggLSBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xyXG5cdFx0XHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCBldmVudCApIHtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFJvdGF0ZScgKTtcclxuXHJcblx0XHRyb3RhdGVTdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5KCBldmVudCApIHtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydERvbGx5JyApO1xyXG5cclxuXHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcclxuXHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcclxuXHJcblx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XHJcblxyXG5cdFx0ZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRQYW4nICk7XHJcblxyXG5cdFx0cGFuU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZVJvdGF0ZScgKTtcclxuXHJcblx0XHRyb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cdFx0cm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xyXG5cclxuXHRcdHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xyXG5cclxuXHRcdC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcclxuXHRcdHJvdGF0ZUxlZnQoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xyXG5cclxuXHRcdC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxyXG5cdFx0cm90YXRlVXAoIDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NvcGUucm90YXRlU3BlZWQgKTtcclxuXHJcblx0XHRyb3RhdGVTdGFydC5jb3B5KCByb3RhdGVFbmQgKTtcclxuXHJcblx0XHRzY29wZS51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZURvbGx5JyApO1xyXG5cclxuXHRcdHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcclxuXHRcdHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcclxuXHJcblx0XHR2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XHJcblxyXG5cdFx0ZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xyXG5cclxuXHRcdGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcclxuXHJcblx0XHRpZiAoIGRvbGx5RGVsdGEueSA+IDAgKSB7XHJcblxyXG5cdFx0XHRkb2xseU91dCggZ2V0Wm9vbVNjYWxlKCkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBkb2xseURlbHRhLnkgPCAwICkge1xyXG5cclxuXHRcdFx0ZG9sbHlJbiggZ2V0Wm9vbVNjYWxlKCkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xyXG5cclxuXHRcdHNjb3BlLnVwZGF0ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZVBhbicgKTtcclxuXHJcblx0XHRwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xyXG5cclxuXHRcdHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcclxuXHJcblx0XHRwYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcclxuXHJcblx0XHRwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcclxuXHJcblx0XHRzY29wZS51cGRhdGUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZCggZXZlbnQgKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoRW5kJyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblx0Ly8gZXZlbnQgaGFuZGxlcnMgLSBGU006IGxpc3RlbiBmb3IgZXZlbnRzIGFuZCByZXNldCBzdGF0ZVxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQuYnV0dG9uICkge1xyXG5cclxuXHRcdFx0Y2FzZSBzY29wZS5tb3VzZUJ1dHRvbnMuT1JCSVQ6XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUm90YXRlKCBldmVudCApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlJPVEFURTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLm1vdXNlQnV0dG9ucy5aT09NOlxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRoYW5kbGVNb3VzZURvd25Eb2xseSggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5ET0xMWTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIHNjb3BlLm1vdXNlQnV0dG9ucy5QQU46XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0aGFuZGxlTW91c2VEb3duUGFuKCBldmVudCApO1xyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLlBBTjtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggc3RhdGUgIT09IFNUQVRFLk5PTkUgKSB7XHJcblxyXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XHJcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xyXG5cclxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHRcdHN3aXRjaCAoIHN0YXRlICkge1xyXG5cclxuXHRcdFx0Y2FzZSBTVEFURS5ST1RBVEU6XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlUm90YXRlKCBldmVudCApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgU1RBVEUuRE9MTFk6XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZURvbGx5KCBldmVudCApO1xyXG5cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgU1RBVEUuUEFOOlxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZVBhbiggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VVcCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRoYW5kbGVNb3VzZVVwKCBldmVudCApO1xyXG5cclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcclxuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xyXG5cclxuXHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XHJcblxyXG5cdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVab29tID09PSBmYWxzZSB8fCAoIHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUgKSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0aGFuZGxlTW91c2VXaGVlbCggZXZlbnQgKTtcclxuXHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7IC8vIG5vdCBzdXJlIHdoeSB0aGVzZSBhcmUgaGVyZS4uLlxyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvbktleURvd24oIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlS2V5cyA9PT0gZmFsc2UgfHwgc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRoYW5kbGVLZXlEb3duKCBldmVudCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hTdGFydCggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdGNhc2UgMTpcdC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFJvdGF0ZSggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAyOlx0Ly8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdFx0XHRoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHRcdHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRcdFx0aGFuZGxlVG91Y2hTdGFydFBhbiggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5UT1VDSF9QQU47XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0c3RhdGUgPSBTVEFURS5OT05FO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5OT05FICkge1xyXG5cclxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBvblRvdWNoTW92ZSggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0c3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSApIHJldHVybjtcclxuXHRcdFx0XHRpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxyXG5cclxuXHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVSb3RhdGUoIGV2ZW50ICk7XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XHJcblxyXG5cdFx0XHRcdGlmICggc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgKSByZXR1cm47XHJcblx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfRE9MTFkgKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxyXG5cclxuXHRcdFx0XHRoYW5kbGVUb3VjaE1vdmVEb2xseSggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cclxuXHJcblx0XHRcdFx0aWYgKCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cdFx0XHRcdGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjsgLy8gaXMgdGhpcyBuZWVkZWQ/Li4uXHJcblxyXG5cdFx0XHRcdGhhbmRsZVRvdWNoTW92ZVBhbiggZXZlbnQgKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cclxuXHRcdFx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoIGV2ZW50ICkge1xyXG5cclxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XHJcblxyXG5cdFx0aGFuZGxlVG91Y2hFbmQoIGV2ZW50ICk7XHJcblxyXG5cdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcclxuXHJcblx0XHRzdGF0ZSA9IFNUQVRFLk5PTkU7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Db250ZXh0TWVudSggZXZlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vXHJcblxyXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UgKTtcclxuXHJcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlICk7XHJcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnd2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XHJcblxyXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlICk7XHJcblx0c2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSApO1xyXG5cdHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSApO1xyXG5cclxuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XHJcblxyXG5cdC8vIGZvcmNlIGFuIHVwZGF0ZSBhdCBzdGFydFxyXG5cclxuXHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9yYml0Q29udHJvbHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApO1xyXG5USFJFRS5PcmJpdENvbnRyb2xzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk9yYml0Q29udHJvbHM7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuT3JiaXRDb250cm9scy5wcm90b3R5cGUsIHtcclxuXHJcblx0Y2VudGVyOiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuY2VudGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnRhcmdldCcgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGFyZ2V0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Ly8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxyXG5cclxuXHRub1pvb206IHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVpvb207XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9ab29tIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlWm9vbSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0dGhpcy5lbmFibGVab29tID0gISB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vUm90YXRlOiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9Sb3RhdGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVSb3RhdGUgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiAhIHRoaXMuZW5hYmxlUm90YXRlO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUm90YXRlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUm90YXRlIGluc3RlYWQuJyApO1xyXG5cdFx0XHR0aGlzLmVuYWJsZVJvdGF0ZSA9ICEgdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRub1Bhbjoge1xyXG5cclxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZVBhbjtcclxuXHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5ub1BhbiBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVBhbiBpbnN0ZWFkLicgKTtcclxuXHRcdFx0dGhpcy5lbmFibGVQYW4gPSAhIHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0bm9LZXlzOiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAubm9LZXlzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlS2V5cyBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuICEgdGhpcy5lbmFibGVLZXlzO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLm5vS2V5cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZUtleXMgaW5zdGVhZC4nICk7XHJcblx0XHRcdHRoaXMuZW5hYmxlS2V5cyA9ICEgdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRzdGF0aWNNb3Zpbmc6IHtcclxuXHJcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gISB0aGlzLmVuYWJsZURhbXBpbmc7XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuc3RhdGljTW92aW5nIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlRGFtcGluZyBpbnN0ZWFkLicgKTtcclxuXHRcdFx0dGhpcy5lbmFibGVEYW1waW5nID0gISB2YWx1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGR5bmFtaWNEYW1waW5nRmFjdG9yOiB7XHJcblxyXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5kYW1waW5nRmFjdG9yO1xyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT3JiaXRDb250cm9sczogLmR5bmFtaWNEYW1waW5nRmFjdG9yIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSAuZGFtcGluZ0ZhY3RvciBpbnN0ZWFkLicgKTtcclxuXHRcdFx0dGhpcy5kYW1waW5nRmFjdG9yID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvT3JiaXRDb250cm9scy5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9